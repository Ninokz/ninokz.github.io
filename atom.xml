<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ninokz</title>
  
  <subtitle>你干嘛，哎哟</subtitle>
  <link href="https://ninokz.github.io/atom.xml" rel="self"/>
  
  <link href="https://ninokz.github.io/"/>
  <updated>2024-09-18T14:12:45.372Z</updated>
  <id>https://ninokz.github.io/</id>
  
  <author>
    <name>Ninokz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>All</title>
    <link href="https://ninokz.github.io/2024/09/15/All/"/>
    <id>https://ninokz.github.io/2024/09/15/All/</id>
    <published>2024-09-15T03:26:46.490Z</published>
    <updated>2024-09-18T14:12:45.372Z</updated>
    
    <content type="html"><![CDATA[<h3 id="综合"><a class="header-anchor" href="#综合"></a>综合</h3><ol><li><p>C++ 11新特性</p><blockquote><p>auto; 范围for；lambda与函数闭包；右值引用与移动语义；可变参数模板；初始化列表；强类型枚举；智能指针；<code>nullptr</code>；线程库支持；新的容器；</p></blockquote></li><li><p>单例模式（4种渐进）</p><blockquote><table><thead><tr><th>实现方式</th><th>实现思想</th><th>问题</th></tr></thead><tbody><tr><td><strong>局部静态变量方式</strong></td><td>使用函数内局部静态变量保证单例对象只创建一次</td><td>线程不安全，内存自动管理但不灵活</td></tr><tr><td><strong>静态成员变量指针方式</strong></td><td>静态指针初始化（懒汉式或饿汉式），通过指针管理单例对象</td><td>内存释放困难，多线程环境下二次释放风险</td></tr><tr><td><strong>智能指针方式</strong></td><td>使用 <code>std::shared_ptr</code> 自动管理单例的生命周期</td><td>析构函数暴露，外部可能手动释放导致崩溃，性能有一定开销</td></tr><tr><td><strong>辅助类智能指针方式</strong></td><td>使用自定义删除器防止外部访问析构函数，确保内存安全管理</td><td>实现较复杂，适用于对内存管理要求严格的场景</td></tr></tbody></table></blockquote></li><li><p>TCP&amp;UDP</p><blockquote><p>连接；可靠性；速度；数据流</p></blockquote></li><li><p>左值\右值引用</p><blockquote><p>左右值；引用；移动语义&amp;完美转发</p></blockquote></li><li><p><code>static</code></p><blockquote></blockquote></li><li><p>STL的<code>map</code>类和<code>vector</code></p><blockquote><p>构成（容器；迭代器；适配器；算法；空间配置器；函数对象）；序列容器、容器适配器、关联式容器；</p></blockquote></li><li><p><code>std::move</code></p></li><li><p><code>?_cast&lt;T&gt;</code></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>`、`<span class="keyword">dynamic_cast</span>`、`<span class="keyword">const_cast</span>`、`<span class="keyword">reinterpret_cast</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>智能指针</p></li><li><p>进程通信方式</p><blockquote><p>管道\共享内存\消息队列\套接字\信号\信号量</p></blockquote></li><li><p>多态\多态怎么实现</p><blockquote><p>C++中的多态主要通过虚函数实现。当一个类中的函数被声明为虚函数时，它可以在该类的派生类中被重写，实现运行时多态。在调用时，会根据对象的实际类型来确定调用哪个版本的函数、这个决定是在运行时做出的。这种机制是通过虚函数表来实现的，每个有虚函数的类都有一个对应的虚函数表，表中存储了指向虚函数的指针。通过对象指针或引用调用虚函数时，会根据这个表来动态确定调用哪个函数。</p></blockquote></li><li><p>什么是虚函数</p><blockquote><p>通过在函数声明前添加<code>virtual</code>关键字来定义虚函数。虚函数允许派生类重写（override）基类中的成员函数，<strong>实现运行时多态</strong></p></blockquote></li><li><p>进程线程</p><blockquote><p>进程是操作系统分配资源和调度的基本单位，它包含了运行程序所需的代码、数据以及其他系统资源。线程是进程中的执行流，它是CPU调度和执行的最小单位<br>1.进程拥有独立的地址空间，而同一进程下的线程共享地址空间。<br>2.进程间切换开销较大，线程间切换开销较小，<br>3.进程间通信(IPC)方式多样但相对复杂，线程间可以直接通过读写共享内存来通信，更简单高效。</p></blockquote></li><li><p>死锁//避免死锁</p><blockquote><p>概念\死锁必要条件:互斥条件；持有并等待条件；不可剥夺条件；环路等待条件；</p></blockquote></li><li><p>段\页</p><blockquote><p>1.段:段是一种逻辑地址空间的划分方式，以便将程序分成多个相对独立的部分，例如代码段、数据段等。每个段在逻辑内存中是连续的，但在物理内存中可能不连续。段的大小不固定，由程序所需要的内存量决定。<br>2.页:页是一种物理地址空间的划分方式，将物理内存和逻辑内存都分割成固定大小的块。物理内存的页被称为页框，逻辑内存的页被称为页。通过页表，操作系统可以将逻辑内存的页映射到物理内存的页框，实现内存的虚拟化。段和页的主要区别在于，段是以逻辑的方式进行内存划分</p></blockquote></li><li><p>数据库索引</p><blockquote><p>数据结构快速定位到数据位置</p></blockquote></li><li></li></ol>]]></content>
    
    
    <summary type="html">综合面经合集</summary>
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>Common Summary</title>
    <link href="https://ninokz.github.io/2024/09/02/Common/"/>
    <id>https://ninokz.github.io/2024/09/02/Common/</id>
    <published>2024-09-02T14:42:04.795Z</published>
    <updated>2024-09-15T05:31:46.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Common-Summary"><a class="header-anchor" href="#Common-Summary"></a>Common Summary</h3><p>This markdown is a file which helps me to review OS and NET for interview. 🤓</p><hr><h3 id="OS"><a class="header-anchor" href="#OS"></a>OS</h3><h4 id="进程"><a class="header-anchor" href="#进程"></a>进程</h4><h5 id="进程-线程-协程"><a class="header-anchor" href="#进程-线程-协程"></a>进程\线程\协程</h5><table><thead><tr><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>定义</td><td>资源分配和拥有的基本单位</td><td>程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td>切换情况</td><td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td>保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr><td>切换过程</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td>调用栈</td><td>内核栈</td><td>内核栈</td><td>用户栈</td></tr><tr><td>拥有资源</td><td>CPU资源、内存资源、文件资源和句柄等</td><td>程序计数器、寄存器、栈和状态字</td><td>拥有自己的寄存器上下文和栈</td></tr><tr><td>并发性</td><td>不同进程之间切换实现并发，各自占有CPU实现并行</td><td>一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td>系统开销</td><td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td>切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td>通信方面</td><td>进程间通信需要借助操作系统</td><td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table><ol><li><p>进程是资源分配的基本单位（父进程子进程）</p></li><li><p>线程是资源调度的基本单位，也是程序执行的基本单位，是轻量级的进程</p></li><li><p>协程是用户态的轻量级线程，线程内部调度的基本单位</p></li></ol><h5 id="进程调度算法"><a class="header-anchor" href="#进程调度算法"></a>进程调度算法</h5><p>先来先服务调度算法、最短作业优先调度算法、高响应比优先调度算法、时间片轮转调度算法、最高优先级调度算法、多级反馈队列调度算法</p><h5 id="进程通信方式"><a class="header-anchor" href="#进程通信方式"></a>进程通信方式</h5><p>管道：</p><ul><li>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在父子进程关系使用。</li><li>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，进程之间使用，管道是先进先出的通信方式。</li></ul><p>共享内存：共享内存的机制，虚拟地址空间映射到相同的物理内存</p><p>消息队列：消息队列是保存在内核中的消息链表实现</p><p>套接字：</p><p>信号：</p><p>信号量：信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步</p><h5 id="死锁"><a class="header-anchor" href="#死锁"></a>死锁</h5><p>死锁必要条件:互斥条件；持有并等待条件；不可剥夺条件；环路等待条件；</p><h5 id="死锁处理"><a class="header-anchor" href="#死锁处理"></a>死锁处理</h5><p>主要是死锁预防和死锁避免</p><h5 id="锁种类"><a class="header-anchor" href="#锁种类"></a>锁种类</h5><p>互斥锁：<strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</p><p>自旋锁：<strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</p><p>读写锁：读写互斥，写互斥，读不互斥；</p><p>乐观锁：修改完了后验证</p><p>悲观锁：用就上锁</p><h5 id="原子操作"><a class="header-anchor" href="#原子操作"></a>原子操作</h5><p>缓存锁和总线锁</p><h5 id="动态分区分配算法"><a class="header-anchor" href="#动态分区分配算法"></a>动态分区分配算法</h5><p>首次适应、最佳适应、最坏适应、邻近适应</p><h4 id="内存管理"><a class="header-anchor" href="#内存管理"></a>内存管理</h4><h5 id="虚拟内存"><a class="header-anchor" href="#虚拟内存"></a>虚拟内存</h5><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>通过页表\段表实现，即页式和段式</p><h5 id="虚拟内存访存"><a class="header-anchor" href="#虚拟内存访存"></a>虚拟内存访存</h5><blockquote><ol><li><strong>TLB 查找</strong>：当处理器要访问一个虚拟地址时，首先检查快表（TLB）。TLB 是一个缓存，用来存储最近使用的页表项（PTE）。如果虚拟地址的页表项在 TLB 中找到（称为 TLB 命中），则可以直接获得物理地址。<ul><li><strong>TLB 命中</strong>：如果 TLB 中找到了对应的页表项，那么可以直接获得物理地址，从而跳过下面的页表访问步骤。这时，只需一次内存访问（从物理地址访问数据）。</li><li><strong>TLB 未命中</strong>：如果 TLB 中没有找到对应的页表项，那么需要通过页表查找来获得物理地址。</li></ul></li><li><strong>页表查找</strong>：<ul><li>如果 TLB 未命中，处理器会读取页表来查找对应的物理地址。页表查找可能需要多个内存访问（通常是 2-3 次，具体取决于页表结构，如二级页表或多级页表）。</li><li><strong>一级页表</strong>：首先查找一级页表的入口，访问一级页表来找到对应的二级页表的地址。</li><li><strong>二级页表</strong>：接着查找二级页表，获取物理页框号（PFN），从而计算出最终的物理地址。</li><li>在每次页表查找过程中，相关的页表项可以被加载到 TLB 中，以便后续访问能更快地找到对应的物理地址。</li></ul></li><li><strong>数据访问</strong>：一旦得到了物理地址，处理器就可以访问对应的物理内存单元，读取或写入数据。</li></ol></blockquote><h5 id="页面置换算法"><a class="header-anchor" href="#页面置换算法"></a>页面置换算法</h5><table><thead><tr><th></th><th>算法规则</th><th>优缺点</th></tr></thead><tbody><tr><td>OPT</td><td>优先淘汰最长时间内不会被访问的页面</td><td>缺页率最小，性能最好;但无法实现</td></tr><tr><td>FIFO</td><td>优先淘汰最先进入内存的页面</td><td>实现简单;但性能很差，可能出现Belady异常</td></tr><tr><td>LRU</td><td>优先淘汰最近最久没访问的页面</td><td>性能很好;但需要硬件支持，算法开销大</td></tr><tr><td>CLOCK (NRU)</td><td>循环扫描各页面。第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第一轮没选中，则进行第二轮扫描。</td><td>实现简单，算法开销小;但未考虑页面是否被修改过。</td></tr><tr><td>改进型CLOCK (改进型NRU)</td><td>若用(访问位，修改位)的形式表述，则 第一轮:淘汰(0,0) 第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0) 第四轮:淘汰(0, 1)</td><td>算法开销</td></tr></tbody></table><hr><h3 id="NET"><a class="header-anchor" href="#NET"></a>NET</h3><h4 id="TCP-IP四层模型"><a class="header-anchor" href="#TCP-IP四层模型"></a>TCP/IP四层模型</h4><p>应用层：负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;</p><p>传输层（TCP 和 UDP）：负责端到端的通信，比如 TCP、UDP 等；</p><blockquote><p>T&amp;U区别：连接、可靠性、速度、数据流四个方面去描述</p></blockquote><p>网际层（IP等）：负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；</p><p>链路层（网络接口层）：负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等</p><h4 id="HTTP"><a class="header-anchor" href="#HTTP"></a>HTTP</h4><p>概况：超文本传输协议，定义了Web Client向Web Server请求Web页面的方式，是无状态的协议；同时其还有持续链接和非持续连接传输方式；</p><h5 id="请求-响应报文格式-常见字段"><a class="header-anchor" href="#请求-响应报文格式-常见字段"></a>请求\响应报文格式\常见字段</h5><p><code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以请求复用</p><h5 id="GET-POST"><a class="header-anchor" href="#GET-POST"></a>GET&amp;POST</h5><p>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。但实际上不一定，上述只是RFC的规定。</p><h5 id="Cookie机制"><a class="header-anchor" href="#Cookie机制"></a>Cookie机制</h5><h5 id="Web缓存器"><a class="header-anchor" href="#Web缓存器"></a>Web缓存器</h5><p>代理服务器，代表初始Web服务器满足请求的网络实体，内部有最近请求过的对象副本。视作互联网中的LRUCache</p><h5 id="条件GET（协商缓存）和本地缓存（强制缓存）"><a class="header-anchor" href="#条件GET（协商缓存）和本地缓存（强制缓存）"></a>条件GET（协商缓存）和本地缓存（强制缓存）</h5><p>If-Modified-Since首部行完成</p><h5 id="1-0-1-1-2-0-3-0"><a class="header-anchor" href="#1-0-1-1-2-0-3-0"></a>1.0\1.1\2.0\3.0</h5><p>1.0是非持续连接传输方式；1.1采用持续链接传输方式；无状态（cookie解决），明文不安全；</p><p>2.0进行头部压缩和二进制格式头信息和数据体，并发传输，不阻塞</p><p>3.0改为UDP的QUIC协议</p><h5 id="HTTP-HTTPS"><a class="header-anchor" href="#HTTP-HTTPS"></a>HTTP\HTTPS</h5><p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。通过证书CA验证\公钥私钥非对称加密\对称加密技术实现安全可靠的传输；机密性、完整性、可用性</p><ol><li>建立连接时候：https 比 http多了 TLS 的握手过程；</li><li>传输内容的时候：https 会把数据进行加密，通常是对称加密数据；</li></ol><h4 id="Websocket"><a class="header-anchor" href="#Websocket"></a>Websocket</h4><p>服务器主动推送数据到客户端的场景，HTTP半双工，而Websocket实现了全双工web</p><h4 id="TCP"><a class="header-anchor" href="#TCP"></a>TCP</h4><p>格式：（主要区别于UDP）</p><p>概念：<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</p><h5 id="建立连接"><a class="header-anchor" href="#建立连接"></a>建立连接</h5><p>三次握手才可以阻止重复历史连接的初始化（主要原因）</p><p>三次握手才可以同步双方的初始序列号</p><p>三次握手才可以避免资源浪费</p><h5 id="断开连接"><a class="header-anchor" href="#断开连接"></a>断开连接</h5><p>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据；服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，但可能还有数据发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接</p><p><strong>TIME_WAIT 2MSL:</strong></p><ul><li>TIME_WAIT?</li></ul><p>确保本次连接产生的报文均已经过期不会影响后续的连接过程</p><p>防止SERVER因ACK丢失而挂起</p><ul><li>2MSL?:</li></ul><p>1.确保本次连接产生的报文均已经过期不会影响后续的连接过程</p><p>2.确保最后一个ACK抵达，若不抵达则在2MSL内必定收到回复</p><h5 id="TCP机制"><a class="header-anchor" href="#TCP机制"></a>TCP机制</h5><p>重传：超时重传、快速重传</p><p>流量控制：通过滑动窗口机制实现，即防止发送方发的速度过快淹没接收方，协调双方的收发速率</p><p>拥塞控制：通过慢启动和拥塞避免快恢复完成拥塞控制，防止主机向链路发送过多的数据导致链路阻塞。</p><h4 id="IP"><a class="header-anchor" href="#IP"></a>IP</h4><hr><h3 id="问题记录"><a class="header-anchor" href="#问题记录"></a>问题记录</h3><h4 id="操作系统"><a class="header-anchor" href="#操作系统"></a>操作系统</h4><ul><li>线程和进程的区别、应用场景。</li><li>多线程中各种锁，读写锁，互斥锁</li><li>内存池</li><li>内存管理</li><li>内存写漏</li><li>如果频繁进行内存的分配释放会有什么问题吗？</li><li>如果频繁分配释放的内存很大（&gt;128k）,怎么处理？</li><li>虚拟内存以及堆栈溢出相关的问题，堆栈溢出怎么处理等等。</li><li>分段和分页的区别</li><li>进程间通信原理和方式</li><li>fork()读时共享写时拷贝</li><li>互斥锁+条件变量</li><li>堆和栈的区别。什么情况下会往堆里放</li><li>fork函数返回值是怎么实现的</li><li>用户级线程和内核级线程的区别</li><li>线程池和线程开销</li><li>线程切换的到底是什么</li><li>线程同步共享怎么实现</li><li>互斥同步的方法</li><li>信号量和自旋锁的区别</li><li>查看磁盘、cpu 占用、内存占用命令</li><li>linux虚拟地址空间结构/动态库地址无关代码</li><li>top命令排查高占有率进程/top命令的占用率怎么算的</li><li>谈谈进程创建后在Linux中的内存分布？（回答内存四区，虚拟地址空间，栈内存堆内存）</li><li>在Linux系统下，使用for循环，一直进行new操作，会发生heap-overflow吗？如果不会，原因呢？（答应该不会，Linux系统可能会对此情况进行处理，面试官追问如果不用C++而用Java呢，答Java虚拟机等，胡扯了一些）</li><li>死锁的概念，进程调度算法怎么解决死锁</li><li>讲讲进程管理</li><li>除了MQ和websocket之外，你还能想到什么异步通信的办法？</li><li>为什么要用多线程。多进程可以吗（webserver的）</li><li>为什么要用线程池，线程池中的线程是怎么运作的?</li><li>生产者消费者，信号量的使用</li><li>队列空时，消费者和生产者会发生什么 线程池请求队列是用什么实现的？（链表）</li><li>.C++多线程并发问题（场景千万级数量级怎么处理）</li><li>哪几种常见的 signal? SIGSEGV… -&gt; 正常终止程序的信号？-&gt; kill 进程，几号信号？</li><li>什么情况下会使用静态变量</li><li>多线程读写同一个静态变量你是怎么解决的</li><li>用过无锁编程吗，知道原子量吗</li></ul><h4 id="计算机网络"><a class="header-anchor" href="#计算机网络"></a>计算机网络</h4><ul><li>为什么握手是三次而挥手需要四次</li><li>tcp和udp的原理、区别、应用场景。</li><li>TCP慢启动，拥塞控制实现</li><li>HTTP是在OSI模型的哪一层</li><li>HTTPS用到的是对称加密还是非对称加密？分别体现在哪里？</li><li>http2和http1的区别</li><li>http1.0 / 1.1 / 2 / 3</li><li>get和post区别</li><li>WebSockt</li><li>tcp/ip五层模型</li><li>dns服务器用的是什么协议。</li><li>ping命令 用的是什么协议。在哪一层。</li><li>能详细讲一下有限状态机怎么解析http报文吗</li><li>如果解析http请求的时候，用户一次性没传完数据，（如果头部都没传完，请求报文长度字段都没传完，怎么办）</li><li>路由表说一下</li><li>路由表为空怎么找到下一跳</li><li>粘包拆包是什么，发生在哪一层</li><li>TCP在什么情况下会出现大量time_wait，哪个阶段出现</li><li>TCP 包头字段… 标志位-&gt; 建立连接过程，终止连接过程-&gt; TIME_WAIT, CLOSE_WAIT 分析，属于哪一方？</li><li>TCP 建立连接过程 -&gt; SYN + ACK 包能不能拆开来发</li><li>讲讲quic/听说过哪些快速重传算法/timewait状态干啥用的</li><li>提到了TCP，黏包怎么解决？（固定包头接收，指定内存长度）</li><li>查看网络状况（以为是netstate，其实是ping、traceroute，紧张忘记说了）</li><li>抓包工具？（wireshark，紧张又给忘了靠）</li><li>TCP 2MSL说一下，为什么</li></ul><h4 id="设计模式"><a class="header-anchor" href="#设计模式"></a>设计模式</h4><ul><li>什么是设计模式？为什么使用设计模式？</li><li>列举常见的设计模式分类，并简要描述每个分类中的几个具体设计模式。</li><li>解释单例模式的概念和用途，以及如何实现单例模式。</li><li>什么是工厂方法模式和抽象工厂模式？它们之间有何区别？</li><li>解释装饰器模式和适配器模式的概念，并举例说明它们的应用场景。</li><li>什么是观察者模式？如何实现观察者模式？</li><li>解释策略模式和状态模式之间的区别，以及在什么情况下使用它们。</li><li>什么是迭代器模式和组合模式？它们可以一起使用吗？</li><li>解释桥接模式和适配器模式之间的区别，并说明在哪种情况下选择使用桥接或适配器。</li><li>介绍责任链模式和命令模式的概念，并说明它们如何解耦发送者和接收者。</li><li>单例模式实现区别</li><li>策略模式实现</li></ul><h4 id="RPC"><a class="header-anchor" href="#RPC"></a>RPC</h4><ul><li>什么是RPC？请简要描述RPC的概念和工作原理。</li><li>RPC与HTTP之间有什么区别？它们各自适用于哪些场景？</li><li>RPC框架有哪些常见的实现方式？例如，基于TCP/UDP、HTTP、消息队列等。</li><li>请解释一下序列化和反序列化在RPC中的作用，以及常用的序列化方式有哪些？</li><li>在RPC通信中，如何处理服务发现和负载均衡？</li><li>RPC框架如何保证通信的安全性？可以谈谈认证、加密和防止恶意攻击等方面。</li><li>如何处理分布式系统中的幂等性问题？</li><li>常见的跨语言RPC框架有哪些？比较它们的特点和优劣势。</li><li>如何进行RPC接口版本控制和演进？请分享一些实践经验。</li><li>谈谈你对于微服务架构中使用RPC的看法，并解释为什么选择使用RPC而不是其他通信方式。</li><li>grpc怎么用的</li><li>为什么grpc速度快</li><li>rpc调用流程和机制，rpc超时计时器在什么位置，如果调用超时了怎么处理，当前连接还能继续使用吗</li></ul>]]></content>
    
    
    <summary type="html">通识知识点总结</summary>
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
    <category term="OS" scheme="https://ninokz.github.io/tags/OS/"/>
    
    <category term="NET" scheme="https://ninokz.github.io/tags/NET/"/>
    
  </entry>
  
  <entry>
    <title>Test Summary</title>
    <link href="https://ninokz.github.io/2024/09/01/Test-Summary/"/>
    <id>https://ninokz.github.io/2024/09/01/Test-Summary/</id>
    <published>2024-09-01T13:22:50.953Z</published>
    <updated>2024-09-02T14:28:36.368Z</updated>
    
    <content type="html"><![CDATA[<h3 id="测试面经"><a class="header-anchor" href="#测试面经"></a>测试面经</h3><h4 id="理论"><a class="header-anchor" href="#理论"></a>理论</h4><h5 id="测试目的"><a class="header-anchor" href="#测试目的"></a>测试目的</h5><p>测试的目的是找出软件产品中的错误，是软件尽可能的符合用户的要求，保证质量</p><h5 id="软件测试分类"><a class="header-anchor" href="#软件测试分类"></a>软件测试分类</h5><h6 id="黑盒测试-白盒测试"><a class="header-anchor" href="#黑盒测试-白盒测试"></a>黑盒测试\白盒测试</h6><p>黑盒测试也称为功能测试，是在不考虑内部代码结构和实现的情况下，基于软件功能和需求规格进行的测试。</p><p><strong>测试方法</strong>：包括等价类划分、边界值分析、决策表测试、错误推测法等</p><p>白盒测试也称为结构测试，是在了解软件内部代码结构和实现的基础上，对软件进行的测试，测试人员需要了解程序的逻辑流、算法和代码实现。</p><p><strong>测试方法</strong>：包括语句覆盖、分支覆盖、路径覆盖、条件覆盖等</p><h6 id="功能测试"><a class="header-anchor" href="#功能测试"></a>功能测试</h6><p>也叫黑盒测试，是软件测试中的一种类型，专注于验证软件系统的每个功能是否按照需求规格说明书的描述正确工作</p><p>包含的主要类型和流程：</p><ol><li><strong>单元测试</strong>：验证软件的最小可测试部分（通常是函数或方法）的功能是否正确。</li><li><strong>集成测试</strong>：在不同模块或组件之间的接口处进行测试，以确保它们能够正确交互和集成。</li><li><strong>系统测试</strong>：对整个系统进行全面测试，以验证它在预期环境中的功能和行为。</li><li><strong>验收测试</strong>：由最终用户或客户执行，目的是验证系统是否满足业务需求和用户需求，通常是在系统交付之前进行的最后一步。</li></ol><blockquote><p>单元测试（详细设计）、集成测试（概要设计）、系统测试（需求分析）、验收测试（用户需求）</p><p>测试的目的是找出软件产品中的错误，是软件尽可能的符合用户的要求。当然软件测试是不可能找出全部错误的</p><p>1-单元测试(模块测试)是开发者编写的一小段代码，用于检验被测试代码的一个很小的、很明确的功能是否正确。</p><p>2-集成测试(也叫组装测试、联合测试)是单元测试的逻辑扩展。它最简单的形式是：两个已经经过测试的单元组合成一个组件，并且测试它们之间的接口。</p><p>3-系统测试是将经过测试的子系统装配成一个完整系统来测试。它是检验系统是否确实能提供系统方案说明书中制定功能的有效方法。</p><p>4-验收测试是部署软件之前的最后一个测试操作。验收测试的目的是确保软件准备就绪，并且可以让用户将其执行软件的既定功能和任务。</p></blockquote><h6 id="性能测试"><a class="header-anchor" href="#性能测试"></a>性能测试</h6><p>性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试；</p><p>特点：关注响应速度，吞吐量，稳定性，性能瓶颈</p><h6 id="接口测试"><a class="header-anchor" href="#接口测试"></a>接口测试</h6><p>API测试，是软件测试中的一种类型，专注于验证不同软件系统组件之间的接口是否正确工作。接口测试的目的是确保这些组件之间的数据交换和交互按照预期进行，且数据传递过程中没有丢失、篡改或出现错误。</p><h5 id="测试用例设计方法"><a class="header-anchor" href="#测试用例设计方法"></a>测试用例设计方法</h5><p><strong>等价类划分</strong><br>将输入数据划分为若干等价类，每个类中的所有数据应被系统同样处理。对于每个等价类，只需选取一个代表值进行测试。<br><strong>边界值分析法</strong><br>边界值分析专注于输入数据的边界条件，因为系统在边界条件下更容易出现错误。通常包括最小值、最大值、刚好大于和小于边界的值。</p><p><strong>决策表测试</strong></p><p>决策表是一种列举输入条件组合及其对应操作结果的表格，用于系统性地考虑所有可能的输入情况及其输出</p><p><strong>错误推测法</strong></p><p>基于经验和对系统的理解，测试人员通过猜测可能的错误或薄弱点来设计测试用例。</p><p><strong>因果图方法</strong></p><p>因果图分析通过图形化表示输入条件（原因）与系统输出（结果）之间的关系，有助于识别输入条件的所有可能组合及其影响。</p><h5 id="测试计划"><a class="header-anchor" href="#测试计划"></a>测试计划</h5><p>软件测试计划是知道测试过程的纲领性文件，包含了产品概述、测试策略、测试方法、测试区域、测试配置、测试周期、测试资源、测试交流、风险分析等内容。借助软件测试计划，参与测试的项目成员，尤其是测试管理人员，可以明确测试任务和测试方法，保持测试实施过程的顺畅沟通，跟踪和控制测试进度，应对测试过程中的各种变更。</p><h5 id="测试过程"><a class="header-anchor" href="#测试过程"></a>测试过程</h5><p>1-项目经理通过和客户的交流，完成需求文档，由开发人员和测试人员共同完成需求文档的评审</p><p>2-开发人员根据需求文档完成需求分析文档，测试人员进行评审，评审的主要内容包括是否有遗漏或者双方理解不同的地方，测试人员完成测试计划文档</p><p>3-测试人员根据修改好的需求分析文档开始写测试用例，同时开发人员完成概要设计文档，详细设计文档。此两份文档成为测试人员撰写测试用例的补充材料。</p><p>4-测试用例完成后，测试和开发需要进行评审。</p><p>5-测试人员搭建环境</p><p>6-开发人员提交第一个版本，可能存在未完成功能，需要说明。测试人员进行测试，发现bug后提交</p><p>7-开发提交第二个版本，包括bug fix以及增加了部分功能，测试人员进行测试。</p><p>8-重复上面的工作，一般是3-4个版本后bug数量减少，达到出货的要求。</p><p>9-如果有客户反馈的问题，需要测试人员协助重现以及回归测试。</p><blockquote><p>需求调查：全面了解项目概况</p><p>制定计划</p><p>测试准备：组织测试团队、培训、建立测试和管理环境等。</p><p>测试设计：按照测试要求进行每个测试项的测试设计，包括测试用例的设计和测试脚本的开发等。</p><p>测试实施：按照测试计划实施测试。</p><p>测试评估：根据测试的结果，出具测试评估报告。</p></blockquote><h5 id="BUG-缺陷报告"><a class="header-anchor" href="#BUG-缺陷报告"></a>BUG\缺陷报告</h5><p>日期、ID、缺陷名称、缺陷描述、缺陷类型、缺陷优先级、期望结果、实际结果、环境信息、缺陷复现步骤、指派与状态</p><h5 id="如何测试一个APP"><a class="header-anchor" href="#如何测试一个APP"></a>如何测试一个APP</h5><ol><li><p>测试计划和分析</p></li><li><p>测试用例设计</p></li><li><p>设置测试环境</p></li><li><p>执行功能性测试</p><ul><li><strong>功能测试</strong>：验证每个功能是否按预期工作。</li><li><strong>回归测试</strong>：在修复Bug或新增功能后，进行回归测试，确保其他功能未受到影响。</li><li><strong>集成测试</strong>：测试各个模块或组件之间的交互是否正常。</li><li><strong>系统测试</strong>：整体测试系统的所有功能和模块是否正常工作</li></ul></li><li><p>执行非功能性测试</p><ul><li><strong>性能测试</strong>：检查系统的响应时间、吞吐量和稳定性。在Web系统中，这通常包括负载测试、压力测试和容量测试。</li><li><strong>安全测试</strong>：检查系统是否存在安全漏洞，例如SQL注入、跨站脚本攻击（XSS）、认证和授权问题。</li><li><strong>兼容性测试</strong>：验证系统在不同的硬件、操作系统、浏览器和设备上是否兼容。</li></ul></li><li><p>缺陷报告和跟踪</p></li><li><p>回归测试</p></li><li><p>用户验收测试</p></li><li><p>全回归测试</p><p>对整个系统进行完整的回归测试确保所有功能和性能指标符合要求</p></li><li><p>持续监控和优化</p></li></ol>]]></content>
    
    
    <summary type="html">测试知识点总结新版</summary>
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
    <category term="Test" scheme="https://ninokz.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode</title>
    <link href="https://ninokz.github.io/2024/09/01/Algorithms-Summary/"/>
    <id>https://ninokz.github.io/2024/09/01/Algorithms-Summary/</id>
    <published>2024-09-01T06:19:54.651Z</published>
    <updated>2024-09-02T14:52:24.894Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Algorithms-Summary"><a class="header-anchor" href="#Algorithms-Summary"></a>Algorithms Summary</h3><p>This markdown is a file which helps me to review algorithms for interview. 🤗</p><hr><h4 id="链表篇"><a class="header-anchor" href="#链表篇"></a>链表篇</h4><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">ListNode* cur1 = list1;</span><br><span class="line">ListNode* cur2 = list2;</span><br><span class="line"><span class="function">ListNode <span class="title">tempHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">ListNode* cur = &amp;tempHead;</span><br><span class="line"><span class="keyword">while</span> (cur1 &amp;&amp; cur2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur1-&gt;val &lt; cur2-&gt;val) &#123;</span><br><span class="line">cur-&gt;next = cur1;</span><br><span class="line">cur1 = cur1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cur-&gt;next = cur2;</span><br><span class="line">cur2 = cur2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur1) cur-&gt;next = cur1;</span><br><span class="line"><span class="keyword">if</span> (cur2) cur-&gt;next = cur2;</span><br><span class="line"><span class="keyword">return</span> tempHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/partition-list/">86</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">dummy1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">dummy2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">ListNode* p1 = &amp;dummy1, * p2 = &amp;dummy2;</span><br><span class="line"><span class="keyword">while</span> (head) &#123;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;val &lt; x)</span><br><span class="line">&#123;</span><br><span class="line">p1-&gt;next = head;</span><br><span class="line">p1 = p1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p2-&gt;next = head;</span><br><span class="line">p2 = p2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p1-&gt;next = dummy2.next;</span><br><span class="line">p2-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> dummy1.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> cmp = [](ListNode* a, ListNode* b) &#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;;</span><br><span class="line">priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> list : lists)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ListNode* node = list; node != <span class="literal">nullptr</span>; node = node-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">pq.<span class="built_in">push</span>(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">ListNode* tail = &amp;dummy;</span><br><span class="line"><span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">tail-&gt;next = pq.<span class="built_in">top</span>();</span><br><span class="line">pq.<span class="built_in">pop</span>();</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">算法刷题新版</summary>
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
    <category term="Practices" scheme="https://ninokz.github.io/tags/Practices/"/>
    
  </entry>
  
  <entry>
    <title>C++ Summary</title>
    <link href="https://ninokz.github.io/2024/08/29/C++-Summary/"/>
    <id>https://ninokz.github.io/2024/08/29/C++-Summary/</id>
    <published>2024-08-29T12:32:58.961Z</published>
    <updated>2024-09-15T03:23:21.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-Summary"><a class="header-anchor" href="#C-Summary"></a>C++ Summary</h3><p>This markdown is a file which helps me to review cc for interview. 🤓</p><hr><h4 id="内存管理-🔧"><a class="header-anchor" href="#内存管理-🔧"></a>内存管理 🔧</h4><h5 id="图示"><a class="header-anchor" href="#图示"></a>图示</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|Text| low address //代码区（文本段）</span><br><span class="line">|---------------|</span><br><span class="line">|data|// 数据区</span><br><span class="line">|segment|</span><br><span class="line">|---------------|</span><br><span class="line">|HEAP|// 向高地址增长</span><br><span class="line">|---------------|</span><br><span class="line">| 空闲 |</span><br><span class="line">| 内存 |</span><br><span class="line">|---------------|</span><br><span class="line">|stack| high address // 向低地址增长</span><br></pre></td></tr></table></figure><p><strong>代码段</strong>：它包含可执行指令（机器代码），代码段通常是只读，即程序代码区</p><p><strong>数据段</strong>：</p><p><strong>初始化数据段</strong>：所有<strong>全局、静态static和常量数据</strong>都存储在数据段中，即静态存储区 .data (<code>const</code>变量虽然属于常量，但是本质还是变量，不存储于代码段)</p><p><strong>Data 段</strong>：</p><ul><li>分为 <strong>已初始化数据段</strong> 和 <strong>常量数据段</strong>。</li><li><strong>已初始化数据段</strong>：存储显式初始化为非 0 的全局变量和静态变量。</li><li><strong>常量数据段</strong>：存储只读的数据，如字符串字面量和 <code>const</code> 修饰的全局变量。</li></ul><p><strong>未初始化数据段</strong>：所有未初始化的全局变量和静态变量都存储在该段中，也称为BSS段.bss</p><p><strong>BSS 段</strong>：</p><ul><li>存储所有未显式初始化或初始化为 0 的全局变量和静态变量。</li><li>这些变量在程序运行时自动初始化为 0。</li><li>BSS 段在编译后的可执行文件中并不占用实际空间，因为它只记录了需要多少空间，而在程序运行时由操作系统分配和清零。</li></ul><p><strong>堆段</strong>：当程序在运行时使用<code>calloc</code>和<code>malloc</code>函数分配内存时，内存在堆中分配，向高地址增长<br><strong>栈段</strong>：栈用于存储<strong>局部变量</strong>、<strong>函数参数</strong>和其他与函数相关的信息，向低地址增长</p><h5 id="堆栈区别"><a class="header-anchor" href="#堆栈区别"></a>堆栈区别</h5><table><thead><tr><th></th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td><strong>管理方式</strong></td><td>堆中资源由程序员控制（容易产生memory leak）</td><td>栈资源由编译器自动管理，无需手工控制</td></tr><tr><td><strong>内存管理机制</strong></td><td>系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序</td><td>只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出</td></tr><tr><td><strong>空间大小</strong></td><td>堆是不连续的内存区域</td><td>栈是一块连续的内存区域</td></tr><tr><td><strong>碎片问题</strong></td><td>对于堆，频繁的new/delete会造成大量碎片，使程序效率降低</td><td>对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片</td></tr><tr><td><strong>生长方向</strong></td><td>向高地址方向增长。</td><td>向低地址方向增长</td></tr><tr><td><strong>分配效率</strong></td><td>堆由C/C++函数库提供，效率低</td><td>栈是其系统提供的数据结构，<strong>计算机在底层对栈提供支持，效率高</strong></td></tr></tbody></table><h5 id="变量问题"><a class="header-anchor" href="#变量问题"></a>变量问题</h5><p><strong>作用域</strong>：</p><p>全局变量：全局作用域，可以通过extern作用于其他非定义的源文件。</p><p>静态全局变量 ：全局作用域+文件作用域，所以无法在其他文件中使用。只能在本源文件中使用</p><p>局部变量：局部作用域，函数内的变量等</p><p>静态局部变量 ：局部作用域，只被初始化一次，直到程序结束</p><p><strong>所在空间</strong>：</p><p>除了局部变量在栈上外，其他都在静态存储区</p><p><strong>生命周期</strong>：</p><p>局部变量在栈上，出了作用域就回收内存；而全局变量、静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存</p><p><strong>静态变量什么时候初始化</strong></p><p>C语言：全局和静态变量初始化发生在任何代码执行之前，属于编译期初始化。</p><p>C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造</p><p><strong>静态成员函数不能访问非静态成员</strong></p><p>静态成员函数不属于任何一个对象，因此<strong>C++规定静态成员函数没有this指针</strong>，只能访问静态成员，不能访问普通成员</p><table><thead><tr><th>区域名称</th><th>用途</th><th>内存管理</th><th>生命周期</th><th>典型存储内容</th></tr></thead><tbody><tr><td><strong>静态存储区</strong></td><td>存储全局变量、静态变量和常量</td><td>自动分配</td><td>从程序开始到结束</td><td>全局变量、静态变量、常量字符串</td></tr><tr><td><strong>栈区</strong></td><td>存储局部变量、函数参数和返回地址</td><td>自动分配和释放</td><td>函数调用期间</td><td>局部变量、函数参数、返回地址</td></tr><tr><td><strong>堆区</strong></td><td>动态内存分配</td><td>手动分配和释放</td><td>由程序员控制</td><td>动态分配的内存（如对象、数组）</td></tr><tr><td><strong>常量区</strong></td><td>存储程序代码和常量</td><td>自动分配</td><td>程序运行期间</td><td>字符串字面量、程序代码</td></tr></tbody></table><p><strong><code>static</code></strong></p><p><strong>隐藏</strong>：静态函数或静态全局变量只能在本源文件中使用</p><p><strong>持久性</strong>：在数据段分配内存，维护值直到程序结束</p><p><strong>默认值0</strong>：默认初始化为 0</p><h5 id="内存泄露"><a class="header-anchor" href="#内存泄露"></a>内存泄露</h5><p><code>new</code>和<code>malloc</code>申请资源使用后，没有用<code>delete</code>和<code>free</code>释放；子类继承父类时，父类析构函数不是虚函数；资源句柄未释放；智能指针<code>shared_ptr</code>形成环形引用，无法释放</p><h5 id="内存碎片"><a class="header-anchor" href="#内存碎片"></a>内存碎片</h5><h5 id="内存池"><a class="header-anchor" href="#内存池"></a>内存池</h5><h5 id="内存泄漏检测方法"><a class="header-anchor" href="#内存泄漏检测方法"></a>内存泄漏检测方法</h5><p>Windows上除了使用VS自带的性能检测窗口观察内存分配，还可以使用<code>_CrtDumpMemoryLeaks();</code>调试时输出窗口会输出内存泄漏的消息。</p><p>Linux上使用 Val grind</p><hr><h4 id="内存模型🍳"><a class="header-anchor" href="#内存模型🍳"></a>内存模型🍳</h4><h5 id="内存分区模型"><a class="header-anchor" href="#内存分区模型"></a>内存分区模型</h5><h5 id="内存顺序模型"><a class="header-anchor" href="#内存顺序模型"></a>内存顺序模型</h5><p><strong>概念</strong>：内存模型是描述编程语言在支持多线程编程中对共享内存访问的顺序,主要目的是为了确保在多线程环境中，程序行为是可预测的且一致的。</p><blockquote><p>在多线程环境下，不同的线程可以同时访问和修改相同的内存位置。这种并发访问会导致**数据竞争（Data Race）<strong>和</strong>指令重排序（Instruction Reordering）**等问题。因此，需要一种机制来约束线程之间的内存访问顺序，这就是内存模型的核心任务</p><p>现代处理器和编译器为了优化性能，可能会对指令进行重排序（Out-of-Order Execution）或缓存一致性操作,在多线程环境下可能导致不可预期的行为,<strong>缓存效应（Cache Effects）<strong>与</strong>指令重排序（Instruction Reordering）</strong></p><ul><li><strong>缓存效应（Cache Effects）</strong>：一个线程的内存修改可能被暂时保存在其本地缓存中，而其他线程看到的仍然是旧值。</li><li><strong>指令重排序（Instruction Reordering）</strong>：编译器或CPU可能会改变指令的执行顺序以优化性能，这可能导致一个线程看到的内存操作顺序与另一个线程不一致。</li></ul></blockquote><p><strong>内存顺序</strong>：</p><p><strong>关系</strong></p><blockquote><p><strong>sequenced-before</strong></p><p>单线程下A指令序列先于B</p><p><strong>happens-before</strong></p><p>多线程下A指令序列先于B</p><p><strong>synchronizes-with</strong></p><p>线程修改某变量的之后的结果能被其它线程可见</p><p><strong>Carries dependency</strong></p><p>同一个线程内，表达式A sequenced-before 表达式B，并且表达式B的值是受表达式A的影响的一种关系</p></blockquote><p><strong>6种顺序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,<span class="comment">// no sync</span></span><br><span class="line">    memory_order_consume,<span class="comment">// message passing 执行于本操作之前的所有操作后</span></span><br><span class="line">    memory_order_acquire,<span class="comment">// message passing 执行于本操作之前的所有读操作后</span></span><br><span class="line">    memory_order_release,<span class="comment">// message passing 执行于本操作之前的所有写操作后</span></span><br><span class="line">    memory_order_acq_rel,<span class="comment">// message passing</span></span><br><span class="line">    memory_order_seq_cst<span class="comment">// total order</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由上至下为宽松到严格</p><hr><h4 id="关键字-🔑"><a class="header-anchor" href="#关键字-🔑"></a>关键字 🔑</h4><h5 id="volatile-与mutable"><a class="header-anchor" href="#volatile-与mutable"></a><code>volatile </code>与<code>mutable</code></h5><ul><li>概念</li></ul><p><code>mutable</code>：被mutable修饰的变量，将永远处于可变的状态，即使处于<code>const</code>修饰</p><p><code>volatile </code>：关键字可以用来提醒编译器使用 volatile 声明的变量随时有可能改变，要求取内存读取值而非寄存器读取</p><p><code>volatile </code>主要有三个应用场景：</p><p>（1）外围设备的特殊功能寄存器。</p><p>（2）在中断服务函数中修改全局变量。</p><p>（3）在多线程中修改全局变量(多线程中修改全局变量存在什么问题？怎么解决?)</p><h5 id="const"><a class="header-anchor" href="#const"></a><code>const</code></h5><ul><li>概念</li></ul><p>对被修饰对象进行限定，在初始化后对象在后续过程中不能进行修改操作，类似于将其视作常量。4种修饰类型：修饰变量、修饰指针、修饰引用、修饰函数</p><p>对于局部常量，存放在栈区； 对于全局常量，编译期⼀般不分配内存，有时编译器会把放在符号表中以提⾼访问效率；字⾯值常量，⽐如字符串，放在常量区；</p><p><code>const </code>指针</p><p>底层const和顶层const</p><p>​<strong>顶层</strong>const：指的是const修饰的变量<strong>本身</strong>是一个常量，无法修改，指的是指针，就是 * 号的右边</p><p>​<strong>底层</strong>const：指的是const修饰的变量<strong>所指向的对象</strong>是一个常量，指的是所指变量，就是 * 号的左边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// 顶层const</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* c = &amp;a; <span class="comment">// 底层const, 指向对象不可更改</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> d = &amp;b; <span class="comment">// 顶层const, 指针自身不能更改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> e = &amp;a; <span class="comment">// 前一个为底层const 后一个为顶层const</span></span><br></pre></td></tr></table></figure><p><strong>顶层const</strong>和<strong>底层const</strong>：从以下代码看出const修饰的影响，前者表示指针本身是常量（不可更改），后者表示指针所指对象是常量（对象不可更改）。通常意义上来讲顶层const的限制弱于底层 const。所以在进行拷贝操作时，<strong>顶层const基本上不受影响，而底层const的限制性更大</strong>，当进行拷贝考入考出时，左右对象必须是相同的底层const资格（因为执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const）</p><p>需要记住<em><strong>const修饰对象将会导致一个不可更改的对象即可</strong></em>。对待这个东西我个人的处理看待方式就是，先搞清楚目标对象是什么样的const，然后再做处理，也许和指针引用搭配的时候是有点绕。在确定对象是在当前过程中readonly的，那么我们就应该对其const修饰，对于非内部数据的输入参数，应该将单纯的值类型<code>A a</code>更改为<code>const A&amp; a</code>，避免了拷贝，同时避免了对其修改，提高了效率</p><h5 id="this"><a class="header-anchor" href="#this"></a><code>this</code></h5><ul><li>概念</li></ul><p>在类的非静态成员函数中，<code>this</code>指针是隐式可用的，它指向调用成员函数的对象实例。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>在类<code>T</code>的成员函数内，<code>this</code>的类型是<code>T* const</code>。这意味着<code>this</code>是一个指向<code>T</code>类型的常量指针，你不能改变<code>this</code>指针的指向，即不能让<code>this</code>指向另一个对象，但可以修改这个对象的成员（除非成员是<code>const</code>）底层const。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>在 const 成员函数中，<code>this</code>指针的类型是<code>const T* const</code>，这意味着你既不能改变<code>this</code>指针的指向，也不能通过<code>this</code>指针修改对象的成员</p><ul><li>补充</li></ul><p>1.可否delete this?</p><p><code>delete this</code> 是合法的，但是要非常小心使用。<code>delete this</code> 语句用于在对象的成员函数中释放该对象的内存，但这种操作需要确保在调用该语句之后，不再访问已释放的内存，否则会导致未定义的行为或程序崩溃</p><p>2.类的析构函数中<code>delete this</code>？</p><p>无限递归导致 stack overflow</p><p>3.<code>this</code>赋值<code>nullptr</code>后调用成员函数？</p><p>访问成员函数将导致未定义行为，唯一的例外是静态成员函数。静态成员函数不依赖于任何对象，因此不需要 <code>this</code> 指针。可以使用 <code>nullptr</code> 调用静态成员函数，因为静态成员函数不涉及对象的成员访问</p><h5 id="inline"><a class="header-anchor" href="#inline"></a><code>inline</code></h5><ul><li><strong>概念</strong></li></ul><p>内联函数是C++中的一种函数声明方式，它告诉（<strong>建议</strong>）编译器在调用函数时将函数的代码插入到调用处，而不是像普通函数那样通过跳转执行。这样做可以减少函数调用的开销，提高程序的执行效率。编译器不一定会遵循<code>inline</code>关键字，它可能会根据具体情况决定是否将函数内联。</p><p>优点：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而<strong>宏定义则不会</strong>。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">^{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏<strong>定义则不能</strong>。</p><p>缺点：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>包括可能导致代码体积增加，因为函数的代码会被复制到每个调用处，以及可能增加编译时间</p><ul><li><strong>补充</strong></li></ul><h5 id="sizeof"><a class="header-anchor" href="#sizeof"></a><code>sizeof</code></h5><ul><li><strong>概念</strong></li></ul><p><code>sizeof(var)</code>返回变量所占大小、<code>sizeof(pointer)</code>返回4或者8，这个与编译对象目标平台有关，<code>sizeof(array)</code>返回 类型大小*数组长度</p><p><code>size_of</code>是在编译期在确定</p><p><code>sizeof(空结构体)</code> 在C中是0，在C++中是1。C++标准规定，不同的对象不能拥有相同的内存地址</p><p>对类进行<code>sizeof</code>，看类中函数是不是虚函数。如果不是虚函数，则结果是1,如果是虚函数，则大小是4或者8</p><h5 id="extern"><a class="header-anchor" href="#extern"></a><code>extern </code></h5><ul><li><strong>概念</strong></li></ul><p>被 extern 限定的函数或变量是 extern 类型的；被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</p><h5 id="explict"><a class="header-anchor" href="#explict"></a><code>explict</code></h5><ul><li><strong>概念</strong></li></ul><p><code>explicit </code>修饰构造函数时，可以防止<strong>隐式转换和复制初始化</strong>；<code>explicit </code>修饰转换函数时，可以防止隐式转换</p><h5 id="cast"><a class="header-anchor" href="#cast"></a><code>?_cast</code></h5><ul><li><strong>概念</strong></li></ul><p>引入 <code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code> 等类型转换关键字，主要是为了<strong>提供类型转换的安全性和可控性</strong>。与C语言中的传统类型转换（使用强制类型转换操作符 <code>(type)</code>）相比，这些关键字更加清晰、可读，并且在编译时提供更多的类型检查。</p><p>引入原因</p><p><strong>安全性</strong>:提供更严格的类型检查，避免类型转换中的潜在错误。在编译时检测类型转换的合法性，减少运行时错误。</p><p><strong>可读性</strong>:通过不同的关键字表示不同类型的转换，代码意图更明确。提高代码的可维护性，程序员可以更清晰地理解转换的目的和风险。</p><p><strong>控制性</strong>:允许程序员在不同的上下文中选择合适的转换类型。提供对类型转换过程的精细控制，避免滥用强制类型转换。</p><p><strong>兼容性</strong>:保持与旧代码和C语言代码的兼容性，同时引入更现代化的类型转换机制。</p><p>类型</p><ol><li><p><code>static_cast</code></p><p><code>static_cast</code>是最常用的类型转换形式，用于<strong>基本数据类型之间的转换</strong>，如整型和浮点型、指针类型之间的转换（只要它们是相关的类型），以及类层次结构中<strong>向上</strong>（子类指针或引用转换为基类指针或引用）的转换。</p></li><li><p><code>dynamic_cast</code></p><p><code>dynamic_cast</code>专门用于处理类的层次结构中的<strong>向下</strong>转换（基类指针或引用转换为派生类指针或引用），并在运行时检查类型的安全性。它要求至少有一个基类声明为虚拟的（即至少有一个虚函数）。</p></li><li><p><code>const_cast</code></p><p><code>const_cast</code>用于修改类型的<code>const</code>或<code>volatile</code>属性，比如将一个<code>const</code>指针转换为非<code>const</code>指针，允许修改所指向的数据。它不能改变非<code>const</code>对象的<code>const</code>性质，也不能改变对象的类型。</p></li><li><p><code>reinterpret_cast</code></p><p>用于进行任意类型的指针转换。通常用于底层、硬件相关或系统编程中，进行较低级别的类型转换。</p></li></ol><h5 id="struct-union-class"><a class="header-anchor" href="#struct-union-class"></a><code>struct</code> <code>union</code> <code>class</code></h5><ol><li>C++区别</li></ol><table><thead><tr><th>union</th><th>struct</th><th>class</th></tr></thead><tbody><tr><td>定义多个成员，使用一个</td><td>定义多个成员，使用多个</td><td>定义多个成员，使用多个</td></tr><tr><td>默认public</td><td>默认public</td><td>默认private</td></tr><tr><td>不可以定义模板参数</td><td>不可以定义模板参数</td><td>可以定义模板参数</td></tr></tbody></table><ol start="2"><li><p>C\C++\C#之间的<code>struct</code> 和 <code>class</code> 区别</p><p>C:<code>struct</code> 只能定义数据成员，不能包含成员函数\没有访问控制</p><p>C++:参见1.</p><p>C#:<code>struct</code> 是一种值类型，而 <code>class</code> 是一种引用类型，分配内存位置不同，前者不可继承</p></li><li><p><code>struct</code>字节对齐</p><p>为什么：许多硬件平台对特定类型的数据访问有最优的内存对齐要求。正确对齐的数据可以直接从内存读取，而<strong>未对齐的数据可能需要多次访问才能完成读取</strong>，这样会降低性能。</p><p>数据对齐：起始位置的偏移量必须是该变量类型大小的整数倍</p><ol><li>结构体变量的首地址是其最宽基本成员类型大小的整数倍。</li><li>结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍。</li><li>结构体的总大小为结构体最宽基本成员类型大小的整数倍。</li></ol></li></ol><h5 id="new-delete-malloc-free"><a class="header-anchor" href="#new-delete-malloc-free"></a><code>new</code> <code>delete</code> <code>malloc</code> <code>free</code></h5><table><thead><tr><th>特性</th><th><code>new</code> / <code>delete</code></th><th><code>malloc</code> / <code>free</code></th></tr></thead><tbody><tr><td>语言支持</td><td>C++ 运算符</td><td>C 标准库函数，也可在 C++ 中使用</td></tr><tr><td>类型安全</td><td>类型安全，编译时进行类型检查</td><td>类型不安全，需要显式类型转换</td></tr><tr><td>构造函数调用</td><td><code>new</code> 分配内存并调用构造函数</td><td><code>malloc</code> 只分配内存，不调用构造函数</td></tr><tr><td>析构函数调用</td><td><code>delete</code> 调用析构函数并释放内存</td><td><code>free</code> 只释放内存，不调用析构函数</td></tr><tr><td>申请内存</td><td>无须指定内存块的大小，编译器会根据类型信息自行计算</td><td>显式地指出所需内存的大小</td></tr><tr><td>内存分配失败处理</td><td>抛出 <code>std::bad_alloc</code> 异常</td><td>返回 <code>nullptr</code></td></tr><tr><td>数组支持</td><td><code>new[]</code> 和 <code>delete[]</code> 提供数组分配和释放支持</td><td>需要手动计算大小和类型转换</td></tr><tr><td>使用语法</td><td>简洁，适用于对象和数组的分配</td><td>复杂，需要显式类型转换</td></tr><tr><td>内存对齐</td><td>自动处理内存对齐</td><td>取决于具体的实现，可能需要手动处理</td></tr><tr><td>性能和优化</td><td>通常更优化，特别是在处理复杂对象时</td><td>性能依赖于具体的标准库实现</td></tr><tr><td>运算符重载</td><td>支持运算符重载，自定义内存分配策略</td><td>不支持运算符重载</td></tr><tr><td>异常处理</td><td>提供异常处理机制</td><td>需要手动检查返回值并处理错误</td></tr><tr><td>代码示例</td><td><code>MyClass* obj = new MyClass(); delete obj; </code></td><td><code>MyClass* obj = (MyClass*)malloc(sizeof(MyClass)); free(obj); </code></td></tr><tr><td>返回类型</td><td><code>new</code>返回目标对象类型的指针</td><td><code>malloc</code>返回<code>void</code>的指针</td></tr></tbody></table><h5 id="NULL-nullptr"><a class="header-anchor" href="#NULL-nullptr"></a><code>NULL</code> <code>nullptr</code></h5><ul><li><strong>概念</strong></li></ul><p><strong><code>NULL</code></strong>：<code>NULL</code>通常被定义为整数<code>0</code>，或者是一个宏定义，如<code>#define NULL 0</code>或<code>#define NULL ((void*)0)</code>。它的实际类型可能因编译器而异。</p><p><strong><code>nullptr</code></strong>：<code>nullptr</code>是C++11引入的一个新的关键字，它表示一个指向任何类型的空指针。<code>nullptr</code>的类型是<code>std::nullptr_t</code>，可以隐式转换为任何指针类型。</p><h5 id="auto-decltype"><a class="header-anchor" href="#auto-decltype"></a><code>auto</code> <code>decltype</code></h5><ul><li><strong>概念</strong></li></ul><p>auto 和 decltype都是类型推断关键字；</p><p><code>auto</code> 关键字用于在变量声明时根据初始化表达式自动推导变量的类型。</p><p><code>decltype</code> 关键字用于从表达式中推导出类型，它不会对表达式求值，只是获取其类型</p><p><code>auto</code> 会去掉引用和顶层 <code>const</code>，<code>auto</code> 必须有一个初始化表达式。</p><p><code>decltype</code> 会保留表达式的引用和 <code>const</code> 属性，<code>decltype</code> 可以用于没有初始化表达式的场合。</p><h5 id="macro"><a class="header-anchor" href="#macro"></a>macro</h5><table><thead><tr><th></th><th>宏</th><th>const</th><th>inline</th><th>typedef</th></tr></thead><tbody><tr><td>定义</td><td>字符替换</td><td>常量声明</td><td>函数声明</td><td>定义新别名</td></tr><tr><td>内存</td><td>不分配内存</td><td>分配</td><td>\</td><td>\</td></tr><tr><td>处理</td><td>预处理器</td><td>编译器</td><td>编译器</td><td>编译器</td></tr><tr><td>安全检查</td><td>无</td><td>有</td><td>有</td><td>有</td></tr><tr><td>存储</td><td>代码段</td><td>数据段</td><td>\</td><td>\</td></tr><tr><td>阶段</td><td>预编译执行</td><td>编译阶段</td><td>编译阶段</td><td>编译阶段</td></tr></tbody></table><hr><h4 id="STL-📦"><a class="header-anchor" href="#STL-📦"></a>STL 📦</h4><h5 id="引入"><a class="header-anchor" href="#引入"></a>引入</h5><ul><li><h5 id="概念"><a class="header-anchor" href="#概念"></a>概念</h5></li></ul><p><strong>容器</strong>：数据结构，容器通过迭代器暴露其元素，使得算法可以操作这些元素</p><p><strong>迭代器</strong>：访问容器的泛型指针，让用户通过特定的接口访问容器的数据，不需要了解容器内部的底层数据结构</p><p><strong>算法</strong>：数据操作方式</p><p><strong>函数对象（仿函数）</strong>：函数对象是重载了函数调用操作符（<code>()</code>）的类实例。STL中的函数对象可以用作算法的某些操作，如定义比较行为（<code>less</code>，<code>greater</code>等），定义算法作用与容器的行为。</p><p><code>sort(a.begin(), a.end(),less&lt;int&gt;());</code></p><p><strong>适配器</strong>：可以修改或扩展迭代器、容器和仿函数的行为，使其能够以新的方式被算法使用或操作。(stack\queue)</p><p><strong>空间配置器</strong>：在更底层被容器使用来管理内存分配的，但它通常对于 STL 的使用者是透明的，除非需要自定义内存管理行为。<strong>【可以作为说是STL优化策略】</strong>【堆中申请内存】</p><p>容器以 class template 完成;<br>算法以 function templates 完成;<br>仿函数是一种将 operator() 重载的 class template;<br>迭代器是一种将 operator++ 和 operator* 等指针习惯常行为重载的 class template;<br>配接器中的 container adapter 和 iterator adapter 都是一种 class template, 而 function adapter.</p><h5 id="容器分类"><a class="header-anchor" href="#容器分类"></a>容器分类</h5><p><strong>概念</strong></p><p>1总览</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">STL:</span><br><span class="line"><span class="comment">//序列式容器: string,vector,array,deque,list,forward_list</span></span><br><span class="line"><span class="comment">//容器适配器: stack,queue,priority_queue</span></span><br><span class="line"><span class="comment">//关联式容器: </span></span><br><span class="line"><span class="comment">//红黑树结构：map,set,multimap,multiset</span></span><br><span class="line"><span class="comment">//哈希结构：unordered_map,unordered_set,unordered_multimap,unordered_multiset</span></span><br><span class="line"></span><br><span class="line">vector:可变大小数组</span><br><span class="line">deque:双端队列</span><br><span class="line">list:双向链表</span><br><span class="line">array:固定大小数组</span><br><span class="line">string:类似于vector但是专门保存字符</span><br><span class="line">forward_list:前向链表</span><br><span class="line"></span><br><span class="line">map:关联数组：key-value pair 有序</span><br><span class="line">set：只保存关键字的容器：key is value 有序</span><br><span class="line">mutilmap：关键字可重复出现</span><br><span class="line">mutilset：关键字可重复出现</span><br><span class="line"></span><br><span class="line">unordered_map:hash函数组织map 无序</span><br><span class="line">unordered_set:hash函数组织set 无序</span><br><span class="line">unordered_mutilmap:hash函数组织map 无序 关键字可重复出现</span><br><span class="line">unordered_mutilset:hash函数组织set 无序 关键字可重复出现</span><br></pre></td></tr></table></figure><p>2表格</p><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#array">array</a></td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#vector">vector</a></td><td>数组</td><td>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#deque">deque</a></td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#forward_list">forward_list</a></td><td>单向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#list">list</a></td><td>双向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#stack">stack</a></td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，<strong>扩容耗时</strong></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#queue">queue</a></td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，<strong>扩容耗时</strong></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue</a></td><td>vector + max-heap</td><td>插入、删除 O(log2n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#set">set</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multiset">multiset</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#map">map</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multimap">multimap</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set">unordered_set</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset">unordered_multiset</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map">unordered_map</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap">unordered_multimap</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table><table><thead><tr><th>算法</th><th>底层算法</th><th>时间复杂度</th><th>可不可重复</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/algorithm/find/">find</a></td><td>顺序查找</td><td>O(n)</td><td>可重复</td></tr><tr><td><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdC++-v3/include/bits/stl_algo.h#L4808">sort</a></td><td><a href="https://en.wikipedia.org/wiki/Introsort">内省排序</a></td><td>O(n*log2n)</td><td>可重复</td></tr></tbody></table><ul><li><strong>补充</strong></li></ul><ol><li>为什么空间配置其使用<strong>内存池</strong>机制实现</li></ol><p>内存池实现机制采用allocate 包装 malloc，deallocate包装free，如果将内存申请交给每个STL容器自己去申请管理，一是不安全容易内存泄漏二是频繁申请小块内存导致内存碎片，影响程序运行效率。</p><ol start="2"><li>为什么空间配置器是一级和二级的，为什么要二级空间配置器(1大1小)</li></ol><p>一级空间配置器对于大块内存非常有效，直接与内存管理机制交互减少额外开销，但是频繁分配和释放小块内存的场景，将会导致性能下降和内存碎片,所以引入二级空间配置器，底层原理是链表构成的内存</p><ol start="3"><li>STL内存管理</li></ol><p>STL内存管理使用二级内存配置器来优化内存分配和回收。这种机制通过减少系统调用（例如 <code>malloc</code> 和 <code>free</code>）的次数来提高性能，特别是在频繁进行小块内存操作的场景下，</p><p><strong>一级内存配置器（first level allocator）</strong>：直接使用标准的内存分配和回收方法，如 <code>malloc</code> 和 <code>free</code>。当申请的内存大小超过128字节时，默认使用一级内存配置器</p><p><strong>二级内存配置器（second level allocator）</strong>：主要用于处理小块内存请求，尤其是小于128字节的请求。二级内存配置器的设计目的是减少内存碎片和提高内存分配效率。减少了对系统级内存管理函数调用，对于小块内存的请求能快速响应，提高了内存分配的速度，通过固定大小的内存块管理，可以有效减少内存碎片。</p><h6 id="vector"><a class="header-anchor" href="#vector"></a>vector</h6><ul><li>概念</li></ul><p>动态增长数组，底层是类似于一个array，但是比array灵活，内部数据连续存储，是一种可以动态增长的序列容器，元素在内存连续存放，随机存取时间复杂度O(1)，尾端操作最佳性能，头部操作O(n)。</p><p>增加元素时若超过自身最大容量，则扩充自身容量2倍（不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍）扩充空间需要经过的步骤：重新配置空间，元素移动，释放旧的内存空间。一旦vector空间重新配置，则指向原来vector的所有迭代器都失效了，因为vector的地址改变了</p><ul><li>补充</li></ul><ol><li><p>为什么加倍扩充，而申请固定容量？扩容为啥1.5倍或2倍？</p><p>加倍扩容将会有更多的空余空间，不然假设我们一边扩一个一边加一个将导致不停的内存拷贝复制，时间复杂度本来是O(1)将会增长为O(n)</p><p>使用k=2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好，最好把增长因子设为(1, 2)，也就是1-2之间的某个数值。1.5倍扩容能更好的利用之前的内存块，降低碎片问题。</p></li><li><p><code>push_back</code>和<code>emplace_back</code>区别</p><p>emplace_back() 和 push_back() 的主要区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程</p></li><li><p>迭代器失效</p><p>resize、reserve、insert、assign、push_back等会引起其底层空间改变的操作，都有可能使迭代器失效，实际就是迭代器底层对应指针所指向的 空间被销毁了</p></li><li><p>使用vector交换技巧释放空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vec).<span class="built_in">swap</span>(vec); <span class="comment">// shrink</span></span><br><span class="line">std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(vec); <span class="comment">// 清空内容，且释放内存</span></span><br></pre></td></tr></table></figure></li><li><p>元素类型可以是引用吗</p><p>vector的底层实现要求连续的对象排列，<strong>引用并非对象，没有实际地址，因此vector的元素类型不能是引用</strong></p><ol><li><strong>引用的不可重新绑定性</strong>：引用一旦被绑定到某个对象，就不能被重新绑定。容器在内部需要能够移动和复制元素，这对于引用类型来说是不可能的，因为引用类型一旦创建就绑定到某个对象，无法重新指向其他对象。</li><li><strong>引用类型的内存管理</strong>：容器在内部可能会重新分配内存并移动元素位置，这对于引用类型是不适用的。因为引用本质上是某个对象的别名，而不是独立存在的对象，因此无法被复制或移动</li></ol></li></ol><h6 id="list"><a class="header-anchor" href="#list"></a>list</h6><ul><li><p>概念</p></li><li><p>补充</p></li></ul><h6 id="deque"><a class="header-anchor" href="#deque"></a>deque</h6><ul><li>概念</li></ul><p><strong>双端队列</strong>， 用空间换了时间，支持首尾（中间不能）快速增删（与vector最大差异），<strong>支持随机访问</strong>。<code>deque</code> 的内部实现通常不是一个连续的内存区域，而是由一系列固定大小的数组（称为块或段）构成，这些数组通过一些额外的中央控制结构（如索引数组）连接</p><p><strong>优点：</strong></p><ol><li><strong>两端插入/删除操作高效</strong>：<code>std::deque</code> 允许在容器的前端和后端进行快速插入和删除操作，时间复杂度大约是 O(1)，这比 <code>std::vector</code> 的前端插入和删除效率要高得多。【这也是vector最大差异】</li><li><strong>随机访问</strong>：与 <code>std::vector</code> 类似，<code>std::deque</code> 也支持通过索引进行快速随机访问，访问时间复杂度为 O(1)</li></ol><p><strong>缺点：</strong></p><ol><li><strong>内存使用可能更高</strong>：由于 <code>std::deque</code> 的实现通常需要额外的中央控制结构来管理各个块，以及块内的间接寻址，这可能导致其比 <code>std::vector</code> 使用更多的内存。</li><li><strong>缓存利用率可能较低</strong>：虽然 <code>std::deque</code> 支持随机访问，但其元素可能分布在不连续的内存块中，这可能导致在遍历时缓存命中率低于 <code>std::vector</code>。</li><li><strong>某些操作可能较慢</strong>：虽然在两端的操作很快，但在 <code>std::deque</code> 的中间插入或删除元素仍然需要移动一部分元素，这可能比在 <code>std::vector</code> 中慢，尤其是当元素分布在多个内存块中时</li></ol><ul><li>补充</li></ul><ol><li><code>deque</code>的中控器</li></ol><p><code>deque</code> 的中控器是一个指针数组，每个指针指向一个固定大小的内存块（称为缓冲区），这些缓冲区存储实际的数据元素。中控器本身通常是动态分配的，可以根据需要扩展或缩小，以容纳更多的缓冲区。这种结构允许 <code>deque</code> 在两端动态增长而无需重新分配整个容器的内存，这是 <code>vector</code> 扩展时通常需要做的事情。</p><h6 id="map"><a class="header-anchor" href="#map"></a>map</h6><ul><li>概念</li></ul><p>底层实现为一个<strong>自平衡的二叉搜索树</strong>（红黑树，红黑树的旋转操作比AVL树少，红黑树的这种宽松平衡使其在<strong>插入和删除操作中相对更高效</strong>，因为它不需要像AVL树那样频繁地进行平衡调整，但是这也意味着在最坏情况下，红黑树的查找操作可能会稍慢于AVL树，因为其<strong>树高可能稍高</strong>），意味着在对数时间复杂度内完成插入、查找和删除的操作，内部元素排列是有序的。</p><ul><li>补充</li></ul><p>红黑树？</p><blockquote><p>中所有节点非红即黑。</p><p>根节点必为黑节点。</p><p>红节点的子节点必为黑（黑节点子节点可为黑）</p><p><strong>从根到叶子的任何路径上黑结点数相同</strong></p><p>O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>) 查询</p></blockquote><h6 id="set"><a class="header-anchor" href="#set"></a>set</h6><ul><li>概念</li></ul><p>底层是一个基于红黑树实现，存储唯一的元素（不重复），按照特定的顺序进行排序的，关联容器。并且set仅存储单个值而非键值对，他的值就是键。</p><ul><li>补充</li></ul><ol><li>为什么map和set和插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效</li></ol><p>**关于效率：**set和map是一种关联式容器，底层实现是红黑树实现的，他们的插入和删除效率高于其他容器是因为插入删除操作均是在节点进行操作，对红黑树节点的操作也只是指针操作，节点的存储内存不变。所以效率高，而vector往中间插入会涉及到对后序的内存中的元素复制再拷贝。</p><p><strong>关于迭代器失效：</strong> 在 <code>std::map</code> 和 <code>std::set</code> 中，插入和删除操作不会使指向其他元素的迭代器失效。这是因为这些操作只影响到特定的节点，并且由于红黑树的性质，树的其他部分保持有效</p><ol start="2"><li>map和set不能像vector一样有个reserve函数来预分配数据</li></ol><p>vector是一种序列式容器，底层实现是一个连续的内存空间，可以动态添加删除数据。而map&amp;set基于红黑树结构他们并不支持连续的内存布局，<strong>他们的底层设计和数据结构</strong>决定了它们不支持 <code>reserve</code> 功能，</p><h6 id="priority-queue"><a class="header-anchor" href="#priority-queue"></a>priority_queue</h6><ul><li>概念</li></ul><p><code>std::priority_queue</code> 默认使用 <code>std::vector</code> 作为其底层容器，并使用 <code>std::less</code> 作为比较函数，这意味着最大的元素总是位于队列的前端。它<strong>不提供遍历其元素的能力</strong>，因为 <code>std::priority_queue</code> 只允许访问最顶端的元素。插入和删除操作（添加和移除队列中的元素）的时间复杂度大约是 O(log n)</p><h5 id="容器其它补充"><a class="header-anchor" href="#容器其它补充"></a>容器其它补充</h5><p>迭代器 ++it 与 it++</p><ul><li>概念</li></ul><p><code>++it</code>（前缀递增）</p><p><strong>行为</strong>：首先增加迭代器的值（即让迭代器指向下一个元素），然后返回增加后的迭代器的引用。普通<code>++i</code>就是这样，<code>++i</code> 首先将 <code>i</code> 的值增加+1再返回</p><p><strong>性能</strong>：通常推荐使用前缀递增，因为它不需要创建迭代器的临时副本。在迭代器或者对象本身较大时，使用前缀递增可以避免不必要的复制，从而提高效率</p><p><code>it++</code>（后缀递增）</p><p><strong>行为</strong>：首先创建当前迭代器的一个副本，然后增加原迭代器的值（让原迭代器指向下一个元素），最后返回副本。这意味着返回的是增加之前的迭代器的值。普通<code>i++</code>就是这样，<code>i++</code> 首先返回 <code>i</code> 当前的值（增加前的值），然后再+1</p><p><strong>性能</strong>：后缀递增需要创建迭代器的一个临时副本，这可能导致额外的性能开销，尤其是对于那些复制成本较高的迭代器（如某些容器的迭代器）</p><p>STL线程安全性</p><ul><li>概念</li></ul><p><strong>单线程访问</strong>：所有 STL 容器都是线程安全的。</p><p><strong>多线程只读访问</strong>：多个线程可以安全地同时读取同一个容器。</p><p><strong>多线程读写访问</strong>：需要使用同步机制（如互斥锁）来保护对容器的访问，以防止数据竞争。</p><p>容器动态链接可能产生的问题</p><ul><li>概念</li></ul><p>一般程序中，局部容器、参数传递容器、参数传递容器的引用以及参数传递容器的指针通常可以正常运行。然而，当涉及到动态链接库（DLL）时，给动态库函数传递容器对象本身可能会导致内存堆栈破坏的问题。</p><p>标准库实现差异；编译器和ABI兼容性；内存分配器不一致</p><hr><h4 id="析构与构造-📚"><a class="header-anchor" href="#析构与构造-📚"></a>析构与构造 📚</h4><ul><li>概念</li></ul><table><thead><tr><th></th><th>解释</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td>普通构造函数</td><td>完成对象的初始化工作</td><td style="text-align:left">含参数</td></tr><tr><td>默认构造函数</td><td>完成对象的初始化工作</td><td style="text-align:left">无参数</td></tr><tr><td>拷贝构造函数</td><td>复制构造函数用于复制本类的对象，拷贝构造函数在用一个对象初始化另一个新对象时被调用</td><td style="text-align:left">默认实现是浅拷贝而非深拷贝</td></tr><tr><td>转换构造函数</td><td>转换构造函数用于将其他类型的变量，隐式转换为本类对象</td><td style="text-align:left"></td></tr><tr><td>移动构造函数</td><td>特殊的构造函数，用于在对象之间转移资源的所有权，而不是复制资源</td><td style="text-align:left">接受一个右值引用作为参数；noexcept不抛出异常</td></tr><tr><td>委托构造函数</td><td>构造函数可以委托同类型的另一个构造函数对对象进行初始化</td><td style="text-align:left"></td></tr></tbody></table><p>构造过程：</p><ol><li><p><strong>内存分配</strong>：首先为对象分配内存，包括其所有成员变量。</p></li><li><p>成员初始化</p><ul><li><p><strong>使用初始化列表</strong>：如果提供了初始化列表，则成员变量将通过在列表中指定的构造函数直接初始化。这意味着对于类类型成员，将直接调用相应的构造函数（可能是参数化构造函数或复制构造函数），而对于内置类型成员，则直接进行赋值。</p><p>初始化列表只做一次赋值操作，相比构造函数体内进行赋值的话，构造函数体内进行赋值会等于是一次默认构造加一次赋值。</p></li><li><p><strong>未使用初始化列表</strong>：如果没有为类类型的成员变量提供初始化列表，则这些成员变量首先通过默认构造函数进行初始化。之后，如果在构造函数体内有赋值操作，这些成员变量将经历一次赋值操作。</p></li></ul></li><li><p><strong>执行构造函数体</strong>：完成成员的初始化后，执行构造函数体中的代码</p></li></ol><p>对于类类型的成员变量，如果在构造函数体内对它们进行赋值，而不是在初始化列表中直接初始化，会发生以下情况：</p><ul><li><strong>默认构造阶段</strong>：在进入构造函数体之前，类类型的成员需要被初始化。如果没有在初始化列表中明确指定如何初始化，那么这些成员将通过默认构造函数进行初始化。这是成员对象的生命周期的开始。</li><li><strong>赋值操作</strong>：在构造函数体内，对这些已经默认构造的成员进行赋值，实际上是调用赋值操作符。这不是成员对象的初始化，而是在一个已经构造的对象上进行的赋值。</li></ul><p>浅拷贝(Shallow Copy) 深拷贝(Deep Copy) 零拷贝</p><p>构造\析构执行顺序</p><p>构造：<strong>基类构造函数-&gt;成员对象的构造函数-&gt;派生类构造函数</strong></p><p>有多个成员类对象则构造函数的调用顺序是对象在类中<strong>被声明的顺序</strong>，而不是它们出现在成员初始化表中的顺序</p><blockquote><p>构造子类构造函数的参数</p><p>子类调用基类构造函数</p><p>基类设置vptr</p><p>基类初始化列表内容进行构造</p><p>基类函数体调用</p><p>子类设置vptr</p><p>子类初始化列表内容进行构造</p><p>子类构造函数体调用</p></blockquote><ul><li>补充</li></ul><ol><li><p>构造函数与析构函数进行内联</p><p>将构造函数和析构函数声明为inline是没有什么意义即编译器并不真正对声明为 <code>inline </code>的构造和析构函数进行内联操作</p><p>原因：因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。即实际上这两个函数很复杂，编译器不会对其<code>inline</code></p></li><li><p>虚函数内联</p><p>当是指向派生类的指针（多态性）调用 <code>inline </code>的虚函数时，不会内联展开；当是对象本身调用 inline 的虚函数时，会内联展开。</p><p>虚函数是为了实现运行时多态性而设计的，它允许在派生类中重写基类中的同名函数，而在运行时动态地确定应该调用哪个版本的函数，内联函数允许在调用处直接展开函数的代码，以减少函数调用的开销。但是，对于虚函数来说，编译器需要在运行时确定实际调用的函数版本，这与内联函数的特性相矛盾。因此，虚函数通常不会被声明为内联函数。虚函数的实现通常涉及虚函数表（vtable）和虚函数指针（vptr），而内联函数的展开是在编译期间完成的，这两者的机制不兼容</p><table><thead><tr><th>内联问题</th></tr></thead><tbody><tr><td>虚函数内联（类中本身调用才展开，指针调用情况下不会）</td></tr><tr><td>构造函数内联（没意义）</td></tr><tr><td>析构函数内联（没意义）</td></tr></tbody></table></li><li><p>什么时候合成构造函数</p><p>没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数</p><p>没有任何构造函数的类派生自一个带有默认构造函数的基类</p><p>带有虚函数的类</p><p>含有虚基类</p></li><li><p>什么时候合成拷贝构造函数</p><p>被当做参数交给某个函数</p><p>如果返回的对象是一个函数参数或类的成员变量，而不是局部对象，则会调用拷贝构造函数</p><p>没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数</p><p>没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类</p><p>带有虚函数的类</p><p>含有虚基类</p></li><li><p>返回一个局部对象，返回值的创建</p><p>返回一个局部对象，编译器会优先调用移动构造函数来创建返回值，而不是拷贝构造函数</p></li></ol><hr><h4 id="多态与虚函数-🧊"><a class="header-anchor" href="#多态与虚函数-🧊"></a>多态与虚函数 🧊</h4><p>多态</p><ul><li>概念</li></ul><ol><li><strong>编译时多态</strong>：也称为<strong>静态多态</strong>，主要通过方法重载和运算符重载实现。在编译时，编译器就决定了应该使用哪个函数，基于函数签名（如参数类型和数量）来进行区分。</li><li><strong>运行时多态</strong>：也称为<strong>动态多态</strong>，主要依赖于继承和接口实现。在运行时，系统根据对象的实际类型来决定调用哪个实现，这种决定通常依赖于虚函数。</li></ol><ul><li>补充</li></ul><ol><li>引用和指针才能展现多态，非引用或者指针呢？</li></ol><p>非指针和非引用将导致<strong>切割问题</strong>：指针类型的时候按照多态的行为去解释（即去查虚函数表，然后实现运行时多态），而非指针类型，直接使用基类类型不会按照多态行为解释（虚函数表指针丢失）</p><p>虚xxx</p><ul><li>概念</li></ul><ol><li>普通虚函数（Virtual Functions）</li></ol><p><strong>定义与目的</strong>：通过在函数声明前添加<code>virtual</code>关键字来定义虚函数。虚函数允许派生类重写（override）基类中的成员函数，<strong>实现运行时多态</strong></p><p><strong>运行时多态</strong>：虚函数的调用是在运行时决定的，而非编译时。这意味着当通过基类指针或引用调用一个虚函数时，将执行对象实际类型的函数版本</p><p><strong>编译时多态</strong>：函数重载或者模板【问模板的原理？】</p><ol start="2"><li>纯虚函数（Pure Virtual Functions）</li></ol><p><strong>定义</strong>：纯虚函数是一种没有实现的虚函数，通过在函数声明的结尾处添加<code>= 0</code>来指定</p><p><strong>抽象基类</strong>：包含至少一个纯虚函数的类称为抽象基类。抽象基类不能实例化对象</p><ol start="3"><li>虚析构函数（Virtual Destructors）</li></ol><p><strong>目的</strong>：确保通过基类指针删除派生类对象时能够调用正确的析构函数，从而避免资源泄漏</p><p><strong>实现</strong>：将基类的析构函数声明为虚函数</p><ol start="3"><li>虚继承</li></ol><p><strong>解决问题</strong>：用于解决多重继承中的菱形继承问题（钻石问题），避免基类被多次继承导致的成员重复</p><p>实现：编译器会为使用虚继承的类构建一个虚基类表。这个表用于存储虚基类相对于派生类对象的偏移量</p><ul><li>补充</li></ul><table><thead><tr><th>不可以为虚函数的函数</th><th>备注</th></tr></thead><tbody><tr><td>构造函数 （不可以）</td><td>虚指针未初始化，矛盾</td></tr><tr><td>内联函数 （不推荐）</td><td>派生类指针调用不会内联展开；对象本身调用内联展开</td></tr><tr><td>静态函数 （不可以）</td><td>因为不属于对象属于类，静态成员函数没有this指针</td></tr><tr><td>友元函数 （不可以）</td><td>因为友元函数不属于类的成员函数，不能被继承，不会进入虚表</td></tr></tbody></table><ol><li><p>静态函数可以声明为虚函数吗</p><p>不可以，静态函数不是对象的实际成员，无法和实例进行绑定</p></li><li><p>构造函数可以为虚函数吗</p><p><strong>不可以，虚函数表和虚指针是在对象被创建完成后才进行初始化</strong>的。在对象的构造函数执行之前，对象的内存空间已经分配，但<strong>虚指针尚未初始化</strong>。因此，在构造函数中无法使用虚函数表和虚指针来实现动态绑定</p><blockquote><p>当一个虚函数被调用时,它通过虚表(vtable)来解析，而虚函数的调用需要我们通过虚指针去查询虚表进行访问，但此时我们的虚指针的构造是跟随着对象构造函数一起走的，既然我们的虚指针还未初始化那我们访问虚表的行为可能就是未知的，得不到相应调用。此时就会导致一个悖论:</p><p><strong>解释1：虚指针还未还没有初始化,对象未完成构造,编译器就需要使用它来调用构造函数</strong>;</p><p><strong>解释2：虚函数是在运行时动态确定其类型的。在构造一个对象时对象还未创建成功，编译器无法知道对象的实际类型，无法进行调用</strong></p><p><em>'鸡和蛋相互依赖:鸡来自蛋,而蛋又是由鸡生的。这导致了一个看似无法解决的循环因果关系,同样,在构造函数和虚函数的情况下,也存在一种循环依赖:</em></p><ol><li><em>为了调用虚函数,对象需要通过vptr访问其虚表。</em></li><li><em>但是,访问虚表我们需要一个已经初始化好了的vptr才行，而虚指针是在构造函数执行期间初始化的,对象完成构造后才能得到虚指针</em></li><li><em>如果构造函数本身是一个虚函数,那么在调用构造函数之前,就需要访问尚未初始化的虚指针进而访问虚表，很明显这有问题。</em></li></ol><p><em>这就产生了一个类似于&quot;先有鸡还是先有蛋&quot;的悖论:为了调用构造函数(虚函数),需要虚指针访问虚表;但为了初始化虚指针,需要先调用构造函数’</em></p></blockquote><p>对象的虚指针（指向虚表的指针）设置通常是在<strong>构造函数开始执行的早期阶段进行</strong>的，这是为了确保即使在<strong>构造过程中，对象的虚函数也能正确解析到当前构造阶段对应类的实现</strong>。这意味着，虚指针和虚表的设置发生在对象的构造过程中，而不是在构造函数完成后【是逐步逐步完成的】。</p><blockquote><p>假设有三个类，<code>Base</code>，<code>Derived1</code>继承自<code>Base</code>，以及<code>Derived2</code>继承自<code>Derived1</code>。每个类都有其虚函数和相应的虚表。</p><p>构造<code>Derived2</code>对象时的过程：</p><ul><li>当<code>Derived2</code>的构造函数被调用时，它首先会调用<code>Derived1</code>的构造函数。</li><li>在<code>Derived1</code>的构造函数执行之前，<code>Base</code>的构造函数会被自动调用。</li><li><strong>在<code>Base</code>构造函数执行的早期阶段</strong>，对象的虚指针被设置为指向<code>Base</code>的虚表。这确保了即使在<code>Base</code>构造函数内部，任何虚函数调用都能正确地解析到<code>Base</code>类的实现。</li><li>然后，控制权回到<code>Derived1</code>的构造函数，在它开始执行的早期，对象的虚指针更新为指向<code>Derived1</code>的虚表。</li><li>同样地，当<code>Derived2</code>的构造函数开始执行时，对象的虚指针最终被更新为指向<code>Derived2</code>的虚表。</li><li>当<code>Derived2</code>的构造函数执行完毕，整个对象被完全构造完成，此时虚指针指向<code>Derived2</code>的虚表，确保任何对虚函数的调用都会解析到<code>Derived2</code>或它正确的基类实现。</li></ul><p>因此，虚指针的设置和更新发生在每个构造阶段的开始，确保了即使在构造过程中发生虚函数调用，也能够调用到正确版本的函数【但是一般不在构造函数中调用虚函数，不推荐】。这也意味着虚指针和虚表的“生成”（或更准确地说，虚指针的设置）是在构造对象的过程中逐步完成的，而不是在整个对象构造完成后</p></blockquote></li><li><p>析构函数可以为虚函数吗</p><p>有一个指向派生类对象的基类指针，并且通过这个基类指针删除对象时，如果基类的析构函数不是虚的，那么只有基类的析构函数会被调用，导致派生类部分可能不会被正确清理，从而造成资源泄漏或其他问题。这是因为在这种情况下，编译器无法确定要调用哪个析构函数，因为它只依据指针的静态类型来做决定。</p></li><li><p>构造函数和析构函数可以调用虚函数吗</p><p>对于构造函数：此时子类的对象还没有完全构造，编译器会去虚函数化，只会用当前类的函数， 如果是纯虚函数，就会调用到纯虚函数，会导致构造函数抛异常</p><p>对于析构函数： 同样，由于对象不完整，编译器会去虚函数化，函数调用本类的虚函数，如果本类虚函数是纯虚函数，就会到账析构函数抛出异常</p><p>语法上讲可以，但不推荐这种做法【effective C++: <strong>绝不在构造和析构过程中调用虚函数</strong>】</p><blockquote><p>《Effective C++》的解释是： 派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型</p><ul><li>在构造函数中调用虚函数,调用的是当前<strong>正在构造</strong>的类的版本,而不是最终的重写版本</li><li>在析构函数中调用虚函数,调用的是当前<strong>正在析构</strong>的类的版本,而不是原始的基类版本</li></ul></blockquote><p>父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编【<strong>构造函数和析构函数调用虚函数时都不使用动态联编</strong>】</p></li></ol><p>vptr 与 vtable</p><ul><li><p>概念</p><ul><li><p>虚指针 vptr</p><p><strong>定义</strong>：虚指针是一个指针，每个使用虚函数的对象都会持有一个指向相应虚表的虚指针。</p><p><strong>作用</strong>：虚指针使得对象能够在运行时通过虚表找到正确的虚函数实现。当对象的虚函数被调用时，编译器通过对象的虚指针访问虚表，从而找到对应的函数实现进行调用。<strong>在构造函数执行时会对虚表指针进行初始化</strong></p></li><li><p>虚表 vtable</p><p><strong>定义</strong>：虚表是一个包含指向类的虚函数地址的数组。<strong>每个</strong>有虚函数的类或包含虚函数的类的派生类都有一个为它生成的虚表，这个表是一个函数指针数组，每个元素指向一个虚函数的实现。如果类中有虚函数，每个对象实例会包含一个指向其类虚函数表的指针（通常在对象内存布局的开始位置）。</p><p><strong>作用</strong>：当调用对象的虚函数时，编译器会使用虚表来决定需要调用的实际函数。这允许在运行时进行函数的动态绑定，是实现多态的关键。</p></li><li><p>工作原理</p><p><strong>初始化</strong>：当一个对象被创建时，编译器会自动在对象的内存布局中添加一个虚指针（vptr），并将其初始化为指向该类的虚表</p><blockquote><p>在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</p><p>即导致一种情况：覆盖</p><p>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</p></blockquote><p><strong>继承与多态</strong>：如果一个类被继承，派生类会有它自己的虚表（如果它覆盖了基类的虚函数或添加了新的虚函数）。当通过基类指针或引用调用虚函数时，运行时会查找对象实际类型的虚表，从而调用正确的函数实现</p><p>继承中的虚函数表</p><ol><li><p><strong>无新虚函数，无覆盖</strong>：</p><p>如果派生类没有引入新的虚函数，也没有重写基类的任何虚函数，则派生类可以直接使用基类的虚函数表。</p></li><li><p><strong>覆盖基类虚函数</strong>：</p><p>如果派生类重写（覆盖）了基类的虚函数，派生类的虚函数表将包含指向新实现的指针，替换掉原有函数的位置。这保证了通过基类指针调用虚函数时，能够执行到派生类中的覆盖版本。</p></li><li><p><strong>引入新的虚函数</strong>：</p><p>如果派生类引入了新的虚函数，这些新函数会被添加到虚函数表的末尾。派生类的虚函数表首先包含指向从基类继承的所有虚函数（包括被覆盖的和未被覆盖的）的指针，随后是新增虚函数的指针。</p></li></ol></li></ul></li><li><p>补充</p><ol><li>vptr和vtable是什么时候创建</li></ol><p><strong>虚表是在编译阶段为每个含有虚函数的类生成的，而虚指针在类的对象实例化过程中，具体是在构造函数执行过程中初始化，并指向相应的虚表</strong></p><p>虚表和虚指针创建和初始化的过程，涉及到类的实例化：</p><p>**编译阶段：**编译器在编译阶段识别出哪些类含有虚函数，并为这些类生成虚表。虚表中存储了虚函数的地址。如果类有继承，并且子类覆盖了基类的虚函数，子类的虚表中会用子类函数的地址替换相应的基类函数地址。<br>**构造函数执行阶段：**当创建一个类的对象时，该对象的构造函数会被调用。在构造函数的执行过程中，对象的虚指针（vptr）被初始化，指向其对应类的虚表。如果有继承关系，每个构造函数（从基类到派生类）在其执行过程中都可能更新vptr以指向正确的虚表，以反映当前构造阶段对象的动态类型。<br>**构造函数完成后：**一旦对象的构造函数（包括所有基类和派生类的构造函数，如果有继承的话）执行完成，对象的vptr将最终指向最派生类的虚表。此时，对象已经完全构建好，可以正常使用虚函数了。</p><blockquote><p>虚指针 (vptr)</p><ul><li><strong>创建和初始化时机</strong>：每个含有虚函数的类的对象都会有一个虚指针。这个虚指针是在对象创建时自动被编译器添加到对象中的。对于类的每个实例，虚指针在对象的构造函数中被初始化。</li><li><strong>指向</strong>：虚指针指向相应的虚表。</li></ul><p>所以我们说只有在vptr完成初始化后才能访问到虚表</p><p>虚表 (vtable)</p><ul><li><strong>创建时机</strong>：虚表是在编译时期创建的。对于每一个含有虚函数的类，编译器会生成一个虚表。虚表是类的一个静态属性，因此对于该类的所有实例来说，<strong>虚表是共享的</strong>。</li><li><strong>初始化时机</strong>：虚表在编译期间就已经被初始化了。编译器会将类中所有的虚函数地址填入虚表中。这意味着，当程序编译完成后，每个含有虚函数的类对应的虚表中已经填充了所有虚函数的地址。</li><li><strong>填入虚函数地址</strong>：虚函数的地址是在编译器编译时期填入虚表的。<strong>这个过程发生在程序编译阶段，而不是运行时或者类的初始化时期</strong></li></ul></blockquote></li></ul><hr><h4 id="引用与指针-📎"><a class="header-anchor" href="#引用与指针-📎"></a>引用与指针 📎</h4><h5 id="区别"><a class="header-anchor" href="#区别"></a>区别</h5><p>在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有<code>const</code>和⾮ <code>const</code>区别，甚⾄可以为空，<code>sizeof</code>指针得到的是指针类型的⼤⼩。</p><p>引⽤来说，它只是⼀块内存的别名，在添加到符号表的时候，是将&quot;引⽤变量名-引⽤对象的地址&quot;添加到符号表中，符号表⼀经完成不能改变，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 <code>const</code> 和⾮<code>const</code>区别。</p><ul><li><p>指针是一个变量，存储地址，引用是别名</p></li><li><p>指针可以有多级，引用只有一级</p></li><li><p>指针可以为空，引用必须初始化</p></li><li><p>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</p></li><li><p>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参。而使用引用作为参数传值对这个引用进行修改则会引起源对象变化</p></li></ul><h5 id="参数传递方式"><a class="header-anchor" href="#参数传递方式"></a>参数传递方式</h5><p>指针传递、引用传递、值传递</p><h5 id="指针分辨"><a class="header-anchor" href="#指针分辨"></a>指针分辨</h5><p>右左法则：使用右左法则时，你从变量名开始，然后根据优先级（括号 &gt; 数组/函数 &gt; 指针）向右看，如果到达声明的末尾，就转向左边继续</p><p><code>int *p[10]</code></p><ul><li><strong>分析</strong>: 首先看到的是 <code>[]</code>，表示 <code>p</code> 是一个数组；然后移动到左边，看到 <code>*</code>，表示数组的元素是指针；最后到最左边，看到 <code>int</code>，表示这些指针指向整型数据。</li><li><strong>结论</strong>: <code>p</code> 是一个有10个元素的数组，每个元素是指向 <code>int</code> 类型数据的指针。</li></ul><p><code>int (*p)[10]</code></p><ul><li><strong>分析</strong>: 首先看到的是 <code>(*p)</code>，括号表示 <code>p</code> 是被 <code>*</code> 解引用的，所以 <code>p</code> 是一个指针；然后外面是 <code>[]</code>，表示这个指针指向的是一个数组；最后是 <code>int</code>，表示数组的元素是整型数据。</li><li><strong>结论</strong>: <code>p</code> 是一个指针，指向一个有10个整型元素的数组。</li></ul><p><code>int *p(int)</code></p><ul><li><strong>分析</strong>: 这是一个函数声明。首先看到的是 <code>(int)</code>，表示有一个整型参数的函数；然后到左边，看到 <code>*p</code>，这里 <code>p</code> 是函数名，<code>*</code> 表示函数返回的是指针；最后到最左边，<code>int</code> 表示这个指针指向整型数据。</li><li><strong>结论</strong>: <code>p</code> 是一个函数，接受一个整型参数，返回一个指向整型数据的指针。</li></ul><p><code>int (*p)(int)</code></p><ul><li><strong>分析</strong>: 首先看到的是 <code>(*p)</code>，括号里的 <code>*</code> 表示 <code>p</code> 是一个指针；外面的 <code>(int)</code> 表示这个指针指向的是一个接受整型参数的函数；最后是 <code>int</code>，表示这个函数返回整型数据。</li><li><strong>结论</strong>: <code>p</code> 是一个指针，指向一个函数，该函数接受一个整型参数并返回一个整型数据。</li></ul><h5 id="左右值引用"><a class="header-anchor" href="#左右值引用"></a>左右值引用</h5><p><strong>左值</strong>：<strong>指的是表达式结束后依然存在的对象</strong>。左值可以出现在赋值表达式的左侧。例如，变量、对数组元素的引用、解引用指针、返回引用的函数调用都是左值。</p><p><strong>右值</strong>：<strong>通常指的是表达式结束就不再存在的临时对象</strong>。右值不能出现在赋值表达式的左侧。字面量（除了字符串字面量外）、返回非引用的函数调用、算术表达式的结果都是右值。</p><p><strong>右值引用</strong></p><p>优点：</p><ol><li>支持移动语义：<strong>右值引用允许将资源（如动态分配的内存）从一个对象移动到另一个对象，而不是传统的复制，从而提高性能和效率</strong>。</li><li>可用于完美转发：右值引用可以用于实现完美转发，即在函数模板中将参数以原始形式传递给其他函数，保留参数的值类别（左值或右值）【即左值被处理后仍然是左值】</li></ol><p>引用折叠：</p><p>出现了左值引用最后折叠的结果都是左值引用，只有右值应用和右值引用折叠才能变成右值引用</p><blockquote><p>T&amp; &amp; =&gt; T&amp;</p><p>T&amp; &amp;&amp; =&gt; T&amp;</p><p>T&amp;&amp; &amp; =&gt; T&amp;</p><p>T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp;</p></blockquote><h5 id="野指针-与-悬空指针"><a class="header-anchor" href="#野指针-与-悬空指针"></a>野指针 与 悬空指针</h5><p>野指针（Wild Pointer）</p><p>野指针是指未初始化的指针。其指向的内存地址是不确定的，因为它没有被明确初始化为NULL或指向有效的内存地址。使用野指针的结果是不可预测的，因为它可能指向任何内存地址，包括系统保留的内存。尝试访问或操作野指针所指向的内存通常会导致不可预测的行为，包括程序崩溃、数据损坏或者安全漏洞。</p><p>悬空指针（Dangling Pointer）</p><p>悬空指针是指向了一块已经被释放的内存的指针。当使用例如<code>free</code>或<code>delete</code>操作释放了一块内存之后，原本指向那块内存的指针就成了悬空指针。与野指针不同，悬空指针之前是指向有效内存的，但在内存释放后继续使用它就变得危险了。因为那块内存可能已经被重新分配给其他用途，对悬空指针的引用或操作可能会导致数据损坏或者不稳定的行为。</p><h5 id="智能指针"><a class="header-anchor" href="#智能指针"></a>智能指针</h5><p><strong>分类</strong></p><p>智能指针是一个类，指向动态分配对象，负责自动释放动态分配的对象，防止内存泄漏</p><p><strong><code>auto_ptr</code></strong> C++98 引入的一种智能指针,可以自动管理动态分配（使用 <code>new</code>）的对象的生命周期，以避免内存泄漏,当 <code>std::auto_ptr</code> 的实例离开作用域时，它会自动删除所管理的对象. 由于缺陷建议被3大智能指针替代</p><p><code>std::auto_ptr</code> 的主要问题:</p><ol><li><strong>所有权转移</strong>：<code>std::auto_ptr</code> 在进行拷贝或赋值时，会发生所有权的转移。这意味着原 <code>std::auto_ptr</code> 会失去对对象的所有权（变为 <code>nullptr</code>），而新的 <code>std::auto_ptr</code> 获得所有权。这种行为很容易导致意外的所有权转移，造成资源管理上的困惑。</li><li><strong>容器兼容性</strong>：由于所有权转移的行为，<code>std::auto_ptr</code> 不能安全地用于标准容器（如 <code>std::vector</code>、<code>std::list</code> 等）。尝试存储 <code>std::auto_ptr</code> 的拷贝在容器中会导致未定义行为，因为容器操作经常需要元素的复制和赋值。</li><li><strong>多线程问题</strong>：<code>std::auto_ptr</code> 没有考虑到多线程环境中的安全性问题。其设计不包含对并发访问的保护，这在多线程程序中可能会导致数据竞争和其他同步问题。</li></ol><p><strong><code>std::unique_ptr</code></strong>：是一种<strong>独占所有权</strong>的智能指针，意味着同一时间内只能有一个<code>unique_ptr</code>指向给定资源。当<code>unique_ptr</code>离开作用域时，它指向的对象会被自动销毁。<strong>这种智能指针不允许复制，确保了资源的独占性，但它允许移动，使得资源的所有权可以转移</strong></p><p><strong><code>std::shared_ptr</code></strong>：是一种<strong>共享所有权</strong>的智能指针，允许多个<code>shared_ptr</code>实例指向同一个对象。内部使用引用计数机制来跟踪有多少个<code>shared_ptr</code>共享同一个资源。当最后一个指向对象的<code>shared_ptr</code>被销毁时，对象会被自动删除。<code>shared_ptr</code>适用于需要通过多个指针访问同一资源的情况。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要<strong>加锁</strong></p><p><strong><code>std::weak_ptr</code></strong>：是一种<strong>不拥有对象</strong>的智能指针，它设计用来解决<code>shared_ptr</code>间的<strong>循环引用问题</strong>。<em><code>weak_ptr</code>指向<code>shared_ptr</code>管理的对象，但不增加引用计数</em>。因此，<code>weak_ptr</code>不会阻止其指向的对·象被销毁。通常，<code>weak_ptr</code>用于临时访问<code>shared_ptr</code>管理的对象，而不希望对对象的生命周期产生影响。可以通过lock函数检查对象是否失效，未失效则转换到<code>shared_ptr</code></p><p><strong>拷贝</strong></p><p>当使用一个智能指针来初始化另一个智能指针时,会调用智能指针的拷贝构造函数。不同的智能指针类型,其拷贝构造行为也不尽相同:</p><ul><li><code>std::unique_ptr</code>: 由于<code>unique_ptr</code>是独占所有权的,不允许拷贝构造,只能进行移动构造。</li><li><code>std::shared_ptr</code>: 拷贝构造会使新的<code>shared_ptr</code>与原<code>shared_ptr</code>共享同一个控制块,从而共享对象的所有权。引用计数会加1。</li><li><code>std::weak_ptr</code>: 拷贝构造不会影响引用计数,新旧<code>weak_ptr</code>指向同一个控制块。</li></ul><p><strong>赋值</strong></p><p>对智能指针进行赋值操作时,行为也因类型而异:</p><ul><li><code>std::unique_ptr</code>: 不允许普通的赋值操作,只能通过移动赋值转移所有权。</li><li><code>std::shared_ptr</code>: 赋值后,两个<code>shared_ptr</code>共享同一个控制块,引用计数会加1。</li><li><code>std::weak_ptr</code>: 赋值不会影响引用计数</li></ul><p><strong>循环引用</strong>：指两个或多个对象相互持有对方的强引用（如 <code>shared_ptr</code>），导致这些对象的引用计数永远不会降为零，从而造成内存泄漏</p><p><strong>实现智能指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr;            <span class="comment">// 原始指针</span></span><br><span class="line">    <span class="type">int</span>* ref_count;    <span class="comment">// 引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ref_count) &#123;</span><br><span class="line">            (*ref_count)--;</span><br><span class="line">            <span class="keyword">if</span> (*ref_count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                <span class="keyword">delete</span> ref_count;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Resource released&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SharedPtr</span><span class="params">(T* p = <span class="literal">nullptr</span>)</span> : ptr(p), ref_count(new int(<span class="number">1</span>)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr&lt;T&gt;&amp; sp) : <span class="built_in">ptr</span>(sp.ptr), <span class="built_in">ref_count</span>(sp.ref_count) &#123;</span><br><span class="line">        (*ref_count)++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SharedPtr&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;sp) &#123;</span><br><span class="line">            <span class="built_in">release</span>(); <span class="comment">// 释放旧的资源</span></span><br><span class="line">            ptr = sp.ptr;</span><br><span class="line">            ref_count = sp.ref_count;</span><br><span class="line">            (*ref_count)++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解引用运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 箭头运算符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ref_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指针是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ref_count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始指针</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from Test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SharedPtr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;  <span class="comment">// 创建一个SharedPtr对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        SharedPtr&lt;Test&gt; sp2 = sp1;    <span class="comment">// 引用计数增加</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出: 2</span></span><br><span class="line">        sp2-&gt;<span class="built_in">say</span>();</span><br><span class="line">    &#125;   <span class="comment">// sp2离开作用域，引用计数减少</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sp1 use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出: 1</span></span><br><span class="line">    sp1-&gt;<span class="built_in">say</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="模板-📏"><a class="header-anchor" href="#模板-📏"></a>模板 📏</h4><ul><li>概念</li></ul><p><strong>函数模板</strong>：允许以任意类型执行相同的操作。例如，可以写一个排序函数，用于任何可以比较元素的数据类型。</p><p><strong>类模板</strong>：允许生成操作任意类型数据的类的实例。例如，<code>std::vector&lt;T&gt;</code>可以存储任何类型<code>T</code>的动态数组</p><p>模板的底层实现机制称为<strong>模板实例化</strong>。<strong>模板本身不是直接编译成机器代码的</strong>，而是在编译器遇到模板使用时（例如，通过指定模板参数来创建对象或调用函数）【两次编译】<strong>在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译</strong></p><p><strong>函数模板实例化</strong>：当你使用特定类型调用一个函数模板时，编译器会生成一个该类型的特定版本的函数。如果你用相同的类型参数再次调用该函数模板，编译器通常会重用之前生成的实例。这意味着对于每一种类型的函数调用，编译器都可能生成一个专门的函数实例。</p><p><strong>类模板实例化</strong>：类模板的实例化过程与函数模板类似。当你声明一个类模板的实例（即对象）时，需要为模板参数提供具体的类型。编译器随后为这些具体类型生成一个特定的类定义。每个不同的参数化类型都会生成一个新的类实例。</p><ul><li>补充</li></ul><ol><li><p>模板中<code>typename</code>和<code>class</code>区别</p><p><code>class</code>用于声明一个类型参数，可以是任何类型包括基本数据类型等；而<code>typename</code>也能这样用，但他主要用于依赖类型的情况，即模板内部依赖于模板参数的类型，其主要是解决编译器解析依赖类型名称时的歧义（例如<code>T::iterator</code>就是一个依赖于模板参数的类型）</p></li></ol><hr><h4 id="其它-🔦"><a class="header-anchor" href="#其它-🔦"></a>其它 🔦</h4><h5 id="C-与-C"><a class="header-anchor" href="#C-与-C"></a>C++ 与 C</h5><ol><li><strong>面向对象支持</strong>：C++是一种面向对象的编程语言，支持类封装、继承、多态等面向对象的特性，同时引入模板概念呢。而C语言则是一种面向过程的编程语言，没有直接支持面向对象的特性。</li><li><strong>标准库</strong>：C标准库主要提供了基本输入输出、字符串处理等功能函数。而C++标准库除了包含了所有C标准库函数外，还添加了对面向对象特性（如容器、算法）的支持，以及更重要的STL库</li><li><strong>安全性</strong>：应对C的不安全性，C++增加了许多机制和特性来应对这些安全性问题，例如cast转换、异常处理机制、智能指针、<code>nullptr</code>类型</li><li><strong>内存分配</strong>：<code>new</code> <code>delete</code>取代<code>malloc</code> <code>free</code></li></ol><h5 id="C-与-C-v2"><a class="header-anchor" href="#C-与-C-v2"></a>C++ 与 C#</h5><p><strong>C#</strong></p><ul><li>C#通常运行在托管环境中，例如.NET Framework或.NET Core。它依赖于CLR（Common Language Runtime）来执行代码，并使用CIL（Common Intermediate Language）作为中间语言</li><li>C#具有自动垃圾回收机制，开发人员不需要手动释放内存。CLR会周期性地检查不再使用的对象，并自动释放它们所占用的内存</li><li>C#通过.NET Core实现了跨平台支持</li></ul><p><strong>C++</strong></p><ul><li>C++可以编译为本地机器代码，不依赖于特定的运行时环境</li><li>C++需要手动管理内存，开发人员需要显式地分配和释放内存，避免内存泄漏和野指针等问题</li><li>C++本身是跨平台的，可以通过适当的编译器和工具链在各种平台上进行开发和运行</li></ul><h5 id="编译过程"><a class="header-anchor" href="#编译过程"></a>编译过程</h5><p>**预处理阶段：**在这个阶段，预处理器处理源文件中的预处理指令，处理器会根据这些指令展开头文件并替换宏定义，生成一个经过预处理的源文件.ii</p><p>**编译阶段：**编译器将预处理后的源文件转换成汇编代码。编译器会对源文件进行词法分析、语法分析和语义分析，<strong>并生成相应的中间代码或汇编代码 .s</strong></p><p><strong>汇编阶段：<strong>汇编器将汇编代码转换成机器码或者目标文件。汇编器会将汇编代码转换成</strong>可重定位的机器码，并生成目标文件 .o</strong></p><p><strong>链接阶段：<strong>链接器将</strong>目标文件和库文件链接</strong>在一起，生成最终的可执行文件 .out</p><p><strong>启动过程</strong></p><p><code>main</code>函数执行前后干了什么</p><p>初始化<code>.data</code>和<code>.bss</code>段的内容-在<code>main</code>前调用全局对象的构造函数-传递<code>argc</code>和<code>argv</code>参数</p><p>全局对象析构函数在<code>main</code>函数之后执行</p><h5 id="动态-静态"><a class="header-anchor" href="#动态-静态"></a>动态\静态</h5><h6 id="链接"><a class="header-anchor" href="#链接"></a>链接</h6><p><strong>静态链接</strong></p><p>在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件</p><p>优点：可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快</p><p>缺点：导致内存中副本代码过多，源库代码修改了，链接过该库的程序要重新进行编译链接</p><p><strong>动态链接</strong></p><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形 成一个完整的程序</p><p>优点：多个程序在执行时共享同一份副本,更新时只需要替换原来的目标文件，而无需将所有程序再重新链接一遍</p><p>缺点:为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失</p><h6 id="断言"><a class="header-anchor" href="#断言"></a>断言</h6><p>静态断言（Static Assertion）：</p><p>静态断言是在编译时进行的，即在代码被编译之前就会执行。</p><p>使用静态断言可以对编译期间已知的条件进行检查。</p><p>静态断言使用静态表达式来定义条件，并且如果条件为假，则会导致编译错误。</p><p>静态断言通常用于验证编译期常量、类型属性或其他与类型相关的约束。</p><p>动态断言（Dynamic Assertion）：</p><p>动态断言是在运行时进行的，即在程序执行过程中才会执行。</p><p>使用动态断言可以对运行时条件进行检查。</p><p>动态断言使用 assert() 宏来定义条件，并且如果条件为假，则会触发一个运行时错误，并终止程序执行。</p><p>动态断言通常用于验证假设、调试程序或捕获意外情况。</p><h6 id="类型"><a class="header-anchor" href="#类型"></a>类型</h6><p>静态类型：编译期间绑定，静态类型的语言要求在编译时确定所有变量的类型</p><p>动态类型：运行期决定，动态类型的语言允许变量在运行时改变其类型</p><h6 id="绑定"><a class="header-anchor" href="#绑定"></a>绑定</h6><p>静态绑定：绑定的是静态类型，将<strong>函数和对应的属性</strong>依赖绑定到相应的对象的静态类型。指的是对象的方法调用在编译时就已经解析，编译器知道具体调用哪个方法</p><p>动态绑定：绑定的是动态类型，将<strong>函数和对应的属性</strong>依赖绑定到相应的对象的动态类型（例如虚函数）。指的是方法调用的目标在运行时才确定</p><h6 id="多态-略"><a class="header-anchor" href="#多态-略"></a>多态(略)</h6><h5 id="RAII"><a class="header-anchor" href="#RAII"></a>RAII</h5><p>Resource Acquisition Is Initialization(RAII) 核心思想是：在对象的生命周期内获取所需的资源，并在对象销毁时释放这些资源。这种方式利用了C++的构造函数和析构函数自动调用的特性，确保资源使用安全且高效，这也是为什么C++比C安全的原因之一。智能指针便是RAII最具代表的实现。</p><h5 id="RTTI"><a class="header-anchor" href="#RTTI"></a>RTTI</h5><p>Run Time Type Identification 通过运行时类型识别，程序能够使用<strong>基类的指针或引用</strong>来<strong>检查着这些指针或引用所指的对象的实际派生类型</strong> typeid dynamic_cast</p><h5 id="OOP"><a class="header-anchor" href="#OOP"></a>OOP</h5><table><thead><tr><th></th><th>OOP</th><th>POP</th></tr></thead><tbody><tr><td>概念</td><td>将问题分解成一系列步骤或称之为过程的操作序列。编程的焦点是在执行具体任务的过程和函数</td><td>将问题分解成一组相互作用的对象，每个对象代表现实世界中的实体或概念。编程的焦点是对象及其交互</td></tr><tr><td>单位</td><td>函数</td><td>类和对象</td></tr><tr><td>适用场景</td><td>较小、单一任务或脚本，尤其是简单的、逻辑线性的任务</td><td>大型的、复杂的系统，特别是需要多次迭代和维护的项目</td></tr><tr><td>实现抽象</td><td>抽象通常限于函数</td><td>支持较高级别的抽象，如类抽象和多态</td></tr></tbody></table><p><strong>封装</strong>:信息隐藏</p><p><strong>继承</strong>:继承是使用已存在的类的定义作为基础建立新类</p><p><strong>多态</strong>:发出的方法调用在编程时并不确定，而是在程序运行期间才确定</p><ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol><h5 id="锁"><a class="header-anchor" href="#锁"></a>锁</h5><p><strong><code>std::mutex</code></strong>:</p><ul><li>最基本的互斥锁。</li><li>提供了排他性访问，即一次只有一个线程可以持有锁。</li></ul><p><strong><code>std::recursive_mutex</code></strong>:</p><ul><li>递归互斥锁，允许同一个线程多次获取同一互斥锁。</li></ul><p><strong><code>std::timed_mutex</code></strong> 和 <strong><code>std::recursive_timed_mutex</code></strong>:</p><ul><li>这些锁提供了基于时间的锁定功能。</li><li>允许尝试在指定的时间段内获取锁。</li></ul><p><strong><code>std::shared_mutex</code></strong> (自 C++14 开始支持, 在 C++17 中更名为 <code>std::shared_timed_mutex</code>):</p><ul><li>允许多个线程同时读取共享数据，但写入时需要独占访问。</li><li>适用于读多写少的场景，可以提高并发性。</li></ul><p><strong><code>std::lock_guard</code></strong>:</p><ul><li>是一个作用域锁，保护一个代码段，使之在多线程环境下线程安全，使用 RAII（资源获取即初始化）方式管理 <code>std::mutex</code>。</li><li>当 <code>std::lock_guard</code> 对象创建时自动加锁，当作用域结束时自动解锁，避免忘记解锁的问题。</li></ul><p><strong><code>std::unique_lock</code></strong>:</p><ul><li>比 <code>std::lock_guard</code> 更灵活的作用域锁。</li><li>可以在生命周期内多次锁定和解锁。</li><li>支持条件变量 <code>std::condition_variable</code>。</li></ul><h5 id="多线程"><a class="header-anchor" href="#多线程"></a>多线程</h5><ul><li>补充</li></ul><p>使用线程池可能带来哪些风险和有哪些好处？</p><p>好处：减少创建和销毁线程的开销与降低系统资源消耗、更好的线程管理和调度</p><p>风险：资源争用和死锁、复杂性增加</p><p>线程池参数有哪些？</p><p>大小、任务队列容量、线程创建策略、线程拒绝策略、线程活跃时间、核心线程数、最大线程数量、线程优先级</p><p>线程池大小如何确定合理？是否和处理器有关？</p><p>CPU密集型任务：如果任务主要是计算密集型的（例如数学运算），那么线程池的大小通常设为处理器核心数的1到1.5倍。这样可以最大化CPU使用率，同时留有少量空间处理其他可能同时发生的系统任务或其他程序。在完全的CPU密集型场景中，线程数设置为核心数相等通常也是合理的，因为更多的线程不会带来性能提升，反而可能因上下文切换导致效率下降。</p><p>I/O密集型任务：如果任务涉及大量的输入/输出操作，如文件操作、网络通信等，这些操作通常涉及等待，此时CPU核心会空闲。在这种情况下，线程池大小可以设置得比核心数多，通常是核心数的2到3倍，甚至更多，以确保CPU在等待I/O操作完成时可以切换到其他任务。</p><p>常用的线程池工作队列？</p><p>无界队列、有界队列、优先级队列、同步队列、延迟队列</p><h5 id="线程池的设计思路"><a class="header-anchor" href="#线程池的设计思路"></a>线程池的设计思路</h5><p>实现线程池有以下几个步骤： （1）设置一个生产者消费者队列，作为临界资源。</p><p>（2）初始化n个线程，并让其运行起来，加锁去队列里取任务运行</p><p>（3）当任务队列为空时，所有线程阻塞。</p><p>（4）当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量去通知阻塞中的一个线程来处理。</p><p>如果是CPU密集型应用，则线程池大小设置为：核数目+1<br>如果是IO密集型应用，则线程池大小设置为：2CPU数目+1</p><h5 id="常用Linux命令"><a class="header-anchor" href="#常用Linux命令"></a>常用Linux命令</h5><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>man</td><td>帮助命令</td></tr><tr><td>ls命令</td><td>查看当前文件与目录信息</td></tr><tr><td>cd命令</td><td>用于切换当前目录</td></tr><tr><td>pwd命令</td><td>用于显示工作目录。</td></tr><tr><td>mkdir命令</td><td>mkdir 命令用于创建文件夹。</td></tr><tr><td>rm命令</td><td>删除文件或文件夹命令</td></tr><tr><td>rmdir 命令</td><td>从一个目录中删除一个或多个子目录项</td></tr><tr><td>mv命令</td><td>移动文件或文件夹命令</td></tr><tr><td>cp命令</td><td>复制命令</td></tr><tr><td>cat命令</td><td>查看文件内容；连接文件</td></tr><tr><td>more命令</td><td>more 会以一页一页的显示文件内容</td></tr><tr><td>less命令</td><td>less 与 more 类似，但使用 less 可以随意浏览文件</td></tr><tr><td>grep命令</td><td>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工。</td></tr><tr><td>ps命令</td><td>查看进程情况</td></tr><tr><td>top命令</td><td>可以查看操作系统的信息，如进程、CPU占用率、内存信息等</td></tr><tr><td>kill命令</td><td>向进程发送终止信号</td></tr></tbody></table><h5 id="分布式"><a class="header-anchor" href="#分布式"></a>分布式</h5><p>分布式系统中的通信方式有哪些？</p><blockquote><ul><li><strong>消息传递</strong>：节点之间通过发送和接收消息进行通信。</li><li><strong>远程过程调用（RPC）</strong>：允许程序调用远程节点上的函数或方法。</li><li><strong>共享存储</strong>：节点通过共享的存储系统进行数据交换。</li></ul></blockquote><p><strong>什么是一致性问题？</strong></p><blockquote><p>一致性问题指在分布式系统中，多个副本的数据状态需要保持一致。常见的一致性模型包括：</p><ul><li><strong>强一致性</strong>：所有读操作都能看到最新的写操作结果。</li><li><strong>弱一致性</strong>：系统不保证读操作能看到最新的写操作结果。</li><li><strong>最终一致性</strong>：在没有新更新的情况下，所有副本最终会达到一致状态</li></ul></blockquote><p><strong>分布式系统中的负载均衡是什么？</strong></p><blockquote><p>负载均衡是将工作负载均匀分配到多个节点上的技术，以提高系统的性能和可靠性。常见的负载均衡算法包括：</p><ul><li><strong>轮询（Round Robin）</strong>：依次将请求分配给每个节点。</li><li><strong>最小连接数（Least Connections）</strong>：将请求分配给当前连接数最少的节点。</li></ul></blockquote><p><strong>分布式系统中的故障处理有哪些策略？</strong></p><blockquote><ul><li><strong>容错（Fault Tolerance）</strong>：通过冗余设计和备份来应对节点故障。</li><li><strong>重试机制</strong>：在操作失败时自动重试，以应对暂时性故障。</li><li><strong>故障检测和恢复</strong>：检测故障节点并自动恢复服务</li></ul></blockquote><p><strong>分布式系统中的一致性协议有哪些？</strong></p><blockquote><ul><li><strong>Paxos</strong>：一种广泛使用的分布式一致性协议，保证在部分节点故障情况下仍能达成一致。</li><li><strong>Raft</strong>：一种相对易于理解和实现的一致性协议，提供领导选举和日志复制机制。</li></ul></blockquote><p><strong>什么是CAP定理？</strong></p><blockquote><p>CAP定理指出，在分布式系统中，无法同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）。在设计系统时，必须在这三者之间进行权衡。通常选择分区容忍性，然后在一致性和可用性之间做出取舍</p></blockquote><p><strong>分布式系统中的事务处理如何实现？</strong></p><blockquote><p>分布式事务处理需要确保跨多个节点的操作要么全部成功，要么全部失败。常见模型包括：</p><ul><li><strong>两阶段提交（2PC）</strong>：协调者首先请求所有参与者准备提交，然后在所有参与者准备好后发出提交命令。</li><li><strong>三阶段提交（3PC）</strong>：在两阶段提交基础上增加一个预提交阶段，以提高容错性。</li></ul></blockquote><hr><h4 id="问题记录1"><a class="header-anchor" href="#问题记录1"></a>问题记录1</h4><blockquote><p>答题模板：</p><p>各自概念</p><p>对比\优缺点</p></blockquote><h5 id="C-C-语言基础部分"><a class="header-anchor" href="#C-C-语言基础部分"></a>C/C++ 语言基础部分</h5><p>常见问题：智能指针、多态、虚函数、stl原理。</p><ul><li><p>智能指针实现原理</p></li><li><p>智能指针，里面的计数器何时会改变</p></li><li><p>智能指针和管理的对象分别在哪个区（智能指针本身在栈区，托管的资源在堆区，利用了栈对象超出生命周期后自动析构的特征，所以无需手动delete释放资源。</p></li><li><p>面向对象的特性：多态原理</p></li><li><p>介绍一下虚函数，虚函数怎么实现的</p></li><li><p>多态和继承在什么情况下使用</p></li><li><p>除了多态和继承还有什么面向对象方法</p></li><li><p>C++内存分布。什么样的数据在栈区，什么样的在堆区</p></li><li><p>C++内存管理（RAII啥的）</p><p>C++中的内存管理涉及多个方面：首先，内存被分为栈、堆、全局/静态存储区和常量区。栈上的内存分配是自动管理的，而堆上的内存需要我们手动管理，通常使用<code>new</code>和<code>delete</code>或者智能指针来避免内存泄漏和悬挂指针的问题。智能指针如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>提供了自动化的内存管理，尤其是在复杂的应用场景中非常有用。此外，C++还支持RAII原则，通过构造和析构函数自动管理资源，这有助于确保在异常或早期返回时释放资源。常见的内存管理问题包括内存泄漏、悬挂指针、缓冲区溢出和双重释放。我在项目中通常使用智能指针来管理资源，以避免这些问题，并遵循RAII的原则确保异常安全性</p></li><li><p>C++从源程序到可执行程序的过程</p></li><li><p>一个对象=另一个对象会发生什么（赋值构造函数）</p></li><li><p>如果new了之后出了问题直接return。会导致内存泄漏。怎么办（智能指针，raii）</p></li><li><p>c++11的智能指针有哪些。weak_ptr的使用场景。什么情况下会产生循环引用</p></li><li><p>多进程fork后不同进程会共享哪些资源</p></li><li><p>多线程里线程的同步方式有哪些</p></li><li><p>size_of是在编译期还是在运行期确定</p></li><li><p>函数重载的机制。重载是在编译期还是在运行期确定</p></li><li><p>指针常量和常量指针</p></li><li><p>vector的原理，怎么扩容</p></li><li><p>介绍一下const</p></li><li><p>引用和指针的区别</p></li><li><p>Cpp新特性知道哪些</p></li><li><p>类型转换</p></li><li><p>RAII基于什么实现的（生命周期、作用域、构造析构</p></li><li><p>手撕：Unique_ptr，控制权转移(移动语义）</p></li><li><p>手撕：类继承，堆栈上分别代码实现多态</p></li><li><p>unique_ptr和shared_ptr区别</p></li><li><p>右值引用</p></li><li><p>函数参数可不可以传右值</p></li><li><p>参考c/c++堆栈实现自己的堆栈。要求：不能用stl容器。</p></li><li><p>stl容器了解吗？底层如何实现：vector数组，map红黑树，红黑树的实现</p></li><li><p>完美转发介绍一下 去掉std::forward会怎样？</p></li><li><p>介绍一下unique_lock和lock_guard区别？</p></li><li><p>C代码中引用C++代码有时候会报错为什么？</p></li><li><p>静态多态有什么？虚函数原理 虚表是什么时候建立的 为什么要把析构函数设置成虚函数？</p></li><li><p>map为啥用红黑树不用avl树？（几乎所有面试都问了map和unordered_map区别）</p></li><li><p>inline 失效场景</p></li><li><p>C++ 中 struct 和 class 区别</p></li><li><p>如何防止一个头文件 include 多次</p></li><li><p>lambda表达式的理解，它可以捕获哪些类型</p></li><li><p>友元friend介绍</p></li><li><p>move函数</p></li><li><p>模版类的作用</p></li><li><p>模版和泛型的区别</p></li><li><p>内存管理：C++的new和malloc的区别</p></li><li><p>new可以重载吗，可以改写new函数吗</p></li><li><p>C++中的map和unordered_map的区别和使用场景</p></li><li><p>他们是线程安全的吗</p></li><li><p>c++标准库里优先队列是怎么实现的？</p></li><li><p>gcc编译的过程</p></li><li><p>C++ Coroutine</p></li><li><p>extern C有什么作用</p></li><li><p>c++ memoryorder/elf文件格式/中断对于操作系统的作</p></li><li><p>C++的符号表</p></li><li><p>C++的单元测试</p></li></ul><h5 id="数据结构"><a class="header-anchor" href="#数据结构"></a>数据结构</h5><p>常见问题：链表、排序、二叉树。</p><ul><li>数组和链表区别和优缺点</li><li>快速排序</li><li>堆排序是怎么做的</li><li>冒泡排序</li><li>二分查找（复杂度）</li><li>hash表数据很大。rehash的代价很高，怎么办</li><li>二叉树前序遍历非递归</li><li>链表反转</li><li>二叉树输出每一层最右边的节点</li><li>千万级数组如何求最大k个数？（用最小堆反之最大堆） 千万数据范围有限，0到1000，有很多重复的，按频率排序怎么处理？</li><li>计算二叉树层高。</li><li>给一个连续非空子数组，找它乘积最大的（动态规划）</li><li>排序算法. 哪些是稳定的，哪些不稳定的</li><li>树的深度和高度。一开始分别用了一个层序遍历和一个dfs，然后面试官问能否都在一个dfs里面呢，提示了一下在dfs是否可以传一个参数，然后解决了。</li><li>布隆过滤器介绍</li><li>为什么不用布隆过滤器</li><li>.数据结构相关，图的种类，表示方法，图有哪些经典算法+描述算法</li><li>求最大的k个数字，解法：优先队列（堆）或者快速排序</li><li>一个大数问题，解法：转换为字符串解决，这题没写好，leetcode应该有很多类似的问题</li><li>hash解决冲突 （ 开放定址法、链地址法、再哈希法、建立公共溢出区 ），四种方式详细的过程、思路</li><li>链地址法和再哈希法之间的关联和区别，两者分别适用场景，两者底层的数据结构，关联和区别</li><li>链表和数组的底层结构设计、关联、区别、应用场景</li></ul><h5 id="gdb-gcc-g"><a class="header-anchor" href="#gdb-gcc-g"></a>gdb/gcc/g++</h5><ul><li>什么是GDB？它用于做什么？</li><li>GDB的常用命令有哪些？</li><li>如何在GDB中设置断点？</li><li>如何在GDB中查看变量的值？</li><li>如何使用GDB进行程序调试时，定位内存泄漏问题？</li><li>请解释GCC和G++之间的区别。</li><li>GCC和G++都可以编译C++代码吗？如果可以，有什么不同之处？</li><li>GCC的常用编译选项有哪些？</li><li>G++的常用编译选项有哪些？</li><li>如何在GCC/G++中指定特定版本的标准（如C++11或C++14）进行编译？</li><li>怎么debug，怎么看内存泄漏。</li><li>gdb 使用 -&gt; 多线程程序切换到某线程栈帧 -&gt; 如何查看寄存器值</li><li>怎么分析C++的core文件</li><li>GDB有哪些命令</li><li>gcc和g++的区别</li><li>Linux下程序有问题，如何调试？（答GDB打开，打上Breakpoint进行调试）</li></ul>]]></content>
    
    
    <summary type="html">知识点总结新版</summary>
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
    <category term="C++" scheme="https://ninokz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Point</title>
    <link href="https://ninokz.github.io/2024/05/14/CppLearning/"/>
    <id>https://ninokz.github.io/2024/05/14/CppLearning/</id>
    <published>2024-05-14T06:36:07.130Z</published>
    <updated>2024-08-29T12:43:09.253Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础语法-📖"><a class="header-anchor" href="#基础语法-📖"></a>基础语法 📖</h3><h4 id="static"><a class="header-anchor" href="#static"></a>static</h4><ul><li><strong>解释</strong></li></ul><blockquote><p>修改对象的存储区域和生命周期，分为修饰函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>、修饰变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>、防止冲突<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">^{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p><strong>1</strong>修饰变量：变量所在对象只保存一个该变量，而且能够直接访问 <strong>[static 变量存储于全局数据区]</strong>；</p><p><strong>2</strong>修饰成员函数：不需要生成对象实例就可以访问该函数**[static 函数仍然存储与代码区]**；</p><p><strong>3</strong>在多人开发项目时，为了防止与他人命名空间里的函数重名，通过static修饰能做到这一点</p></blockquote><ul><li>作用</li></ul><p>隐藏：未加static前缀的全局变量和函数都具有全局可见性</p><p>持久化：static的第二个作用是保持变量内容的持久（static变量中的记忆功能和全局生存期）存储在<strong>静态数据区</strong>的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围</p><p>置0：默认初始化为0</p><h4 id="const"><a class="header-anchor" href="#const"></a>const</h4><ul><li><strong>解释</strong></li></ul><blockquote><p>对被修饰对象进行限定，在初始化后对象在后续过程中不能进行修改操作，类似于将其视作常量。4种修饰类型：修饰变量、修饰指针、修饰引用、修饰函数</p></blockquote><ul><li><strong>const的修饰</strong></li></ul><p>const 变量（略）</p><p>const 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰成员函数，说明该成员函数内不能修改成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcation</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>const 引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; aRef = a;</span><br><span class="line"><span class="type">int</span>&amp; b = aRef;</span><br><span class="line"><span class="comment">// Error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;const int&#x27;</span></span><br><span class="line"><span class="comment">// int&amp; b = aRef 错误，我们不可以根据b修改a的值，因为a本身不可修改</span></span><br></pre></td></tr></table></figure><p>const 指针 ⭐</p><p><strong>顶层const</strong>和<strong>底层const</strong>：从以下代码看出const修饰的影响，前者表示指针本身是常量（不可更改），后者表示指针所指对象是常量（对象不可更改）。通常意义上来讲顶层const的限制弱于底层 const。所以在进行拷贝操作时，<strong>顶层const基本上不受影响，而底层const的限制性更大</strong>，当进行拷贝考入考出时，左右对象必须是相同的底层const资格（因为执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const）</p><p>底层const和顶层const</p><p>​<strong>顶层</strong>const：指的是const修饰的变量<strong>本身</strong>是一个常量，无法修改，指的是指针，就是 * 号的右边</p><p>​<strong>底层</strong>const：指的是const修饰的变量<strong>所指向的对象</strong>是一个常量，指的是所指变量，就是 * 号的左边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// 顶层const</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* c = &amp;a; <span class="comment">// 底层const, 指向对象不可更改</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> d = &amp;b; <span class="comment">// 顶层const, 指针自身不能更改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> e = &amp;a; <span class="comment">// 前一个为底层const 后一个为顶层const</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>总结</strong></p><p>需要记住<em><strong>const修饰对象将会导致一个不可更改的对象即可</strong></em>。对待这个东西我个人的处理看待方式就是，先搞清楚目标对象是什么样的const，然后再做处理，也许和指针引用搭配的时候是有点绕。在确定对象是在当前过程中readonly的，那么我们就应该对其const修饰，对于非内部数据的输入参数，应该将单纯的值类型<code>A a</code>更改为<code>const A&amp; a</code>，避免了拷贝，同时避免了对其修改，提高了效率</p></li><li><p><strong>区别辨析</strong></p></li></ul><table><thead><tr><th>#define</th><th>const</th></tr></thead><tbody><tr><td>宏定义，相当于字符替换</td><td>常量声明</td></tr><tr><td>预处理器处理</td><td>编译器处理</td></tr><tr><td><strong>无类型安全检查</strong></td><td><strong>有类型安全检查</strong></td></tr><tr><td>不分配内存</td><td>要分配内存</td></tr><tr><td><strong>存储在代码段</strong></td><td>存储在数据段</td></tr><tr><td>可通过 <code>#undef</code> 取消</td><td>不可取消</td></tr></tbody></table><ul><li>QA</li></ul><ol><li>C中用const 能定义真正意义上的常量吗？C++中的const呢？</li></ol><p>c中的局部const常量存储在栈空间，全局const常量存在只读存储区，所以全局const常量也是无法修改的，它是一个只读变量，常量并非仅仅是不可修改，而是相对于变量，它的值在编译期已经决定，而不是在运行时决定</p><p>C++中只有用字面量初始化的const常量会被加入符号表，而变量初始化的const常量依然只是只读变量，C++中const成员为只读变量，可以通过指针修改const成员的值，另外const成员变量只能在初始化列表中进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* pa = (<span class="type">int</span>*)&amp;a;</span><br><span class="line">*pa = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*pa = %d, a = %d&quot;</span>, *pa, a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 这是未定义行为</span></span><br></pre></td></tr></table></figure><ol start="2"><li>C++ ⾥是怎么定义常量的？常量存放在内存的哪个位置</li></ol><p>对于局部常量，存放在栈区；</p><p>对于全局常量，编译期⼀般不分配内存，有时编译器会把放在符号表中以提⾼访问效率；</p><p>字⾯值常量，⽐如字符串，放在常量区；</p><h4 id="this"><a class="header-anchor" href="#this"></a>this</h4><ul><li><strong>解释</strong></li></ul><blockquote><p>在类的非静态成员函数中，<code>this</code>指针是隐式可用的，它指向调用成员函数的对象实例。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>在类<code>T</code>的成员函数内，<code>this</code>的类型是<code>T* const</code>。这意味着<code>this</code>是一个指向<code>T</code>类型的常量指针，你不能改变<code>this</code>指针的指向，即不能让<code>this</code>指向另一个对象，但可以修改这个对象的成员（除非成员是<code>const</code>）底层const。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>在const成员函数中，<code>this</code>指针的类型是<code>const T* const</code>，这意味着你既不能改变<code>this</code>指针的指向，也不能通过<code>this</code>指针修改对象的成员</p></blockquote><ul><li>QA</li></ul><p>1.可否delete this?</p><p><code>delete this</code> 是合法的，但是要非常小心使用。<code>delete this</code> 语句用于在对象的成员函数中释放该对象的内存，但这种操作需要确保在调用该语句之后，不再访问已释放的内存，否则会导致未定义的行为或程序崩溃</p><p>2.类的析构函数中delete this？</p><p>无限递归导致 stack overflow</p><h4 id="inline"><a class="header-anchor" href="#inline"></a>inline</h4><ul><li><strong>解释</strong></li></ul><blockquote><p>内联函数是C++中的一种函数声明方式，它告诉（<strong>建议</strong>）编译器在调用函数时将函数的代码插入到调用处，而不是像普通函数那样通过跳转执行。这样做可以减少函数调用的开销，提高程序的执行效率。</p><p>编译器不一定会遵循<code>inline</code>关键字，它可能会根据具体情况决定是否将函数内联。通常情况下，编译器会将短小的函数内联，而对于较大的函数，编译器可能会忽略<code>inline</code>关键字</p></blockquote><ul><li><strong>特征</strong></li></ul><p>优点：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而<strong>宏定义则不会</strong>。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">^{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏<strong>定义则不能</strong>。</p><p>缺点：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>包括可能导致代码体积增加，因为函数的代码会被复制到每个调用处，以及可能增加编译时间</p><ul><li>QA</li></ul><p>1.构造函数与析构函数进行内联？</p><p><strong>结论</strong>：<strong>将构造函数和析构函数声明为inline是没有什么意义</strong>即编译器并<strong>不</strong>真正对声明为 <code>inline </code>的构造和析构函数进行内联操作</p><p><strong>原因</strong>：因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简。即实际上这两个函数很复杂，编译器不会对其<code>inline</code></p><p>2.虚函数内联?</p><p><strong>结论</strong>：当是指向派生类的指针（多态性）调用 <code>inline </code>的虚函数时，不会内联展开；当是对象本身调用 inline 的虚函数时，会内联展开</p><p><strong>原因</strong>：虚函数是为了实现运行时多态性而设计的，它允许在派生类中重写基类中的同名函数，而在运行时动态地确定应该调用哪个版本的函数，内联函数允许在调用处直接展开函数的代码，以减少函数调用的开销。但是，对于虚函数来说，编译器需要在运行时确定实际调用的函数版本，这与内联函数的特性相矛盾。因此，虚函数通常不会被声明为内联函数。虚函数的实现通常涉及虚函数表（vtable）和虚函数指针（vptr），而内联函数的展开是在编译期间完成的，这两者的机制不兼容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span><span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，</span></span><br><span class="line"> <span class="comment">// 编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line"> Base b;</span><br><span class="line"> b.<span class="built_in">who</span>();</span><br><span class="line"> <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，</span></span><br><span class="line"> <span class="comment">// 所以不能为内联。</span></span><br><span class="line"> Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"> ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>内联问题</th></tr></thead><tbody><tr><td>虚函数内联（类中本身调用才展开，指针调用情况下不会）</td></tr><tr><td>构造函数内联（没意义）</td></tr><tr><td>析构函数内联（没意义）</td></tr></tbody></table><h4 id="sizeof"><a class="header-anchor" href="#sizeof"></a>sizeof</h4><ul><li>解释</li></ul><blockquote><p>主要是求变量或者类型的大小；需要分辨的是作用于类、结构体、指针、数组；以及数据对齐问题；计算结构体大小问题</p></blockquote><ul><li>解析</li></ul><p>作用于变量、指针、数组</p><p><code>sizeof(var)</code>返回变量所占大小、<code>sizeof(pointer)</code>返回4或者8，这个与编译对象目标平台有关，<code>sizeof(array)</code>返回 类型大小*数组长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::string str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(str1) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(str2) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(str3) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 第一个返回4或8，因为它是个指针，第二个是个数组，不过末尾有个\0结束符，所以它的值是6,第三个std::string对象的大小通常为24字节或32字节或40字节，这取决于具体的实现和编译器，等于sizeof(std::string)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArraySize</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">5</span>])</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of array in function: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Size of array in function: 20 当数组以引用的形式传递给函数时，sizeof 运算符会返回整个数组的大小。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArraySize</span><span class="params">(<span class="type">int</span>* arr)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of array in function: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Size of array in function: 8 当数组以指针形式传递给函数时，sizeof 运算符会返回指针的大小，而不是数组的大小。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作用于结构体</p><blockquote><p>数据对齐：起始位置的偏移量必须是该变量类型大小的整数倍</p><p>why</p><ul><li><strong>硬件优化</strong>：许多硬件平台对特定类型的数据访问有最优的内存对齐要求。正确对齐的数据可以直接从内存读取，而<strong>未对齐的数据可能需要多次访问才能完成读取</strong>，这样会降低性能。</li><li><strong>平台要求</strong>：某些平台可能不允许未对齐的内存访问，尝试这样做可能导致硬件异常。</li></ul><p>method</p><ol><li>结构体变量的首地址是其最宽基本成员类型大小的整数倍。</li><li>结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍。</li><li>结构体的总大小为结构体最宽基本成员类型大小的整数倍。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Goo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Coo</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Foo) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Goo) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Coo) &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>Foo 布局<code>| c (1 byte) | padding (3 bytes) | i (4 bytes) | d (8 bytes) |</code></p><p>Goo 布局<code>| c (1 byte) | padding (7 bytes) | d (8 bytes) | i (4 bytes) | padding (4 bytes) |</code></p><p><code>sizeof(空结构体)</code> 在C中是0，在C++中是1。C++标准规定，不同的对象不能拥有相同的内存地址</p><p>作用于类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Koo</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Voo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Koo) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Voo) &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p>对只有一个函数的类进行<code>sizeof</code>运算结果是多少？看这个函数是不是虚函数。如果不是虚函数，则结果是1,如果是虚函数，则大小是4或者8</p><h4 id="volatile"><a class="header-anchor" href="#volatile"></a>volatile</h4><ul><li>解释</li></ul><blockquote><p>编译器会对代码进行各种优化，该关键字告诉编译器<strong>不要对这些变量的读写操作进行优化</strong></p><p>volatile 关键字可以用来提醒编译器使用 volatile 声明的变量随时有可能改变，因此编译器在代码编译时就不会对该变量进行某些激进的优化，故而编译生成的程序在每次存储或读取该变量时，都会直接从内存地址中读取数据而非寄存器(volatile 变量的操作并不是原子)</p><p>编译器不会对volitale变量的读取和写入进行优化，每次需要读取或写入这个变量时，都会直接从内存中读取或写入数据，而不是使用寄存器中的缓存值</p></blockquote><h4 id="extern-“c”"><a class="header-anchor" href="#extern-“c”"></a>extern “c”</h4><ul><li>解释</li></ul><blockquote><p>被 extern 限定的函数或变量是 extern 类型的</p><p>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</p></blockquote><h4 id="explict"><a class="header-anchor" href="#explict"></a>explict</h4><ul><li>解释</li></ul><blockquote><p>explicit 修饰构造函数时，可以防止<strong>隐式转换和复制初始化</strong></p><p>explicit 修饰转换函数时，可以防止隐式转换</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;</span><br><span class="line"><span class="comment">// constructor code</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;MyClass copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line"><span class="comment">// function code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 编译通过，隐式类型转换为 MyClass 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">// constructor code</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line"><span class="comment">// function code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 编译错误，禁止隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cast"><a class="header-anchor" href="#cast"></a>?_cast</h4><ul><li>解释</li></ul><blockquote><p>引入 <code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code> 等类型转换关键字，主要是为了<strong>提供类型转换的安全性和可控性</strong>。与C语言中的传统类型转换（使用强制类型转换操作符 <code>(type)</code>）相比，这些关键字更加清晰、可读，并且在编译时提供更多的类型检查。</p></blockquote><ul><li>引入原因</li></ul><blockquote><p>引入原因</p><p><strong>安全性</strong>:提供更严格的类型检查，避免类型转换中的潜在错误。在编译时检测类型转换的合法性，减少运行时错误。</p><p><strong>可读性</strong>:通过不同的关键字表示不同类型的转换，代码意图更明确。提高代码的可维护性，程序员可以更清晰地理解转换的目的和风险。</p><p><strong>控制性</strong>:允许程序员在不同的上下文中选择合适的转换类型。提供对类型转换过程的精细控制，避免滥用强制类型转换。</p><p><strong>兼容性</strong>:保持与旧代码和C语言代码的兼容性，同时引入更现代化的类型转换机制。</p></blockquote><ul><li>类型</li></ul><ol><li><p><code>static_cast</code></p><p><code>static_cast</code>是最常用的类型转换形式，用于<strong>基本数据类型之间的转换</strong>，如整型和浮点型、指针类型之间的转换（只要它们是相关的类型），以及类层次结构中<strong>向上</strong>（子类指针或引用转换为基类指针或引用）的转换。</p></li><li><p><code>dynamic_cast</code></p><p><code>dynamic_cast</code>专门用于处理类的层次结构中的<strong>向下</strong>转换（基类指针或引用转换为派生类指针或引用），并在运行时检查类型的安全性。它要求至少有一个基类声明为虚拟的（即至少有一个虚函数）。</p></li><li><p><code>const_cast</code></p><p><code>const_cast</code>用于修改类型的<code>const</code>或<code>volatile</code>属性，比如将一个<code>const</code>指针转换为非<code>const</code>指针，允许修改所指向的数据。它不能改变非<code>const</code>对象的<code>const</code>性质，也不能改变对象的类型。</p></li><li><p><code>reinterpret_cast</code></p><p>用于进行任意类型的指针转换。通常用于底层、硬件相关或系统编程中，进行较低级别的类型转换。</p></li></ol><h4 id="new-delete-malloc-free"><a class="header-anchor" href="#new-delete-malloc-free"></a>new|delete|malloc|free</h4><ul><li>解释</li></ul><table><thead><tr><th>特性</th><th><code>new</code> / <code>delete</code></th><th><code>malloc</code> / <code>free</code></th></tr></thead><tbody><tr><td>语言支持</td><td>C++ 运算符</td><td>C 标准库函数，也可在 C++ 中使用</td></tr><tr><td>类型安全</td><td>类型安全，编译时进行类型检查</td><td>类型不安全，需要显式类型转换</td></tr><tr><td>构造函数调用</td><td><code>new</code> 分配内存并调用构造函数</td><td><code>malloc</code> 只分配内存，不调用构造函数</td></tr><tr><td>析构函数调用</td><td><code>delete</code> 调用析构函数并释放内存</td><td><code>free</code> 只释放内存，不调用析构函数</td></tr><tr><td>申请内存</td><td>无须指定内存块的大小，编译器会根据类型信息自行计算</td><td>显式地指出所需内存的大小</td></tr><tr><td>内存分配失败处理</td><td>抛出 <code>std::bad_alloc</code> 异常</td><td>返回 <code>nullptr</code></td></tr><tr><td>数组支持</td><td><code>new[]</code> 和 <code>delete[]</code> 提供数组分配和释放支持</td><td>需要手动计算大小和类型转换</td></tr><tr><td>使用语法</td><td>简洁，适用于对象和数组的分配</td><td>复杂，需要显式类型转换</td></tr><tr><td>内存对齐</td><td>自动处理内存对齐</td><td>取决于具体的实现，可能需要手动处理</td></tr><tr><td>性能和优化</td><td>通常更优化，特别是在处理复杂对象时</td><td>性能依赖于具体的标准库实现</td></tr><tr><td>运算符重载</td><td>支持运算符重载，自定义内存分配策略</td><td>不支持运算符重载</td></tr><tr><td>异常处理</td><td>提供异常处理机制</td><td>需要手动检查返回值并处理错误</td></tr><tr><td>代码示例</td><td><code>MyClass* obj = new MyClass(); delete obj; </code></td><td><code>MyClass* obj = (MyClass*)malloc(sizeof(MyClass)); free(obj); </code></td></tr><tr><td>返回类型</td><td><code>new</code>返回目标对象类型的指针</td><td><code>malloc</code>返回<code>void</code>的指针</td></tr></tbody></table><h4 id="NULL-nullptr"><a class="header-anchor" href="#NULL-nullptr"></a>NULL|nullptr</h4><ul><li>解释</li></ul><blockquote><p><strong><code>NULL</code></strong>：<code>NULL</code>通常被定义为整数<code>0</code>，或者是一个宏定义，如<code>#define NULL 0</code>或<code>#define NULL ((void*)0)</code>。它的实际类型可能因编译器而异。</p><p><strong><code>nullptr</code></strong>：<code>nullptr</code>是C++11引入的一个新的关键字，它表示一个指向任何类型的空指针。<code>nullptr</code>的类型是<code>std::nullptr_t</code>，可以隐式转换为任何指针类型。</p></blockquote><h4 id="auto-decltype"><a class="header-anchor" href="#auto-decltype"></a>auto|decltype</h4><ul><li>解释</li></ul><blockquote><p>auto 和 decltype都是类型推断关键字；</p><p><code>auto</code> 关键字用于在变量声明时根据初始化表达式自动推导变量的类型。</p><p><code>decltype</code> 关键字用于从表达式中推导出类型，它不会对表达式求值，只是获取其类型</p></blockquote><ul><li>区别</li></ul><p><code>auto</code> 会去掉引用和顶层 <code>const</code>，<code>auto</code> 必须有一个初始化表达式。</p><p><code>decltype</code> 会保留表达式的引用和 <code>const</code> 属性，<code>decltype</code> 可以用于没有初始化表达式的场合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/// auto</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>, &amp; r = i;</span><br><span class="line"><span class="keyword">auto</span> b = r; <span class="comment">// b int not const int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> c = r; <span class="comment">// c const int</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i; <span class="comment">// d const int*</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> e = &amp;i; <span class="comment">// e const int*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// decltype</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(i).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">decltype</span>((i)) k = i;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(k).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;i &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;j &lt;&lt; std::endl;<span class="comment">// j is an int, so the address of j is different from i</span></span><br><span class="line">std::cout &lt;&lt; &amp;k &lt;&lt; std::endl;<span class="comment">// k is a reference to i, so the address of k is the same as i</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="struct-class-union"><a class="header-anchor" href="#struct-class-union"></a>struct|class|union</h4><ul><li>解释</li></ul><blockquote><p><strong>struct</strong></p><p>在C中struct只能作为单纯用作数据的复合类型，结构体和函数名同名不冲突；C++中可以定义函数、访问修饰符，若结构体的名字与函数名相同，使用结构体，只能使用带struct定义。</p><p>struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，除此之外二者几乎相同，最本质的一个区别就是默认的访问控制，默认的继承访问权限。struct 是 public 的，class 是 private 的。struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的</p><p>class 可以用于定义模板参数，struct 不能用于定义模板参数</p><p><strong>class略</strong></p><p><strong>union</strong></p><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值，当某个成员被赋值后其他成员变为未定义状态。</p></blockquote><ul><li>异同</li></ul><table><thead><tr><th>union</th><th>struct</th><th>class</th></tr></thead><tbody><tr><td>定义多个成员，使用一个</td><td>定义多个成员，使用多个</td><td>定义多个成员，使用多个</td></tr><tr><td>默认public访问</td><td>默认public访问</td><td>默认private访问</td></tr><tr><td>不可以继承</td><td>可以继承</td><td>可以继承</td></tr><tr><td>不能含有虚函数</td><td>能含有虚函数</td><td>能含有虚函数</td></tr></tbody></table><h4 id="define-typedef-typename-inline"><a class="header-anchor" href="#define-typedef-typename-inline"></a>define|typedef|typename|inline</h4><ul><li>解释</li></ul><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">用途</th><th style="text-align:left">语法</th><th style="text-align:left">主要区别</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>#define</code></td><td style="text-align:left">宏定义，通常用于常量或代码片段替换</td><td style="text-align:left"><code>#define NAME value</code></td><td style="text-align:left">预处理器指令，<strong>发生在编译之前</strong>，不进行类型检查</td><td style="text-align:left"><code>#define PI 3.14</code></td></tr><tr><td style="text-align:left"><code>typedef</code></td><td style="text-align:left">为已有类型定义新的类型别名</td><td style="text-align:left"><code>typedef existing_type new_type</code></td><td style="text-align:left">在编译时创建类型别名，进行类型检查</td><td style="text-align:left"><code>typedef unsigned long ulong;</code></td></tr><tr><td style="text-align:left"><code>typename</code></td><td style="text-align:left">指示模板中的依赖类型，或表示类型名</td><td style="text-align:left">作为模板参数或用在模板内部</td><td style="text-align:left">解决依赖名称的歧义，声明模板中的类型名</td><td style="text-align:left"><code>template &lt;typename T&gt; class MyClass &#123;&#125;;</code></td></tr><tr><td style="text-align:left"><code>inline</code></td><td style="text-align:left">提示编译器内联函数，以减少函数调用开销</td><td style="text-align:left"><code>inline return_type function()</code></td><td style="text-align:left">提示编译器将函数代码直接插入调用点，减少函数调用开销</td><td style="text-align:left"><code>inline int add(int a, int b) &#123; return a + b; &#125;</code></td></tr></tbody></table><h3 id="STL-🧊"><a class="header-anchor" href="#STL-🧊"></a>STL 🧊</h3><h4 id="STL-序🍺"><a class="header-anchor" href="#STL-序🍺"></a>STL 序🍺</h4><ul><li><strong>STL的六大组件</strong></li></ul><blockquote><p><strong>容器</strong>：数据结构，容器通过迭代器暴露其元素，使得算法可以操作这些元素</p><p><strong>迭代器</strong>：访问容器的泛型指针，让用户通过特定的接口访问容器的数据，不需要了解容器内部的底层数据结构</p><p><strong>算法</strong>：数据操作方式</p><p><strong>函数对象（仿函数）</strong>：函数对象是重载了函数调用操作符（<code>()</code>）的类实例。STL中的函数对象可以用作算法的某些操作，如定义比较行为（<code>less</code>，<code>greater</code>等），定义算法作用与容器的行为。</p><p><code>sort(a.begin(), a.end(),less&lt;int&gt;());</code></p><p><strong>适配器</strong>：可以修改或扩展迭代器、容器和仿函数的行为，使其能够以新的方式被算法使用或操作。(stack\queue)</p><p><strong>空间配置器</strong>：在更底层被容器使用来管理内存分配的，但它通常对于 STL 的使用者是透明的，除非需要自定义内存管理行为。<strong>【可以作为说是STL优化策略】</strong>【堆中申请内存】</p></blockquote><p>容器以 class template 完成;<br>算法以 function templates 完成;<br>仿函数是一种将 operator() 重载的 class template;<br>迭代器是一种将 operator++ 和 operator* 等指针习惯常行为重载的 class template;<br>配接器中的 container adapter 和 iterator adapter 都是一种 class template, 而 function adapter.</p><ul><li><strong>各大容器</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">STL:</span><br><span class="line">---序列式容器: string,vector,array,deque,list,forward_list</span><br><span class="line">---容器适配器: stack,queue,priority_queue</span><br><span class="line">---关联式容器: </span><br><span class="line">------红黑树结构：map,set,multimap,multiset</span><br><span class="line">------哈希结构：unordered_map,unordered_set,unordered_multimap,unordered_multiset</span><br><span class="line"></span><br><span class="line">vector:可变大小数组</span><br><span class="line">deque:双端队列</span><br><span class="line">list:双向链表</span><br><span class="line">array:固定大小数组</span><br><span class="line">string:类似于vector但是专门保存字符</span><br><span class="line">forward_list:前向链表</span><br><span class="line"></span><br><span class="line">map:关联数组：key-value pair 有序</span><br><span class="line">set：只保存关键字的容器：key is value 有序</span><br><span class="line">mutilmap：关键字可重复出现</span><br><span class="line">mutilset：关键字可重复出现</span><br><span class="line"></span><br><span class="line">unordered_map:hash函数组织map 无序</span><br><span class="line">unordered_set:hash函数组织set 无序</span><br><span class="line">unordered_mutilmap:hash函数组织map 无序 关键字可重复出现</span><br><span class="line">unordered_mutilset:hash函数组织set 无序 关键字可重复出现</span><br></pre></td></tr></table></figure><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#array">array</a></td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#vector">vector</a></td><td>数组</td><td>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#deque">deque</a></td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#forward_list">forward_list</a></td><td>单向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#list">list</a></td><td>双向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#stack">stack</a></td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，<strong>扩容耗时</strong></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#queue">queue</a></td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，<strong>扩容耗时</strong></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue</a></td><td>vector + max-heap</td><td>插入、删除 O(log2n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#set">set</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multiset">multiset</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#map">map</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multimap">multimap</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set">unordered_set</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset">unordered_multiset</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map">unordered_map</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap">unordered_multimap</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table><ul><li><strong>迭代器</strong></li></ul><table><thead><tr><th>容器</th><th>迭代器</th></tr></thead><tbody><tr><td>vector、deque</td><td>随机访问迭代器</td></tr><tr><td>stack、queue、priority_queue</td><td>无</td></tr><tr><td>list、(multi)set/map</td><td>双向迭代器</td></tr><tr><td>unordered_(multi)set/map、forward_list</td><td>前向迭代器</td></tr></tbody></table><ul><li><strong>算法</strong></li></ul><table><thead><tr><th>算法</th><th>底层算法</th><th>时间复杂度</th><th>可不可重复</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/algorithm/find/">find</a></td><td>顺序查找</td><td>O(n)</td><td>可重复</td></tr><tr><td><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdC++-v3/include/bits/stl_algo.h#L4808">sort</a></td><td><a href="https://en.wikipedia.org/wiki/Introsort">内省排序</a></td><td>O(n*log2n)</td><td>可重复</td></tr></tbody></table><ul><li><strong>QA</strong></li></ul><ol><li>为什么空间配置其使用<strong>内存池</strong>机制实现</li></ol><p>内存池实现机制采用allocate 包装 malloc，deallocate包装free，如果将内存申请交给每个STL容器自己去申请管理，一是不安全容易内存泄漏二是频繁申请小块内存导致内存碎片，影响程序运行效率。</p><ol start="2"><li>为什么空间配置器是一级和二级的，为什么要二级空间配置器(1大1小)</li></ol><p>一级空间配置器对于大块内存非常有效，直接与内存管理机制交互减少额外开销，但是频繁分配和释放小块内存的场景，将会导致性能下降和内存碎片,所以引入二级空间配置器，底层原理是链表构成的内存</p><ol start="3"><li><strong>STL内存管理</strong></li></ol><p>STL内存管理使用二级内存配置器来优化内存分配和回收。这种机制通过减少系统调用（例如 <code>malloc</code> 和 <code>free</code>）的次数来提高性能，特别是在频繁进行小块内存操作的场景下</p><p><strong>一级内存配置器（first level allocator）</strong>：直接使用标准的内存分配和回收方法，如 <code>malloc</code> 和 <code>free</code>。当申请的内存大小超过128字节时，默认使用一级内存配置器</p><p><strong>二级内存配置器（second level allocator）</strong>：主要用于处理小块内存请求，尤其是小于128字节的请求。二级内存配置器的设计目的是减少内存碎片和提高内存分配效率。</p><blockquote><p>二级内存配置器的原理：</p><ol><li><strong>固定大小的内存块</strong>：二级内存配置器维护了一组固定大小的内存池，每个池处理特定大小的内存块（例如8字节、16字节等，一般以8字节为一个阶梯，直到128字节）。</li><li><strong>自由链表</strong>：每种大小的内存块都有一个对应的自由链表（free-list），用于存放当前可用的内存块。当程序请求内存时，配置器首先检查相应大小的自由链表，如果自由链表中有可用块，则直接返回一个块给请求者。</li><li><strong>内存池（memory pool）</strong>：如果请求的内存块大小的自由链表为空，二级配置器会从内存池中分配一大块内存，然后将其切分成所需大小的块，并将这些块加入到对应大小的自由链表中。</li><li><strong>块填充与回收</strong>：当一个内存块不再使用时，它会被放回到对应大小的自由链表中，而不是直接返回给系统。这样可以减少对系统内存管理调用的依赖，降低内存分配和回收的开销。</li></ol><p>二级内存配置器的优势：</p><ul><li><strong>减少系统调用</strong>：通过维护固定大小的内存池和自由链表，二级内存配置器减少了对系统级内存管理函数（如 <code>malloc</code> 和 <code>free</code>）的调用，这些函数通常涉及更复杂的内存管理策略和潜在的锁开销。</li><li><strong>快速响应</strong>：对于小块内存的请求，二级内存配置器可以通过简单地从自由链表中取出一个内存块来快速响应，提高了内存分配的速度。</li><li><strong>减少内存碎片</strong>：通过固定大小的内存块管理，二级内存配置器可以有效减少内存碎片。</li></ul></blockquote><ol start="4"><li><code>sort</code>为什么用内省排序</li></ol><p>因为快排在面对小数组（比如大小为10的数组）且基本有序的情况下，它的表现还没插入排序要好。因为数组的基本有序，使得插入排序不用很多次的执行元素的移动，并且可以避免递归。 在SGI STL中的函数sort使用的排序算法其实就是内省式的排序算法。快排的递归层次过深的时候，很可能会退化成O(n^2)。内省式排序使用k来控制快排的递归深度，当快排的递归深度到达k的时候选择使用heap排序。</p><h4 id="STL-Container-💡"><a class="header-anchor" href="#STL-Container-💡"></a>STL Container 💡</h4><h5 id="vector"><a class="header-anchor" href="#vector"></a>vector</h5><ul><li>解释</li></ul><p>动态增长数组，底层是类似于一个array，但是比array灵活，内部数据连续存储，是一种可以动态增长的序列容器，元素在内存连续存放，随机存取时间复杂度O(1)，尾端操作最佳性能，头部操作O(n)。</p><p>增加元素时若超过自身最大容量，则扩充自身容量2倍（不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍）扩充空间需要经过的步骤：重新配置空间，元素移动，释放旧的内存空间。一旦vector空间重新配置，则指向原来vector的所有迭代器都失效了，因为vector的地址改变了</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>数据安排及操作方式与array非常相似。两者的唯一差别在于空间运用的灵活性。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>静态空间，一旦配置好了就不能改变了，如果程序需要一个更大的array，只能自己再申请一个更大的array，然后将以前的array中的内容全部拷贝到新的array中。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">^{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>动态开辟的空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新的元素。vector的关键技术在于对大小的控制以及重新分配时的数据移动效率。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>采用的数据结构是线性的连续空间（泛型的动态类型顺序表），他以两个迭代器start和finish分别指向配置得来的连续空间中目前已将被使用的空间。迭代器end_of_storage指向整个连续的尾部。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">^{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>在增加元素时，如果超过自身最大的容量，vector则将自身的容量扩充为原来的两倍。扩充空间需要经过的步骤：<strong>重新配置空间，元素移动，释放旧的内存空间</strong>。一旦vector空间重新配置，则指向原来vector的所有迭代器都失效了，因为vector的地址改变了。</p><ul><li>QA</li></ul><ol><li><p>为什么加倍扩充，而申请固定容量？扩容为啥1.5倍或2倍？</p><p>加倍扩容将会有更多的空余空间，不然假设我们一边扩一个一边加一个将导致不停的内存拷贝复制，时间复杂度本来是O(1)将会增长为O(n)</p><p>使用k=2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好，最好把增长因子设为(1, 2)，也就是1-2之间的某个数值。1.5倍扩容能更好的利用之前的内存块，降低碎片问题。</p></li><li><p><code>push_back</code>和<code>emplace_back</code>区别</p><p>emplace_back() 和 push_back() 的主要区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;A&gt; v;</span><br><span class="line">A a;</span><br><span class="line">v.<span class="built_in">push_back</span>(a);\\ 拷贝复制到vec</span><br><span class="line">v.<span class="built_in">emplace_back</span>(); \\ 直接进入到vec</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;v[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;v[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">000000B</span>570AFFB24</span><br><span class="line"><span class="number">000002</span>A0CF71A400</span><br><span class="line"><span class="number">000002</span>A0CF71A401</span><br></pre></td></tr></table></figure></li><li><p>迭代器失效</p><p>resize、reserve、insert、assign、push_back等会引起其底层空间改变的操作，都有可能使迭代器失效</p><p>迭代器底层实际就是一个指针，或者是对指针进行了 封装，比如：vector的迭代器就是原生态指针T*。因此迭代器失效，实际就是迭代器底层对应指针所指向的 空间被销毁了，而使用一块已经被释放的空间，造成的后果是程序崩溃(即如果继续使用已经失效的迭代器， 程序可能会崩溃)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec_int = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec_int.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( i == <span class="number">5</span>)</span><br><span class="line">vec_int.<span class="built_in">erase</span>(it);</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">// Error: it is not valid iterator</span></span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec_int = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec_int.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">it = vec_int.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="comment">/// vec_int.erase(it);</span></span><br><span class="line"><span class="comment">/// it++; ///error</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 1, 2, 3, 4, 5, 7, 8, 9, 10 </span></span><br></pre></td></tr></table></figure></li><li><p>如何使用vector交换技巧释放空间</p><p>关键在于创建一个新的 <code>std::vector</code> 对象（在本例中是通过复制构造函数，但因为我们之前已经调用了 <code>clear</code>，所以它是空的），然后与原来的 <code>vec</code> 交换内容。由于新创建的 <code>vector</code> 是空的，这将有效地减少原 <code>vec</code> 的容量，释放多余的空间。在交换后，临时 <code>vector</code> 将被销毁，从而释放了原本 <code>vec</code> 占用的多余内存。</p><p>vector()使用vector的默认构造函数建立临时vector对象，再在该临时对象上调用swap成员，swap调用之后原来vector占用的空间就等于一个默认构造的对象的大小，临时对象就具有原来对象v的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 假设有一个很大的vector</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Capacity before: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 清除元素</span></span><br><span class="line">vec.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">// 请求释放内存（不保证成功）</span></span><br><span class="line">vec.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line"><span class="comment">// 保证减小容量的方法：使用交换技巧</span></span><br><span class="line">std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vec).<span class="built_in">swap</span>(vec); <span class="comment">// 创建一个临时vector并与原vector交换</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Capacity after: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩容过程</p><p>完全弃用现有的内存空间，重新申请更大的内存空间；</p><p>将旧内存空间中的数据，按原有顺序移动到新的内存空间中；</p><p>最后将旧的内存空间释放。</p></li><li><p><code>size resize reserve capacity</code>区别</p><p><code>size</code>：容器当前存储内容数量</p><p><code>resize</code>：改变容器<code>size</code></p><p><code>reserve</code>：改变<code>capacity</code></p><p><code>capacity</code>：容器最大存储内容数量</p></li><li><p>vector的元素类型可以是引用吗</p><p>vector的底层实现要求连续的对象排列，<strong>引用并非对象，没有实际地址，因此vector的元素类型不能是引用</strong></p><ol><li><strong>引用的不可重新绑定性</strong>：引用一旦被绑定到某个对象，就不能被重新绑定。容器在内部需要能够移动和复制元素，这对于引用类型来说是不可能的，因为引用类型一旦创建就绑定到某个对象，无法重新指向其他对象。</li><li><strong>引用类型的内存管理</strong>：容器在内部可能会重新分配内存并移动元素位置，这对于引用类型是不适用的。因为引用本质上是某个对象的别名，而不是独立存在的对象，因此无法被复制或移动。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&amp;&gt; v;</span><br><span class="line"><span class="comment">/// 编译报错</span></span><br></pre></td></tr></table></figure></li><li><p>正确释放vector内存</p><p><code>vec.clear()</code>：清空内容，但是不释放内存</p><p><code>vector&lt;int&gt;().swap(vec)</code>：清空内容，且释放内存，想得到一个全新的vector</p><p><code>vec.shrink_to_fit()</code>：请求容器降低其capacity和size匹配</p><p><code>vec.clear();vec.shrink_to_fit();</code>：清空内容，且释放内存</p></li></ol><h5 id="list"><a class="header-anchor" href="#list"></a>list</h5><ul><li>解释</li></ul><p>底层原理：list底层是一个<strong>双向链表</strong>（前闭后开），以结点为单位存储数据，节点地址在内存空间不一定连续，区别于vector，每次插入和删除就配置或释放一个空间。它还是一个环状双向链表，所以它只需要一个指针</p><p>双向链表允许向前向后，单向链表slist只有push_front()</p><h5 id="deque"><a class="header-anchor" href="#deque"></a>deque</h5><ul><li>解释</li></ul><p><strong>双端队列</strong>， 用空间换了时间，支持首尾（中间不能）快速增删（与vector最大差异），<strong>支持随机访问</strong>。<code>deque</code> 的内部实现通常不是一个连续的内存区域，而是由一系列固定大小的数组（称为块或段）构成，这些数组通过一些额外的中央控制结构（如索引数组）连接起来。这种设计允许 <code>deque</code> 在两端进行快速插入和删除操作，同时提供近乎随机访问的能力。</p><p><strong>优点：</strong></p><ol><li><strong>两端插入/删除操作高效</strong>：<code>std::deque</code> 允许在容器的前端和后端进行快速插入和删除操作，时间复杂度大约是 O(1)，这比 <code>std::vector</code> 的前端插入和删除效率要高得多。【这也是vector最大差异】</li><li><strong>随机访问</strong>：与 <code>std::vector</code> 类似，<code>std::deque</code> 也支持通过索引进行快速随机访问，访问时间复杂度为 O(1)</li></ol><p><strong>缺点：</strong></p><ol><li><strong>内存使用可能更高</strong>：由于 <code>std::deque</code> 的实现通常需要额外的中央控制结构来管理各个块，以及块内的间接寻址，这可能导致其比 <code>std::vector</code> 使用更多的内存。</li><li><strong>缓存利用率可能较低</strong>：虽然 <code>std::deque</code> 支持随机访问，但其元素可能分布在不连续的内存块中，这可能导致在遍历时缓存命中率低于 <code>std::vector</code>。</li><li><strong>某些操作可能较慢</strong>：虽然在两端的操作很快，但在 <code>std::deque</code> 的中间插入或删除元素仍然需要移动一部分元素，这可能比在 <code>std::vector</code> 中慢，尤其是当元素分布在多个内存块中时</li></ol><ul><li>QA</li></ul><ol><li>什么情况下用vector，什么情况下用list，什么情况下用deque</li></ol><p><strong>使用 <code>std::vector</code></strong>：当需要频繁随机访问元素或主要在尾部插入和删除元素时。</p><p><strong>使用 <code>std::list</code></strong>：当需要频繁在任意位置插入和删除元素且不需要随机访问时。</p><p><strong>使用 <code>std::deque</code></strong>：当需要在头部和尾部都进行频繁的插入和删除操作，同时也需要随机访问时。</p><ol start="2"><li><code>deque</code>的中控器</li></ol><p><code>deque</code> 的中控器是一个指针数组，每个指针指向一个固定大小的内存块（称为缓冲区），这些缓冲区存储实际的数据元素。中控器本身通常是动态分配的，可以根据需要扩展或缩小，以容纳更多的缓冲区。这种结构允许 <code>deque</code> 在两端动态增长而无需重新分配整个容器的内存，这是 <code>vector</code> 扩展时通常需要做的事情。</p><h5 id="map"><a class="header-anchor" href="#map"></a>map</h5><ul><li>解释</li></ul><blockquote><p>底层实现为一个<strong>自平衡的二叉搜索树</strong>（红黑树，红黑树的旋转操作比AVL树少，红黑树的这种宽松平衡使其在<strong>插入和删除操作中相对更高效</strong>，因为它不需要像AVL树那样频繁地进行平衡调整，但是这也意味着在最坏情况下，红黑树的查找操作可能会稍慢于AVL树，因为其<strong>树高可能稍高</strong>），意味着在对数时间复杂度内完成插入、查找和删除的操作，内部元素排列是有序的。</p></blockquote><ul><li>QA</li></ul><ol><li><p>红黑树？</p><p>RBT是二叉排序树，但是没有AVL树限制严格</p><ul><li>中所有节点非红即黑。</li><li>根节点必为黑节点。</li><li>红节点的子节点必为黑（黑节点子节点可为黑）</li><li><strong>从根到叶子的任何路径上黑结点数相同</strong></li><li>O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span></span></span></span>) 查询</li></ul></li><li><p>map插入方法有哪些？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>)); </span><br><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>)); </span><br><span class="line">mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_one&quot;</span>; </span><br></pre></td></tr></table></figure></li></ol><h5 id="set"><a class="header-anchor" href="#set"></a>set</h5><ul><li>解释</li></ul><blockquote><p>底层是一个基于红黑树实现，存储唯一的元素（不重复），按照特定的顺序进行排序的，关联容器。并且set仅存储单个值而非键值对，他的值就是键。</p></blockquote><ul><li>QA</li></ul><ol><li>为什么map和set和插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效</li></ol><p>**关于效率：**set和map是一种关联式容器，底层实现是红黑树实现的，他们的插入和删除效率高于其他容器是因为插入删除操作均是在节点进行操作，对红黑树节点的操作也只是指针操作，节点的存储内存不变。所以效率高，而vector往中间插入会涉及到对后序的内存中的元素复制再拷贝。</p><p><strong>关于迭代器失效：</strong> 在 <code>std::map</code> 和 <code>std::set</code> 中，插入和删除操作不会使指向其他元素的迭代器失效。这是因为这些操作只影响到特定的节点，并且由于红黑树的性质，树的其他部分保持有效。但需要注意，删除操作会使指向被删除元素的迭代器失效。相比之下，序列容器如 <code>std::vector</code> 在进行插入或删除操作时可能会导致所有指向插入或删除点之后元素的迭代器、指针和引用失效，因为这些操作可能涉及到元素的移动或内存重新分配</p><ol start="2"><li>map和set不能像vector一样有个reserve函数来预分配数据</li></ol><p>vector是一种序列式容器，底层实现是一个连续的内存空间，可以动态添加删除数据。而map&amp;set基于红黑树结构他们并不支持连续的内存布局，<strong>他们的底层设计和数据结构</strong>决定了它们不支持 <code>reserve</code> 功能，这是与它们存储元素和保持结构平衡方式密切相关的。</p><h5 id="stack-queue"><a class="header-anchor" href="#stack-queue"></a>stack|queue</h5><h5 id="priority-queue"><a class="header-anchor" href="#priority-queue"></a>priority_queue</h5><ul><li>解释</li></ul><blockquote><p>priority_queue其实就是heap（堆）是<strong>完全二叉树</strong></p></blockquote><p><code>std::priority_queue</code> 默认使用 <code>std::vector</code> 作为其底层容器，并使用 <code>std::less</code> 作为比较函数，这意味着最大的元素总是位于队列的前端。它<strong>不提供遍历其元素的能力</strong>，因为 <code>std::priority_queue</code> 只允许访问最顶端的元素。插入和删除操作（添加和移除队列中的元素）的时间复杂度大约是 O(log n)，这里的 n 是队列中元素的数量。</p><h5 id="unoredered-map"><a class="header-anchor" href="#unoredered-map"></a>unoredered_map</h5><ul><li>解释</li></ul><blockquote><p>底层实现是一个哈希表 ，排列顺序是无序的,把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1）</p></blockquote><h4 id="STL-Container-对比-🍹"><a class="header-anchor" href="#STL-Container-对比-🍹"></a>STL Container 对比 🍹</h4><h5 id="vector-vs-List"><a class="header-anchor" href="#vector-vs-List"></a>vector vs List</h5><p><strong>优缺点</strong></p><ul><li><code>vector</code></li></ul><p><strong>优点</strong>：</p><ol><li><strong>快速随机访问</strong>：由于 <code>vector</code> 在内存中是连续线性空间存储的，它支持通过索引快速随机访问元素，访问时间复杂度为 O(1)</li><li><strong>空间效率和缓存友好性</strong>：连续的内存布局使得 <code>vector</code> 在迭代访问时拥有较好的缓存一致性，通常可以提高遍历效率</li><li><strong>末尾插入/删除高效</strong>：在 <code>vector</code> 的末尾添加或删除元素通常非常快速，时间复杂度为 O(1)，尽管当容器需要扩容时会涉及到复制或移动所有元素，但这通过分摊复杂度依然保持了较高效率</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>中间插入/删除低效</strong>：由于需要移动插入点之后的所有元素，所以在 <code>vector</code> 中间插入或删除元素的操作效率较低，时间复杂度为 O(n)</li><li><strong>可能的内存重新分配</strong>：当超出当前容量时，需要重新分配内存并复制或移动所有元素，这可能导致较大的性能开销。【这里可以牵扯出频繁push_back导致性能影响】</li></ol><ul><li><code>list</code></li></ul><p><strong>优点</strong>：</p><ol><li><strong>中间插入/删除高效</strong>：<code>list</code> 是基于链表实现的，可以在任何位置快速插入或删除元素，只需要改变前后元素的指针即可，操作的时间复杂度为 O(1)。</li><li><strong>不需要连续内存</strong>：链表不需要一块连续的内存空间，这在某些情况下可能更加灵活和高效。</li></ol><p><strong>缺点</strong>：</p><ol><li><strong>不支持随机访问</strong>：<code>list</code> 不支持通过索引直接访问元素，访问任何一个元素都需要从头开始遍历，时间复杂度为 O(n)。</li><li><strong>内存使用更高</strong>：每个元素都需要额外的空间来存储前后元素的指针，相比于 <code>vector</code> 的紧凑存储，<code>list</code> 的内存使用效率较低。</li><li><strong>缓存利用率低</strong>：由于元素不是连续存储的，链表遍历时缓存命中率较低，可能导致较低的遍历效率。</li></ol><p><strong>vector和list增删元素对迭代器的影响</strong></p><p>对于vector而言，删除某个元素以后，该元素后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。</p><p>对于list而言，删除某个元素，只有“指向被删除元素”的那个迭代器失效，其它迭代器不受任何影响</p><ol><li>vector插入、查找、删除时间复杂度分别为：O(n)、O(1)、O(n)；</li><li>list插入、查找、删除时间复杂度分别为：O(1)、O(n)、O(1)</li></ol><h5 id="queue-vs-List-vs-deque"><a class="header-anchor" href="#queue-vs-List-vs-deque"></a>queue vs List vs deque</h5><p>queue是STL中的容器适配器，依赖底层序列容器通过一定的方法对容器的数据操作方式进行控制；List是STL中的序列容器，底层原理是双向链表实现，deque也是序列容器，双向开口的连续线性空间，但是它内部底层原理涉及到了map，因为他要将一定的内存块通过map连接起来，这样deque不但能实现双向队列基础上还能以O(1)进行随机访问（而vector不可以）</p><h5 id="map-vs-set"><a class="header-anchor" href="#map-vs-set"></a>map vs set</h5><p>map:</p><ul><li>map以RBTree作为底层容器</li><li>所有元素都是键+值存在</li><li>不允许键重复</li><li>所有元素是通过键进行自动排序的</li><li><strong>map的键是不能修改的</strong>，但是其键对应的值是可以修改的</li></ul><p>set: <strong>read-only</strong></p><ul><li><p>set以RBTree作为底层容器</p></li><li><p>所得元素的只有key没有value，value就是key</p></li><li><p>不允许出现键值重复</p></li><li><p>所有的元素都会被自动排序</p></li><li><p><strong>不能通过迭代器来改变set的值</strong>，因为set的值就是键，<strong>set的迭代器是const的</strong>【对比map】</p></li></ul><blockquote><p>Q:为啥const?</p><p>因为 <code>std::set</code> 的迭代器是常量迭代器（<code>const_iterator</code>），这意味着您不能通过迭代器直接修改元素的值。这是设计上的选择，以确保集合中的元素始终保持正确排序且不重复，所以我们对set的值修改就是删除旧值再添加。</p><p>Q:set存储对象时根据什么作为键值</p><p>A：对象值作为键值，向<code>set</code>中插入对象时，这些对象会根据它们的值被比较。例如，如果你有一个自定义对象类型，并向<code>set</code>中添加这种类型的对象，你需要确保该类型支持比较操作（如通过重载<code>&lt;</code>操作符），这样<code>set</code>才能根据对象的值来进行排序和唯一性检查</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;操作符，以便set可以根据对象的value排序</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> MyClass&amp; other) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value &lt; other.value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::set&lt;MyClass&gt; mySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向set中插入对象</span></span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="built_in">MyClass</span>(<span class="number">10</span>));</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="built_in">MyClass</span>(<span class="number">20</span>));</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="built_in">MyClass</span>(<span class="number">10</span>)); <span class="comment">// 这个插入操作不会成功，因为值10已经存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出set的大小，预期是2，因为有两个唯一的值</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Set size: &quot;</span> &lt;&lt; mySet.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="map-set-vs-multimap-multiset"><a class="header-anchor" href="#map-set-vs-multimap-multiset"></a>map|set vs multimap|multiset</h5><p>唯一区别就是：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样</p><h4 id="STL-其它QA"><a class="header-anchor" href="#STL-其它QA"></a>STL 其它QA</h4><h5 id="迭代器-it-vs-it"><a class="header-anchor" href="#迭代器-it-vs-it"></a>迭代器 ++it vs it++</h5><p><code>++it</code>（前缀递增）</p><ul><li><strong>行为</strong>：首先增加迭代器的值（即让迭代器指向下一个元素），然后返回增加后的迭代器的引用。</li><li><strong>性能</strong>：通常推荐使用前缀递增，因为它不需要创建迭代器的临时副本。在迭代器或者对象本身较大时，使用前缀递增可以避免不必要的复制，从而提高效率。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通<code>++i</code>就是这样，<code>++i</code> 首先将 <code>i</code> 的值增加+1再返回</p><p><code>it++</code>（后缀递增）</p><ul><li><strong>行为</strong>：首先创建当前迭代器的一个副本，然后增加原迭代器的值（让原迭代器指向下一个元素），最后返回副本。这意味着返回的是增加之前的迭代器的值</li><li><strong>性能</strong>：后缀递增需要创建迭代器的一个临时副本，这可能导致额外的性能开销，尤其是对于那些复制成本较高的迭代器（如某些容器的迭代器）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> temp = *<span class="keyword">this</span>; </span><br><span class="line"> ++*<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>普通<code>i++</code>就是这样，<code>i++</code> 首先返回 <code>i</code> 当前的值（增加前的值），然后再+1</p><h5 id="STL容器删除元素"><a class="header-anchor" href="#STL容器删除元素"></a>STL容器删除元素</h5><p>我们在刚才提到，我们用迭代器删除元素将会导致某些种类容器结构变化，进而导致我们后续的容器失效</p><ol><li>对于序列容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器；</li><li>对于关联容器map，set来说，使用了erase后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可；</li><li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用</li></ol><p>顺序容器用迭代器删除一个元素和关联容器用迭代器删除一个元素？</p><p>顺序容器：It = c.erase(it); 因为顺序容器删除元素将导致后续迭代器失效，所以要更新it，不能c.erase(it++)</p><p>关联容器：c.erase(it++); erase迭代器只是被删除元素的迭代器失效,所以c.erase(it++)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (*it == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">// ok, erase will return the next element&#x27;s iterator</span></span><br><span class="line"><span class="comment">// it++ is valid</span></span><br><span class="line"><span class="comment">// map is a related container, so it++ is valid</span></span><br><span class="line">s.<span class="built_in">erase</span>(it++);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (*it == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">// v.erase(it++); </span></span><br><span class="line"><span class="comment">// ERROR because it++ is invalid, vector is a series container, </span></span><br><span class="line"><span class="comment">// if erase an element, next element will be moved to the previous position, so it++ is invalid</span></span><br><span class="line"></span><br><span class="line">it = v.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="comment">// ok, erase will return the next element&#x27;s iterator</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="STL中迭代器失效"><a class="header-anchor" href="#STL中迭代器失效"></a>STL中迭代器失效</h5><ul><li>vector &amp; deque</li></ul><ol><li><p>尾部插入</p><p>插入后size&lt;capacity，首迭代器不失效尾迭代失效；size == capacity时，所有迭代器均失效</p></li><li><p>尾部以外插入</p><p>插入后size &lt; capacity，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效</p></li></ol><ul><li><p>list/map/set</p><p>仅当前迭代器失效，不会影响其他节点的迭代器, 使用**递增方法获取下一个迭代器</p></li></ul><h5 id="STL线程安全性"><a class="header-anchor" href="#STL线程安全性"></a>STL线程安全性</h5><ul><li>结论</li></ul><blockquote><p><strong>单线程访问</strong>：所有 STL 容器都是线程安全的。</p><p><strong>多线程只读访问</strong>：多个线程可以安全地同时读取同一个容器。</p><p><strong>多线程读写访问</strong>：需要使用同步机制（如互斥锁）来保护对容器的访问，以防止数据竞争。</p><p><strong>并行算法</strong>：在使用并行算法时，仍需确保容器的访问是线程安全的。</p></blockquote><ul><li>解释</li></ul><p>单线程访问：</p><p>单个线程中访问或修改 STL 容器，则没有线程安全问题</p><p>多线程只读访问：</p><p>多个线程可以同时读取同一个 STL 容器，而不需要任何额外的同步。这种情况下，容器的只读操作是线程安全的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多线程环境中只读访问</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;vec]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> val = vec[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;vec]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> val = vec[<span class="number">1</span>];</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>多线程读写访问：</p><p>如果多个线程同时对同一个 STL 容器进行写操作（插入、删除、修改），或者一个线程写而另一个线程读，则必须使用同步机制（例如互斥锁）来保证线程安全。否则，会出现数据竞争和未定义行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeToVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readFromVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> val = vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(writeToVector)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(readFromVector)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="STL容器动态链接可能产生的问题"><a class="header-anchor" href="#STL容器动态链接可能产生的问题"></a><strong>STL容器动态链接可能产生的问题</strong></h5><p>一般程序中，局部容器、参数传递容器、参数传递容器的引用以及参数传递容器的指针通常可以正常运行。然而，当涉及到动态链接库（DLL）时，给动态库函数传递容器对象本身可能会导致内存堆栈破坏的问题</p><p>主要源于以下几个方面：</p><ol><li><strong>标准库实现差异</strong>：不同的编译器和标准库实现可能有不同的内存分配和管理机制。如果主程序和动态链接库使用不同版本的标准库，容器的内存管理（如分配和释放）可能会不兼容，导致内存问题。</li><li><strong>编译器和ABI兼容性</strong>：不同编译器之间的ABI（应用二进制接口）可能不兼容，即使是相同编译器的不同版本也可能有不同的ABI。如果主程序和动态链接库使用不同的编译器或编译器版本，容器的布局和管理方式可能会不一致。</li><li><strong>内存分配器不一致</strong>：容器的内存分配器可能在主程序和动态链接库之间不一致，这会导致在一个模块中分配内存，而在另一个模块中释放内存时出现问题</li></ol><h4 id="STL源码剖析笔记-🥪"><a class="header-anchor" href="#STL源码剖析笔记-🥪"></a>STL源码剖析笔记 🥪</h4><h5 id="空间配置器"><a class="header-anchor" href="#空间配置器"></a>空间配置器</h5><p>普通：仅仅是将<code>malloc</code>和<code>delete</code>做了包装</p><p>特殊：内存配置操  作由<code>alloc::allocate()</code>负责，内存释放操作由alloc::deallocate ()负责； 对象构造操作由<code>::construcL()</code>负责，对象析构操作由<code>::destroys()</code>负责；同时需要注意的是在<code>destory</code>时还要辨别元素的数值类似是否有trivial-destructor</p><blockquote><p><strong>平凡的（Trivial）析构：</strong><br>如果类型 T 的析构函数是平凡的，<code>std::destroy</code> 和 <code>std::destroy_at</code> 可以跳过显式的析构操作，因为编译器知道没有任何需要显式处理的资源释放或其他操作。</p><p><strong>非平凡的（Non-Trivial）析构：</strong><br>如果类型 T 的析构函数是非平凡的，<code>std::destroy</code> 和 <code>std::destroy_at</code> 会显式调用析构函数，以确保正确释放资源或执行必要的清理操作。</p><p>SGI分配做法</p><p>SGI 设计了双层级分配器，第一级分配器直接使用 malloc() 和 free()，第二级分配器则视情况采用不同的策略：当分配空间超过 128bytes，便呼叫第一级分配器；当分配空间小于 128bytes，为了降低额外负担，便采用复杂的 memory pool 整理方式，而不再求助于第一级分配器。</p></blockquote><p>第一级分配器</p><p>第一级分配器直接采用从内存中取空间进行分配</p><p>第二级分配器</p><p>第二级分配器多了一些机制，避免􏰃多小额区块造成内存的碎片。当区块小于 128 bytes，则以 <strong>memory pool</strong> 管理，此法又称为二级分配（sub-allocation）：每次配置一大块内存，并维护对应之自由表（free-list）。下次若再有相同大小的内存需求，就直接从 free-lists 中分出。</p><h5 id="迭代器"><a class="header-anchor" href="#迭代器"></a>迭代器</h5><p>迭代器充当算法和容器之间的接口，是一种泛型化的指针，使得可以按顺序访问容器的各个元素，而又不会暴露该容器的内部实现</p><ul><li>迭代器相应型别 - 参数推导办法</li></ul><p>function template 的自变量推导（argument deducation）机制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Ti,<span class="keyword">class</span> Tt&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_impl</span><span class="params">(Ti iter, Tt ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Tt tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(_T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func_impl</span>(t, *t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(&amp;i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>Traits编程技巧</p><p><strong>traits解决什么问题</strong></p><p>比如我们有多种类型<code>A</code>、<code>B</code>、<code>C</code>、<code>int</code>、<code>long</code>、… 等，我们希望能够有某种方法能够处理这些不同参数类型的数值</p><p>解决方案一：函数重载，但是这个导致有新类型出现时我们就要重新实现一个函数</p><p>解决方案二：traits萃取模板类</p><p><strong><code>template</code>中<code>class</code>和<code>typename</code>区别？</strong></p><p>没有区别，但是C++ 语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字 typename 来实现；</p><blockquote><p>我们希望通知编译器一个名字表示类型时，必须使用关键字 typename，而不能使用 class</p></blockquote><p><strong>traits 使用的关键技术  - 模板特化和偏特化</strong></p><p>全特化是指我们为模板的特定类型提供一种特殊的实现。它适用于所有参数都是具体类型的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General template&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Specialized template for int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>偏特化允许我们对部分模板参数进行特化。它适用于模板参数的部分约束，剩余的模板参数仍然是泛型的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General template&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化，当第二个参数是 int 时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Partial specialization for second parameter as int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化，当参数均为pointer时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T*,U*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pointer template&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>traits核心实现</p><p>容器和算法之间通过迭代器联结在一起，那么算法是如何从迭代器类中萃取出容器元素的类型?</p><p><em>萃取</em>：提取类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">     <span class="comment">// 将迭代器 I::value_type 通过typedef 为 value_type</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后我们重新申明一个特化的版本</span></span><br><span class="line"><span class="comment">// 如果 my_iterator_traits 的实参为指针类型时，直接使用指针所指元素类型作为 value_type。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">IterT</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;IterT*&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> IterT value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(int) is called&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">double</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(double) is called&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fun(char) is called&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iter_traits</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iter_traits</span>&lt;T*&gt; &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">iter_traits&lt;vector&lt;<span class="type">int</span>&gt;::iterator&gt;::value_type b = <span class="number">1</span>;</span><br><span class="line">iter_traits&lt;vector&lt;<span class="type">int</span>&gt;::iterator*&gt;::value_type b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>迭代器相应型别</p><p>为了符合规范，任何迭代器都应该提供五个内嵌相应型别，以利于traits进行萃取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stl_iterator.h</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;_Iterator&gt;::iterator_category, <span class="comment">// 迭代器的分类</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;_Iterator&gt;::value_type, <span class="comment">//指迭代器所指对象的类型。</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;_Iterator&gt;::difference_type, <span class="comment">//表示两个迭代器之间的距离。因此，它可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;_Iterator&gt;::pointer, <span class="comment">// 能够传回一个 pointer，指向迭代器所指之物</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;_Iterator&gt;::reference <span class="comment">//C++ 的函数如果要传回左值，都是以 by reference 的方式进行。</span></span><br><span class="line"></span><br><span class="line"># _VC_</span><br><span class="line">_EXPORT_STD <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Category</span>, <span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Diff</span> = <span class="type">ptrdiff_t</span>, <span class="keyword">class</span> _Pointer = _Ty*,</span><br><span class="line">    <span class="keyword">class</span> _Reference = _Ty&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> _CXX17_DEPRECATE_ITERATOR_BASE_CLASS iterator &#123; <span class="comment">// base type for iterator classes</span></span><br><span class="line">    <span class="keyword">using</span> iterator_category = _Category;</span><br><span class="line">    <span class="keyword">using</span> value_type        = _Ty;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = _Diff;</span><br><span class="line">    <span class="keyword">using</span> pointer           = _Pointer;</span><br><span class="line">    <span class="keyword">using</span> reference         = _Reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>iterator_category</code></p><ul><li>Input Iterator：这种迭代器所指对象，不允许外界改变</li><li>Output Iterator：只能写（write only）</li><li>Forward Iterator：读写动作</li><li>Bidirectional Iterator：可双向移动</li><li>Random Access Iterator：涵盖所有算术能力</li></ul></li></ul><h5 id="序列式容器"><a class="header-anchor" href="#序列式容器"></a>序列式容器</h5><blockquote><p><em>“元素都可序(ordered),但未必有序。C++  语言本身提供了一个序列式容器array, STL另外再提供vector, list, deque,  stack, queue, priority-queue等等序列式容器。其中stack和queue由于只  是将deque改头换面而成，技术上被归类为一种配接器(adapter)”</em>- STL源码剖析</p></blockquote><h6 id="vector-v2"><a class="header-anchor" href="#vector-v2"></a>vector</h6><p><code>vector </code>是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素；</p><blockquote><p><em>“<code>push_back() </code>将新元素安插于 <code>vector </code>尾端，该函式首先检查是否还有备用空间？如果有就直接在备用空间上建构元素，并调整迭代器 finish，使 <code>vector </code>变大。如果没有备用空间了，就扩充空间；动态增加大小，并不是在原空间之后接续新空间(因为无法保证原  空间之后尚有可供配置的空间)，而是以原大小的两倍另外配置一块较大空间，然  后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间；迭代器均失效；”</em></p></blockquote><h6 id="list-v2"><a class="header-anchor" href="#list-v2"></a>list</h6><blockquote><p><em>“是一个双向循环环状链表，<code>list </code>每次插入或删除一个元素，就立即分配或释放一个元素空间，其是一个双向链表，（为什么要提供是双向链表？迭代器必须具备前移、  后移的能力，所以<code>list</code>提供的是双向的）插入操作(<code>insert</code>)和接合操作(<code>splice</code>)都不会造成原 有的<code>list</code>迭代器失效”</em></p></blockquote><p><code>list</code>默认缺省使用 Alloc 做为空间分配器，并另外定义了 <code>_Node_alloc_type</code> ，为的是更方便的以节点大小为分配单位。</p><p><code>list</code>不能使用STL算法<code>sort()</code>,必须使用自己的<code>sort() </code>member function, 因为 STL 算法<code>sort() </code>只接受 RamdonAccess iterator</p><h6 id="deque-v2"><a class="header-anchor" href="#deque-v2"></a>deque</h6><blockquote><p><em>“双向开口的连续线性空间,于<code>deque</code>允许于常数时间内对起头端进  行元素的插入或移除操作，二在于<code>deque</code>没有所谓容量（<code>capacity</code>）观念，因为  它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换  句话说，像<code>vector</code>那样“因旧空间不足而重新配置一块更大空间，然后复制元  素，再释放旧空间”这样的事情在<code>deque</code>是不会发生的。也因此，<code>deque</code>没有必  要提供所谓的空间保留 （<code>reserve</code>） 功能.”</em></p></blockquote><p><code>deque</code>实际上是分段的连续空间，但是对外营造连续的假象，它也提供Rcimdon Access lterotor，但它的迭代器并不是普通指针(区别于<code>vector</code>的迭代器)</p><p><code>deque</code>的中控器</p><blockquote><p><em>“采用一块所谓的map （注意，不是STL的map容器）作为主控.这  里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是  指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的  储存空间主体”</em></p><p><em>deque 的最初状态（无任何元素时）保有一个缓冲区，因此 clear() 完成之后回复初始状态，也一样要 保留一个缓冲区</em></p></blockquote><p>其中中控器的<code>map</code>内主要存储一个指针T** 指向存储区地址开始即 T*</p><p><code>deque</code>如何扩充缓冲区？其中<code>map</code>什么时候重新整治？</p><p><strong>扩充缓冲区</strong></p><p>当向 <code>deque</code> 中插入元素导致当前缓冲区满时，<code>deque</code> 需要扩充缓冲区。这通常通过以下步骤实现：</p><ol><li><strong>检查空间</strong>：首先检查是否有足够的缓冲区空间。如果当前缓冲区已满，需要分配一个新的缓冲区。</li><li><strong>分配新的缓冲区</strong>：分配一个新的缓冲区，并将其指针添加到映射表中。</li><li><strong>调整指针</strong>：更新指向元素的指针（Begin 和 End），以反映新的缓冲区。</li></ol><p><strong>映射表的重新整理</strong></p><p><code>deque</code> 的映射表在以下几种情况下需要重新整理：</p><ol><li><strong>映射表满了</strong>：如果映射表中的指针数组也满了，需要扩展映射表的大小。这涉及分配一个更大的映射表，并将旧映射表的内容复制到新的映射表中。</li><li><strong>指针调整</strong>：当插入或删除操作导致缓冲区在映射表中的位置发生变化时，需要调整映射表中的指针。</li><li><strong>首尾操作</strong>：当在 <code>deque</code> 的头部或尾部进行插入或删除操作时，可能会导致映射表的指针需要重新排列。</li></ol><p>为了更高效地插入元素，<code>deque</code> 通常会根据插入位置前后的元素数量来决定是从前端还是后端移动元素。这种优化策略有助于最小化元素移动的次数，从而提高性能；同样在<code>erase</code>中涉及到删除后移动，<code>deque</code>也做了决定是从前端还是后端移动元素的优化策略；</p><h6 id="stack与queue"><a class="header-anchor" href="#stack与queue"></a>stack与queue</h6><p>二者都没有迭代器，无遍历功能，缺省用<code>deque</code>作为底层容器，可用<code>list</code></p><h6 id="heap"><a class="header-anchor" href="#heap"></a>heap</h6><p>算法部分:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::sort_heap;</span><br><span class="line"><span class="keyword">using</span> std::make_heap;</span><br><span class="line"><span class="keyword">using</span> std::pop_heap;</span><br><span class="line"><span class="keyword">using</span> std::push_heap;</span><br></pre></td></tr></table></figure><p><code>priority_queue</code></p><p>缺省情况下使用<code>less</code>即<code>_Left &lt; _Right;</code></p><h5 id="关联式容器"><a class="header-anchor" href="#关联式容器"></a>关联式容器</h5><h6 id="multi-set"><a class="header-anchor" href="#multi-set"></a>multi\set</h6><h6 id="multi-map"><a class="header-anchor" href="#multi-map"></a>multi\map</h6><h5 id="算法"><a class="header-anchor" href="#算法"></a>算法</h5><p>质变算法, 诸如拷贝 (copy)、互换(swap)、替换(replace)、填写(fill)、删除(remove)、排列组合(permutation)、分割(partition)、随机重排(random shuffing)、排序(sort).<br>如果将此类算法运用于一个常数区间上, 编译器将会报错.<br>非质变算法, 诸如查找 (find)、匹配 (search)、计数 (count)、巡访 (for_each)、比较 (equal, mismatch)、寻找极值 (max, min).</p><p>所有泛型算法的前两个参数都是一对迭代器(iterators),通常称为first和  last,用以标示算法的操作区间;这个［first, last)区间的必要条件是，必须能够经由increment (累加)操作符的反复运用，从first到达last</p><p>STL中Copy算法执行的是深拷贝还是浅拷贝?</p><ul><li><strong>浅拷贝</strong>：如果对象的拷贝构造函数和赋值运算符只执行浅拷贝（即默认行为），那么 <code>std::copy</code> 也会执行浅拷贝。</li><li><strong>深拷贝</strong>：如果对象的拷贝构造函数和赋值运算符执行深拷贝，那么 <code>std::copy</code> 会执行深拷贝。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"><span class="built_in">A</span>() &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">int</span>(value)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; other) = <span class="keyword">default</span>; <span class="comment">// 默认拷贝构造函数</span></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other) = <span class="keyword">default</span>; <span class="comment">// 默认赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//A(const A&amp; other) : data(new int(*other.data)) &#123;&#125; // 深拷贝构造函数</span></span><br><span class="line">    <span class="comment">//A&amp; operator=(const A&amp; other) &#123; // 深拷贝赋值运算符</span></span><br><span class="line">    <span class="comment">//    if (this != &amp;other) &#123;</span></span><br><span class="line">    <span class="comment">//        *data = *other.data;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    return *this;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;A&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">A</span>());</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">A</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;A&gt; <span class="title">v2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; obj : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; (obj.data) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; obj : v2) &#123;</span><br><span class="line">        std::cout &lt;&lt; (obj.data) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出错 crtisvaildheappointer错误</span></span><br><span class="line"><span class="comment">// 默认的浅拷贝构造函数和赋值运算符只会拷贝指针值，因此多个对象指向同一个内存位置。这会导致以下问题</span></span><br><span class="line"><span class="comment">// 多个对象共享同一内存：所有对象共享同一个指针，修改一个对象的数据会影响所有共享该指针的对象。</span></span><br><span class="line"><span class="comment">// 重复删除同一内存：当这些对象被销毁时，析构函数会多次尝试删除同一块内存，导致运行时错误</span></span><br></pre></td></tr></table></figure><h5 id="仿函数（函数对象）"><a class="header-anchor" href="#仿函数（函数对象）"></a>仿函数（函数对象）</h5><p>它扮演一种“策略”角色，可以让STL算法有更灵活，而更加灵活的关键，在于STL仿函数的可配接性(adaptability)</p><p>函数指针毕竟不能满足STL对抽象性的要求，仿函数是类型安全的。因为仿函数是通过类定义的，所以编译器可以进行类型检查。相比于函数指针，仿函数在模板中更容易使用，并且在编译时就可以捕获潜在的类型错误。</p><h5 id="配接器"><a class="header-anchor" href="#配接器"></a>配接器</h5><p>实际上是一种设计模式</p><blockquote><p>仿函数适配器：这些配接 操作包括系结(bind)、否定(negate),组合(compose)、以及对一般函数或成员函数的修饰（使其成为一个仿函数）通过它们之间的绑定、组合、修饰能力，几乎  可以无限制地创造出各种可能的表达式；</p><p>容器适配器：栈、队列</p></blockquote><h3 id="底层进阶-🍉"><a class="header-anchor" href="#底层进阶-🍉"></a>底层进阶 🍉</h3><h4 id="面向对象和面向过程的区别"><a class="header-anchor" href="#面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p>面向对象编程（OOP）和 面向过程编程（POP）是两种不同的编程范式</p><table><thead><tr><th></th><th>OOP</th><th>POP</th></tr></thead><tbody><tr><td>概念</td><td>将问题分解成一系列步骤或称之为过程的操作序列。编程的焦点是在执行具体任务的过程和函数</td><td>将问题分解成一组相互作用的对象，每个对象代表现实世界中的实体或概念。编程的焦点是对象及其交互</td></tr><tr><td>单位</td><td>函数</td><td>类和对象</td></tr><tr><td>适用场景</td><td>较小、单一任务或脚本，尤其是简单的、逻辑线性的任务</td><td>大型的、复杂的系统，特别是需要多次迭代和维护的项目</td></tr><tr><td>实现抽象</td><td>抽象通常限于函数</td><td>支持较高级别的抽象，如类抽象和多态</td></tr></tbody></table><h4 id="C-与-C-区别"><a class="header-anchor" href="#C-与-C-区别"></a>C++ 与 C 区别</h4><ol><li>面向对象支持：C++是一种面向对象的编程语言，支持类、继承、多态等面向对象的特性。而C语言则是一种面向过程的编程语言，没有直接支持面向对象的特性。</li><li>扩展性和封装性：由于支持面向对象编程范式，C++提供了更丰富的特性和功能，可以实现数据与方法的封装，并支持继承和多态等机制。这使得代码可重用性更强、模块化更好，并能够构建大型复杂软件系统。相比之下，C语言相对简单，更适合于较小规模的项目或者需要对硬件进行底层操作的场景。</li><li>标准库差异：C标准库主要提供了基本输入输出、字符串处理等功能函数。而C++标准库除了包含了所有C标准库函数外，还添加了对面向对象特性（如容器、算法）的支持。</li><li>异常处理机制：C++引入了异常处理机制，在程序出现错误时可以抛出异常并在适当位置进行捕获和处理。而C语言没有内置的异常处理机制，错误通常通过返回特定值或使用全局变量来处理。</li><li>编译器支持：C++编译器一般也可以编译C代码，因为C++是在C的基础上发展起来的。但是C编译器不一定能够完全支持C++语法和特性。</li></ol><h4 id="C-与-C-区别-v2"><a class="header-anchor" href="#C-与-C-区别-v2"></a>C++ 与 C# 区别</h4><p><strong>C#</strong></p><ul><li>C#通常运行在托管环境中，例如.NET Framework或.NET Core。它依赖于CLR（Common Language Runtime）来执行代码，并使用CIL（Common Intermediate Language）作为中间语言</li><li>C#具有自动垃圾回收机制，开发人员不需要手动释放内存。CLR会周期性地检查不再使用的对象，并自动释放它们所占用的内存</li><li>C#通过.NET Core实现了跨平台支持</li></ul><p><strong>C++</strong></p><ul><li>C++可以编译为本地机器代码，不依赖于特定的运行时环境</li><li>C++需要手动管理内存，开发人员需要显式地分配和释放内存，避免内存泄漏和野指针等问题</li><li>C++本身是跨平台的，可以通过适当的编译器和工具链在各种平台上进行开发和运行</li></ul><h4 id="C-命名空间的作用"><a class="header-anchor" href="#C-命名空间的作用"></a>C++ 命名空间的作用</h4><p>命名空间是一种包含一组标识符（如变量名、函数名、类名等）的抽象概念，用于组织代码中的名称，以避免命名冲突、更好的组织代码、提高代码可读性和可维护性、控制作用域</p><h4 id="C-内存分配情况"><a class="header-anchor" href="#C-内存分配情况"></a>C++ 内存分配情况</h4><ul><li>图示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|Text| low address //代码区（文本段）</span><br><span class="line">|---------------|</span><br><span class="line">|data|// 这里又分为全局数据区和常量区</span><br><span class="line">|segment|</span><br><span class="line">|---------------|</span><br><span class="line">|HEAP|// new delete 作用区域 向高地址增长</span><br><span class="line">|---------------|</span><br><span class="line">| 空闲 | // 不等价于heap</span><br><span class="line">| 内存 |</span><br><span class="line">|---------------|</span><br><span class="line">|stack| high address // 由高向低地址增长</span><br></pre></td></tr></table></figure><p><strong>代码段</strong>：它包含可执行指令（机器代码），代码段通常是只读，即<strong>程序代码区</strong></p><p><strong>数据段</strong>：数据段分为两部分：</p><p>​<strong>初始化数据段</strong>：所有全局、静态static和常量数据都存储在数据段中，即**静态存储区 **.data</p><p>​<strong>未初始化数据段</strong>：所有未初始化的全局变量和静态变量都存储在该段中，也称为<strong>BSS段</strong>.bss</p><p><strong>堆段</strong>：当程序在运行时使用calloc和malloc函数分配内存时，内存在堆中分配，向高地址增长<br><strong>栈段</strong>：栈用于存储局部变量、函数参数和其他与函数相关的信息，向低地址增长</p><ul><li>堆栈区别</li></ul><table><thead><tr><th></th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td><strong>管理方式</strong></td><td>堆中资源由程序员控制（容易产生memory leak）</td><td>栈资源由编译器自动管理，无需手工控制</td></tr><tr><td><strong>内存管理机制</strong></td><td>系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序</td><td>只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出</td></tr><tr><td><strong>空间大小</strong></td><td>堆是不连续的内存区域</td><td>栈是一块连续的内存区域</td></tr><tr><td><strong>碎片问题</strong></td><td>对于堆，频繁的new/delete会造成大量碎片，使程序效率降低</td><td>对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片</td></tr><tr><td><strong>生长方向</strong></td><td>向高地址方向增长。</td><td>向低地址方向增长</td></tr><tr><td><strong>分配方式</strong></td><td>堆都是动态分配</td><td>栈有静态分配和动态分配，静态分配由编译器完成，但栈的动态分配的资源由编译器进行释放</td></tr><tr><td><strong>分配效率</strong></td><td>堆由C/C++函数库提供，效率低</td><td>栈是其系统提供的数据结构，<strong>计算机在底层对栈提供支持，效率高</strong></td></tr></tbody></table><p>Global objects的内存保证会在程序启动的时候被清为0。Local objects配置于程序的堆栈中，heap objects配置于自由空间中，都不一定会被清为0，它们的内容将是内存上次被使用后的遗迹。</p><h4 id="如何检测内存泄漏"><a class="header-anchor" href="#如何检测内存泄漏"></a>如何检测内存泄漏</h4><p>Windows上除了使用VS自带的性能检测窗口观察内存分配，还可以使用以下函数，调试时输出窗口会输出内存泄漏的消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTDBG_MAP_ALLOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">_CrtDumpMemoryLeaks();</span><br></pre></td></tr></table></figure><h4 id="编译过程"><a class="header-anchor" href="#编译过程"></a>编译过程</h4><p>**预处理阶段：**在这个阶段，预处理器处理源文件中的预处理指令，比如 <code>#include</code>、<code>#define</code> 等。预处理器会根据这些指令展开头文件并替换宏定义，生成一个经过预处理的源文件.ii</p><p>**编译阶段：**编译器将预处理后的源文件转换成汇编代码。在这个阶段，编译器会对源文件进行词法分析、语法分析和语义分析，<strong>并生成相应的中间代码或汇编代码 .s</strong></p><p><strong>汇编阶段：<strong>汇编器将汇编代码转换成机器码或者目标文件。在这个阶段，汇编器会将汇编代码转换成</strong>可重定位的机器码，并生成目标文件 .o</strong></p><p><strong>链接阶段：<strong>链接器将</strong>目标文件和库文件链接</strong>在一起，生成最终的可执行文件。在这个阶段，链接器会解析目标文件之间的引用关系，将它们连接到正确的位置上，<strong>并将库文件中的函数和变量链接到可执行文件中</strong>，.out</p><h4 id="静态与动态"><a class="header-anchor" href="#静态与动态"></a>静态与动态</h4><ul><li>链接</li></ul><p><strong>静态链接：</strong></p><p>在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件</p><p>优点：可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快</p><p>缺点：导致内存中副本代码过多，源库代码修改了，链接过该库的程序要重新进行编译链接</p><p><strong>动态链接：</strong></p><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形 成一个完整的程序</p><p>优点：多个程序在执行时共享同一份副本,更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍</p><p>缺点:为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损 失</p><ul><li>类型</li></ul><p>静态类型：编译期间绑定，静态类型的语言要求在编译时确定所有变量的类型</p><p>动态类型：运行期决定，动态类型的语言允许变量在运行时改变其类型</p><ul><li>绑定</li></ul><p>绑定(Binding)：指将<strong>变量</strong>和<strong>函数名</strong>转换为地址的过程</p><p>静态绑定：绑定的是静态类型，将<strong>函数和对应的属性</strong>依赖绑定到相应的对象的静态类型。指的是对象的方法调用在编译时就已经解析，编译器知道具体调用哪个方法</p><p>动态绑定：绑定的是动态类型，将<strong>函数和对应的属性</strong>依赖绑定到相应的对象的动态类型（例如虚函数）。指的是方法调用的目标在运行时才确定</p><ul><li>断言</li></ul><p>静态断言（Static Assertion）：</p><p>静态断言是在编译时进行的，即在代码被编译之前就会执行。</p><p>使用静态断言可以对编译期间已知的条件进行检查。</p><p>静态断言使用静态表达式来定义条件，并且如果条件为假，则会导致编译错误。</p><p>静态断言通常用于验证编译期常量、类型属性或其他与类型相关的约束。</p><p>动态断言（Dynamic Assertion）：</p><p>动态断言是在运行时进行的，即在程序执行过程中才会执行。</p><p>使用动态断言可以对运行时条件进行检查。</p><p>动态断言使用 assert() 宏来定义条件，并且如果条件为假，则会触发一个运行时错误，并终止程序执行。</p><p>动态断言通常用于验证假设、调试程序或捕获意外情况。</p><ul><li>多态（怎么理解多态）</li></ul><ol><li><strong>编译时多态</strong>：也称为<strong>静态多态</strong>，主要通过方法重载和运算符重载实现。在编译时，编译器就决定了应该使用哪个函数，基于函数签名（如参数类型和数量）来进行区分。</li><li><strong>运行时多态</strong>：也称为<strong>动态多态</strong>，主要依赖于继承和接口实现。在运行时，系统根据对象的实际类型来决定调用哪个实现，这种决定通常依赖于虚函数。</li></ol><h4 id="虚函数"><a class="header-anchor" href="#虚函数"></a>虚函数</h4><h5 id="简介"><a class="header-anchor" href="#简介"></a>简介</h5><ol><li><strong>虚函数（Virtual Functions）</strong></li></ol><ul><li><p><strong>定义与目的</strong>：通过在函数声明前添加<code>virtual</code>关键字来定义虚函数。虚函数允许派生类重写（override）基类中的成员函数，<strong>实现运行时多态</strong></p></li><li><p><strong>运行时多态</strong>：虚函数的调用是在运行时决定的，而非编译时。这意味着当通过基类指针或引用调用一个虚函数时，将执行对象实际类型的函数版本</p><p>*<strong>编译时多态</strong>：函数重载或者模板【问模板的原理？】</p></li><li><p>**存储在内存的什么区：**存储在代码段，而非静态区</p></li></ul><ol start="2"><li><strong>纯虚函数（Pure Virtual Functions）</strong></li></ol><ul><li><strong>定义</strong>：纯虚函数是一种没有实现的虚函数，通过在函数声明的结尾处添加<code>= 0</code>来指定</li><li><strong>抽象基类</strong>：包含至少一个纯虚函数的类称为抽象基类。抽象基类不能实例化对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 实现基类中的纯虚函数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Derived show function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>虚析构函数（Virtual Destructors）</strong></li></ol><ul><li><strong>目的</strong>：确保通过基类指针删除派生类对象时能够调用正确的析构函数，从而避免资源泄漏</li><li><strong>实现</strong>：将基类的析构函数声明为虚函数</li></ul><ol start="4"><li><strong>虚继承（Virtual Inheritance）</strong></li></ol><ul><li><strong>解决问题</strong>：用于解决多重继承中的菱形继承问题（钻石问题），避免基类被多次继承导致的成员重复</li><li><strong>实现</strong>：通过在继承时使用<code>virtual</code>关键字（如<code>class Derived : virtual public Base</code>）来声明虚继承</li></ul><h5 id="vptr-vtable"><a class="header-anchor" href="#vptr-vtable"></a>vptr &amp; vtable</h5><p>vptr和vtable是实现C++的多态特征的底层机制</p><ul><li><p>虚指针 vptr</p><p><strong>定义</strong>：虚指针是一个指针，每个使用虚函数的对象都会持有一个指向相应虚表的虚指针。</p><p><strong>作用</strong>：虚指针使得对象能够在运行时通过虚表找到正确的虚函数实现。当对象的虚函数被调用时，编译器通过对象的虚指针访问虚表，从而找到对应的函数实现进行调用。<strong>在构造函数执行时会对虚表指针进行初始化</strong></p></li><li><p>虚表 vtable</p><p><strong>定义</strong>：虚表是一个包含指向类的虚函数地址的数组。<strong>每个</strong>有虚函数的类或包含虚函数的类的派生类都有一个为它生成的虚表，这个表是一个函数指针数组，每个元素指向一个虚函数的实现。如果类中有虚函数，每个对象实例会包含一个指向其类虚函数表的指针（通常在对象内存布局的开始位置）。</p><p><strong>作用</strong>：当调用对象的虚函数时，编译器会使用虚表来决定需要调用的实际函数。这允许在运行时进行函数的动态绑定，是实现多态的关键。</p></li><li><p>工作原理</p><p><strong>初始化</strong>：当一个对象被创建时，编译器会自动在对象的内存布局中添加一个虚指针（vptr），并将其初始化为指向该类的虚表</p><blockquote><p>在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</p><p>即导致一种情况：覆盖</p><p>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</p></blockquote><p><strong>继承与多态</strong>：如果一个类被继承，派生类会有它自己的虚表（如果它覆盖了基类的虚函数或添加了新的虚函数）。当通过基类指针或引用调用虚函数时，运行时会查找对象实际类型的虚表，从而调用正确的函数实现</p><p>继承中的虚函数表</p><ol><li><strong>无新虚函数，无覆盖</strong>：<ul><li>如果派生类没有引入新的虚函数，也没有重写基类的任何虚函数，则派生类可以直接使用基类的虚函数表。</li></ul></li><li><strong>覆盖基类虚函数</strong>：<ul><li>如果派生类重写（覆盖）了基类的虚函数，派生类的虚函数表将包含指向新实现的指针，替换掉原有函数的位置。这保证了通过基类指针调用虚函数时，能够执行到派生类中的覆盖版本。</li></ul></li><li><strong>引入新的虚函数</strong>：<ul><li>如果派生类引入了新的虚函数，这些新函数会被添加到虚函数表的末尾。派生类的虚函数表首先包含指向从基类继承的所有虚函数（包括被覆盖的和未被覆盖的）的指针，随后是新增虚函数的指针。</li></ul></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;::sum()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="type">void</span>* objPtr = &amp;a; <span class="comment">// 获取对象实例的地址</span></span><br><span class="line"><span class="comment">// 根据C++对象模型，对象的第一个成员是指向虚表的指针</span></span><br><span class="line"><span class="type">void</span>** vTablePtr = *(<span class="type">void</span>***)objPtr;</span><br><span class="line"><span class="comment">// 获取虚表中第一个函数的地址</span></span><br><span class="line"><span class="built_in">void</span> (*funcPtra)(A*, <span class="type">int</span>, <span class="type">int</span>) = (<span class="built_in">void</span> (*)(A*, <span class="type">int</span>, <span class="type">int</span>))vTablePtr[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 调用这个函数，传递参数</span></span><br><span class="line"><span class="built_in">funcPtra</span>(&amp;a, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">objPtr = &amp;b;</span><br><span class="line">vTablePtr = *(<span class="type">void</span>***)objPtr;</span><br><span class="line"><span class="built_in">void</span> (*funcPtrb)(B*, <span class="type">int</span>, <span class="type">int</span>) = (<span class="built_in">void</span> (*)(B*, <span class="type">int</span>, <span class="type">int</span>))vTablePtr[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">funcPtrb</span>(&amp;b, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">B another_b;</span><br><span class="line">objPtr = &amp;another_b;</span><br><span class="line">vTablePtr = *(<span class="type">void</span>***)objPtr;</span><br><span class="line"><span class="built_in">void</span> (*funcPtrAnotherB)(B*, <span class="type">int</span>, <span class="type">int</span>) = (<span class="built_in">void</span> (*)(B*, <span class="type">int</span>, <span class="type">int</span>))vTablePtr[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">funcPtrAnotherB</span>(&amp;another_b, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A sum address&quot;</span> &lt;&lt; funcPtra &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B sum address&quot;</span> &lt;&lt; funcPtrb &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Another B sum address&quot;</span> &lt;&lt; funcPtrAnotherB &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;A vtable address: &quot;</span>&lt;&lt;*(<span class="type">void</span>***)&amp;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;B vtable address: &quot;</span>&lt;&lt;*(<span class="type">void</span>***)&amp;b&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Another B vtable address: &quot;</span>&lt;&lt;*(<span class="type">void</span>***)&amp;another_b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="built_in">sum</span>()</span><br><span class="line"><span class="number">8</span></span><br><span class="line">::<span class="built_in">sum</span>()</span><br><span class="line"><span class="number">8</span></span><br><span class="line">::<span class="built_in">sum</span>()</span><br><span class="line"><span class="number">8</span></span><br><span class="line">A sum address00007FF754421555</span><br><span class="line">B sum address00007FF754421555</span><br><span class="line">Another B sum address00007FF754421555</span><br><span class="line"></span><br><span class="line">A vtable address: <span class="number">00007F</span>F75442BC18</span><br><span class="line">B vtable address: <span class="number">00007F</span>F75442BC38</span><br><span class="line">Another B vtable address: <span class="number">00007F</span>F75442BC38</span><br></pre></td></tr></table></figure><blockquote><p><code>objPtr</code>：这是指向对象的指针。我们假设这是一个指向类实例的指针</p><p><code>(void***)objPtr</code>：这里发生了类型转换。我们首先将<code>objPtr</code>转换为<code>void***</code>。在C++中，<code>void*</code>是一个通用指针类型，可以指向任何类型的数据。这里的<code>void***</code>表示一个指向指针的指针的指针，这里具体指的是指向虚表指针的指针</p><p><code>*(void***)objPtr</code>：通过解引用操作（*），我们得到了对象的第一个成员，即虚表指针。在大多数情况下，虚表指针是对象布局中的第一个成员</p><p><code>void** vTablePtr</code>：最后，我们得到了虚表指针，并将其存储在<code>vTablePtr</code>中。<code>void**</code>表示指向指针的指针，这里具体指的是指向虚表的指针</p></blockquote><ul><li>QA</li></ul><ol><li>为什么此时B继承了A输出的函数地址是一样的呢?</li></ol><p>当<code>B</code>继承自<code>A</code>且没有覆盖<code>A</code>中的虚函数<code>sum</code>时，<code>B</code>的虚表会复用<code>A</code>中相应的虚函数入口。这就意味着，即便是<code>B</code>的实例，其虚表中指向<code>sum</code>函数的指针也会是指向<code>A::sum</code>的。这是因为<code>B</code>没有提供一个自己的<code>sum</code>实现来“覆盖”或者说“重写”基类<code>A</code>中的那个，所以继承了<code>A</code>的实现。</p><p>C++的虚表（vtable）机制是用于支持运行时多态的。每个包含虚函数的类都有一个虚表，虚表中存储了指向类的虚函数的指针。当类<code>B</code>继承自类<code>A</code>而不覆盖（重写）其虚函数时，<code>B</code>的虚表会包含指向<code>A</code>的虚函数实现的指针，因此你会看到相同的函数地址。</p><p>这个机制确保了，即使通过基类的指针或引用调用虚函数，也总是会执行到对象实际类型的那个版本，从而实现多态。由于<code>B</code>并没有提供一个新的<code>sum</code>实现，所以它就继承了<code>A</code>的实现，包括使用相同的函数地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A::sum()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="comment">// 添加 override</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;B::sum()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="type">void</span>* objPtr = &amp;a; <span class="comment">// 获取对象实例的地址</span></span><br><span class="line"><span class="comment">// 根据C++对象模型，对象的第一个成员是指向虚表的指针</span></span><br><span class="line"><span class="type">void</span>** vTablePtr = *(<span class="type">void</span>***)objPtr;</span><br><span class="line"><span class="comment">// 获取虚表中第一个函数的地址</span></span><br><span class="line"><span class="built_in">void</span> (*funcPtra)(A*, <span class="type">int</span>, <span class="type">int</span>) = (<span class="built_in">void</span> (*)(A*, <span class="type">int</span>, <span class="type">int</span>))vTablePtr[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 调用这个函数，传递参数</span></span><br><span class="line"><span class="built_in">funcPtra</span>(&amp;a, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">objPtr = &amp;b;</span><br><span class="line">vTablePtr = *(<span class="type">void</span>***)objPtr;</span><br><span class="line"><span class="built_in">void</span> (*funcPtrb)(B*, <span class="type">int</span>, <span class="type">int</span>) = (<span class="built_in">void</span> (*)(B*, <span class="type">int</span>, <span class="type">int</span>))vTablePtr[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">funcPtrb</span>(&amp;b, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">B another_b;</span><br><span class="line">objPtr = &amp;another_b;</span><br><span class="line">vTablePtr = *(<span class="type">void</span>***)objPtr;</span><br><span class="line"><span class="built_in">void</span> (*funcPtrAnotherB)(B*, <span class="type">int</span>, <span class="type">int</span>) = (<span class="built_in">void</span> (*)(B*, <span class="type">int</span>, <span class="type">int</span>))vTablePtr[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">funcPtrAnotherB</span>(&amp;another_b, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A sum address&quot;</span> &lt;&lt; funcPtra &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B sum address&quot;</span> &lt;&lt; funcPtrb &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Another B sum address&quot;</span> &lt;&lt; funcPtrAnotherB &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;A vtable address: &quot;</span>&lt;&lt;*(<span class="type">void</span>***)&amp;a&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;B vtable address: &quot;</span>&lt;&lt;*(<span class="type">void</span>***)&amp;b&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Another B vtable address: &quot;</span>&lt;&lt;*(<span class="type">void</span>***)&amp;another_b&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">sum</span>()</span><br><span class="line"><span class="number">8</span></span><br><span class="line">B::<span class="built_in">sum</span>()</span><br><span class="line"><span class="number">8</span></span><br><span class="line">B::<span class="built_in">sum</span>()</span><br><span class="line"><span class="number">8</span></span><br><span class="line">A sum address00007FF6CC381555</span><br><span class="line">B sum address00007FF6CC38155F</span><br><span class="line">Another B sum address00007FF6CC38155F</span><br><span class="line">A vtable address: <span class="number">00007F</span>F6CC38BC18</span><br><span class="line">B vtable address: <span class="number">00007F</span>F6CC38BC38</span><br><span class="line">Another B vtable address: <span class="number">00007F</span>F6CC38BC38</span><br></pre></td></tr></table></figure><ol start="2"><li>1和2对sum函数修改都有相同效果，所以二者相同吗？</li></ol><p>当派生类提供一个与基类虚函数签名完全相同的成员函数时**，不论是否显式地使用<code>virtual</code>关键字，该成员函数都会被视为覆盖了基类的虚函数**，实现多态行为</p><p><strong>使用<code>virtual</code>关键字</strong>：在派生类中重写基类的虚函数时，即使不用<code>virtual</code>关键字，函数依然是虚的，并且覆盖了基类的虚函数。但在早期的C++代码中，显式地使用<code>virtual</code>可以增加代码的可读性，表明这个函数是虚函数，意图是覆盖基类的虚函数</p><p><strong>使用<code>override</code>关键字</strong>：C++11引入了<code>override</code>关键字，其目的是明确指示编译器这个函数是用来覆盖基类中的一个虚函数的。如果标记了<code>override</code>但没有实际覆盖任何基类中的虚函数（比如因为函数签名不匹配），编译器会报错。这个机制提供了一个额外的安全检查，有助于捕获潜在的错误。因此，使用<code>override</code>可以增强代码的健壮性和可维护性</p><ol start="3"><li>Vptr和Vtable是什么时候创建</li></ol><p><strong>虚表是在编译阶段为每个含有虚函数的类生成的，而虚指针在类的对象实例化过程中，具体是在构造函数执行过程中初始化，并指向相应的虚表</strong></p><p>虚表和虚指针创建和初始化的过程，涉及到类的实例化：</p><p>**编译阶段：**编译器在编译阶段识别出哪些类含有虚函数，并为这些类生成虚表。虚表中存储了虚函数的地址。如果类有继承，并且子类覆盖了基类的虚函数，子类的虚表中会用子类函数的地址替换相应的基类函数地址。<br>**构造函数执行阶段：**当创建一个类的对象时，该对象的构造函数会被调用。在构造函数的执行过程中，对象的虚指针（vptr）被初始化，指向其对应类的虚表。如果有继承关系，每个构造函数（从基类到派生类）在其执行过程中都可能更新vptr以指向正确的虚表，以反映当前构造阶段对象的动态类型。<br>**构造函数完成后：**一旦对象的构造函数（包括所有基类和派生类的构造函数，如果有继承的话）执行完成，对象的vptr将最终指向最派生类的虚表。此时，对象已经完全构建好，可以正常使用虚函数了。</p><blockquote><p>虚指针 (vptr)</p><ul><li><strong>创建和初始化时机</strong>：每个含有虚函数的类的对象都会有一个虚指针。这个虚指针是在对象创建时自动被编译器添加到对象中的。对于类的每个实例，虚指针在对象的构造函数中被初始化。</li><li><strong>指向</strong>：虚指针指向相应的虚表。</li></ul><p>所以我们说只有在vptr完成初始化后才能访问到虚表</p><p>虚表 (vtable)</p><ul><li><strong>创建时机</strong>：虚表是在编译时期创建的。对于每一个含有虚函数的类，编译器会生成一个虚表。虚表是类的一个静态属性，因此对于该类的所有实例来说，<strong>虚表是共享的</strong>。</li><li><strong>初始化时机</strong>：虚表在编译期间就已经被初始化了。编译器会将类中所有的虚函数地址填入虚表中。这意味着，当程序编译完成后，每个含有虚函数的类对应的虚表中已经填充了所有虚函数的地址。</li><li><strong>填入虚函数地址</strong>：虚函数的地址是在编译器编译时期填入虚表的。<strong>这个过程发生在程序编译阶段，而不是运行时或者类的初始化时期</strong></li></ul></blockquote><ol start="4"><li>vtable和vptr和类和实例</li></ol><p>我们上面的实验可以看出，对于同一个类的所有实例，它们共享同一个虚表（vtable）。虚表是每个类的一份，而不是每个对象一份。虚表中包含了该类的所有虚函数地址。每个对象有自己的虚指针（vptr），这个虚指针指向它们共同的虚表。这意味着，如果你输出同一个类的两个不同实例的虚指针值，这两个值是相同的，因为它们都指向同一个虚表。</p><ol><li><strong>节省内存</strong>：如果每个对象都有自己的虚表，将会非常占用内存。共享虚表可以大大减少内存使用。</li><li><strong>提高效率</strong>：因为虚表是共享的，所以在对象间调用虚函数时不需要额外的查找或是切换虚表，可以直接通过虚指针访问到虚表，然后调用相应的函数。</li><li><strong>支持多态</strong>：通过虚指针和虚表的机制，C++实现了运行时多态。即使在基类指针或引用指向派生类对象时，也能通过虚指针找到正确的虚表，进而调用正确版本的虚函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有覆写版本</span></span><br><span class="line">A sum address00007FF754421555</span><br><span class="line">B sum address00007FF754421555</span><br><span class="line">Another B sum address00007FF754421555</span><br><span class="line"></span><br><span class="line">A vtable address: <span class="number">00007F</span>F75442BC18</span><br><span class="line">B vtable address: <span class="number">00007F</span>F75442BC38</span><br><span class="line">Another B vtable address: <span class="number">00007F</span>F75442BC38</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被覆写的版本</span></span><br><span class="line">A sum address00007FF6CC381555</span><br><span class="line">B sum address00007FF6CC38155F</span><br><span class="line">Another B sum address00007FF6CC38155F</span><br><span class="line"></span><br><span class="line">A vtable address: <span class="number">00007F</span>F6CC38BC18</span><br><span class="line">B vtable address: <span class="number">00007F</span>F6CC38BC38</span><br><span class="line">Another B vtable address: <span class="number">00007F</span>F6CC38BC38</span><br></pre></td></tr></table></figure><h5 id="可否虚问题"><a class="header-anchor" href="#可否虚问题"></a>可否虚问题</h5><ul><li><p>静态函数可以声明为虚函数吗</p><blockquote><p>不可以，静态函数不是对象的实际成员，无法和实例进行绑定</p></blockquote></li><li><p>构造函数可以为虚函数吗</p><p><strong>不可以，虚函数表和虚指针是在对象被创建完成后才进行初始化</strong>的。在对象的构造函数执行之前，对象的内存空间已经分配，但<strong>虚指针尚未初始化</strong>。因此，在构造函数中无法使用虚函数表和虚指针来实现动态绑定</p><blockquote><p>当一个虚函数被调用时,它通过虚表(vtable)来解析，而虚函数的调用需要我们通过虚指针去查询虚表进行访问，但此时我们的虚指针的构造是跟随着对象构造函数一起走的，既然我们的虚指针还未初始化那我们访问虚表的行为可能就是未知的，得不到相应调用。此时就会导致一个悖论:</p><p><strong>解释1：虚指针还未还没有初始化,对象未完成构造,编译器就需要使用它来调用构造函数</strong>;</p><p><strong>解释2：虚函数是在运行时动态确定其类型的。在构造一个对象时对象还未创建成功，编译器无法知道对象的实际类型，无法进行调用</strong></p><p><em>'鸡和蛋相互依赖:鸡来自蛋,而蛋又是由鸡生的。这导致了一个看似无法解决的循环因果关系,同样,在构造函数和虚函数的情况下,也存在一种循环依赖:</em></p><ol><li><em>为了调用虚函数,对象需要通过vptr访问其虚表。</em></li><li><em>但是,访问虚表我们需要一个已经初始化好了的vptr才行，而虚指针是在构造函数执行期间初始化的,对象完成构造后才能得到虚指针</em></li><li><em>如果构造函数本身是一个虚函数,那么在调用构造函数之前,就需要访问尚未初始化的虚指针进而访问虚表，很明显这有问题。</em></li></ol><p><em>这就产生了一个类似于&quot;先有鸡还是先有蛋&quot;的悖论:为了调用构造函数(虚函数),需要虚指针访问虚表;但为了初始化虚指针,需要先调用构造函数’</em></p></blockquote><p>对象的虚指针（指向虚表的指针）设置通常是在<strong>构造函数开始执行的早期阶段进行</strong>的，这是为了确保即使在<strong>构造过程中，对象的虚函数也能正确解析到当前构造阶段对应类的实现</strong>。这意味着，虚指针和虚表的设置发生在对象的构造过程中，而不是在构造函数完成后【是逐步逐步完成的】。</p><blockquote><p>假设有三个类，<code>Base</code>，<code>Derived1</code>继承自<code>Base</code>，以及<code>Derived2</code>继承自<code>Derived1</code>。每个类都有其虚函数和相应的虚表。</p><p>构造<code>Derived2</code>对象时的过程：</p><ul><li>当<code>Derived2</code>的构造函数被调用时，它首先会调用<code>Derived1</code>的构造函数。</li><li>在<code>Derived1</code>的构造函数执行之前，<code>Base</code>的构造函数会被自动调用。</li><li><strong>在<code>Base</code>构造函数执行的早期阶段</strong>，对象的虚指针被设置为指向<code>Base</code>的虚表。这确保了即使在<code>Base</code>构造函数内部，任何虚函数调用都能正确地解析到<code>Base</code>类的实现。</li><li>然后，控制权回到<code>Derived1</code>的构造函数，在它开始执行的早期，对象的虚指针更新为指向<code>Derived1</code>的虚表。</li><li>同样地，当<code>Derived2</code>的构造函数开始执行时，对象的虚指针最终被更新为指向<code>Derived2</code>的虚表。</li><li>当<code>Derived2</code>的构造函数执行完毕，整个对象被完全构造完成，此时虚指针指向<code>Derived2</code>的虚表，确保任何对虚函数的调用都会解析到<code>Derived2</code>或它正确的基类实现。</li></ul><p>因此，虚指针的设置和更新发生在每个构造阶段的开始，确保了即使在构造过程中发生虚函数调用，也能够调用到正确版本的函数【但是一般不在构造函数中调用虚函数，不推荐】。这也意味着虚指针和虚表的“生成”（或更准确地说，虚指针的设置）是在构造对象的过程中逐步完成的，而不是在整个对象构造完成后</p></blockquote></li><li><p>析构函数可以为虚函数吗</p><p>可以，而且如果你的类是基类，将基类的析构函数声明为虚函数是非常重要且推荐的做法。这是面向对象设计中的一个关键原则，特别是当涉及到多态和继承时。</p><blockquote><p>有一个指向派生类对象的基类指针，并且通过这个基类指针删除对象时，如果基类的析构函数不是虚的，那么只有基类的析构函数会被调用，导致派生类部分可能不会被正确清理，从而造成资源泄漏或其他问题。这是因为在这种情况下，编译器无法确定要调用哪个析构函数，因为它只依据指针的静态类型来做决定。</p></blockquote></li><li><p>构造函数和析构函数可以调用虚函数吗</p><p>对于构造函数：此时子类的对象还没有完全构造，编译器会去虚函数化，只会用当前类的函数， 如果是纯虚函数，就会调用到纯虚函数，会导致构造函数抛异常</p><p>对于析构函数： 同样，由于对象不完整，编译器会去虚函数化，函数调用本类的虚函数，如果本类虚函数是纯虚函数，就会到账析构函数抛出异常</p><p>语法上讲可以，但不推荐这种做法【effective C++: <strong>绝不在构造和析构过程中调用虚函数</strong>】</p><blockquote><p>《Effective C++》的解释是： 派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型</p><ul><li>在构造函数中调用虚函数,调用的是当前<strong>正在构造</strong>的类的版本,而不是最终的重写版本</li><li>在析构函数中调用虚函数,调用的是当前<strong>正在析构</strong>的类的版本,而不是原始的基类版本</li></ul></blockquote><p>父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编【<strong>构造函数和析构函数调用虚函数时都不使用动态联编</strong>】</p><p>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Base()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">out</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base::print()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base::out()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derived</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Derived()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Derived()&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">out</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Derived::print()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">out</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Derived::out()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">Base::<span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">Derived</span>()</span><br><span class="line">Derived::<span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Derived</span>()</span><br><span class="line">Derived::<span class="built_in">out</span>()</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">Base::<span class="built_in">out</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 谁构造谁调用</span></span><br><span class="line"><span class="comment">// 谁析构谁调用</span></span><br><span class="line"><span class="comment">// 让我们从虚表虚指针的角度讨论</span></span><br><span class="line"><span class="comment">// 构造的时候，我们的派生类对象还未生成完成，此时vptr也是指向基类的虚表，所以无论是从vptr&amp;vtable角度讲还是一般构造来讲调用的是本类的虚函数（即虚函数还未被派生类的定义所覆盖），然后进入到派生类构造函数，此时才开始调用新的覆写的函数</span></span><br><span class="line"><span class="comment">// 同理析构的时候，先从本派生类开始析构，此时vptr是指向派生类虚表，所以无论是从vptr&amp;vtable角度讲还是一般构造来讲调用的是本类的虚函数（即调用的是被覆盖的版本），然后进入到基类的析构函数，此时调用的是原虚函数</span></span><br></pre></td></tr></table></figure></li><li><p>总结</p></li></ul><table><thead><tr><th>不可以为虚函数的函数</th><th>备注</th></tr></thead><tbody><tr><td>构造函数 （不可以）</td><td>虚指针未初始化，矛盾</td></tr><tr><td>内联函数 （不推荐）</td><td>派生类指针调用不会内联展开；对象本身调用内联展开</td></tr><tr><td>静态函数 （不可以）</td><td>因为不属于对象属于类，静态成员函数没有this指针</td></tr><tr><td>友元函数 （不可以）</td><td>因为友元函数不属于类的成员函数，不能被继承，不会进入虚表</td></tr></tbody></table><h4 id="继承"><a class="header-anchor" href="#继承"></a>继承</h4><ol><li><p><strong>公有继承（Public Inheritance）</strong>：</p><p>公有继承意味着基类的<strong>公有成员和保护成员</strong>在派生类中<strong>保持其原有的访问属性</strong>。<strong>基类的私有成员在派生类中仍然是私有的</strong>，<strong>但派生类无法直接访问它们</strong>。这是最常用的继承类型，用于实现“是一个（is-a）”关系。</p></li><li><p><strong>保护继承（Protected Inheritance）</strong>：</p><p>保护继承意味着基类的<strong>公有成员和保护成员</strong>在派生类中<strong>变为保护成员</strong>。这允许派生类的成员和派生类的派生类访问这些成员，但其他任何类都不能。这种继承方式比较少见。</p></li><li><p><strong>私有继承（Private Inheritance）</strong>：</p><p>私有继承意味着基类的<strong>公有成员和保护成员</strong>在派生类中<strong>变为私有成员</strong>。这意味着这些成员只能被派生类自己的成员函数和友元函数访问。私有继承并不表明“是一个（is-a）”关系，而是表明“有一个（has-a）”关系或者是一种实现细节的继承。</p></li><li><p><strong>菱形继承与虚继承</strong></p><p>当两个类继承自同一个基类，并且另一个类再从这两个类继承时，最顶层的基类会被继承多次，导致资源浪费和访问歧义</p><p>虚继承通过引入虚基类来解决菱形继承问题。在虚继承中，无论基类被继承了多少次，派生类中只会包含一个基类的实例</p><p><strong>虚继承工作原理:</strong></p><ul><li><strong>虚基类表（vbase table）</strong>：编译器会为使用虚继承的类构建一个虚基类表。这个表用于存储虚基类相对于派生类对象的偏移量。</li><li><strong>初始化虚基类</strong>：虚基类的构造函数由最开始的派生类调用，确保虚基类只被初始化一次。</li><li>但是引入了额外性能开销,因为要引入虚基类表</li></ul></li></ol><h4 id="析构与构造"><a class="header-anchor" href="#析构与构造"></a>析构与构造</h4><h5 id="构造函数种类"><a class="header-anchor" href="#构造函数种类"></a>构造函数种类</h5><table><thead><tr><th></th><th>解释</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td>普通构造函数</td><td>完成对象的初始化工作</td><td style="text-align:left">含参数</td></tr><tr><td>默认构造函数</td><td>完成对象的初始化工作</td><td style="text-align:left">无参数</td></tr><tr><td>拷贝构造函数</td><td>复制构造函数用于复制本类的对象，拷贝构造函数在用一个对象初始化另一个新对象时被调用</td><td style="text-align:left">默认实现是浅拷贝而非深拷贝</td></tr><tr><td>转换构造函数</td><td>转换构造函数用于将其他类型的变量，隐式转换为本类对象</td><td style="text-align:left"></td></tr><tr><td>移动构造函数</td><td>特殊的构造函数，用于在对象之间转移资源的所有权，而不是复制资源</td><td style="text-align:left"></td></tr><tr><td>委托构造函数</td><td>构造函数可以委托同类型的另一个构造函数对对象进行初始化</td><td style="text-align:left"></td></tr></tbody></table><blockquote><p>赋值运算符在将一个已存在的对象赋值给另一个已存在的对象时被调用</p><ul><li>如果用户没有定义这些函数，则编译器会隐式声明一个构造函数</li><li>在编译器需要的情况下（如带有虚函数，虚拟继承等等），会隐式定义函数，这时函数为非平凡的(no-trivial)；否则则编译器不会添加代码来定义一个函数，这时的函数为平凡的（trivial）</li></ul></blockquote><ul><li>普通构造函数</li></ul><p>**初始化方式：**赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化</p><h6 id="委托构造函数"><a class="header-anchor" href="#委托构造函数"></a>委托构造函数</h6><ol><li><strong>被委托的构造函数在委托构造函数的初始化列表里被调用，而不是在委托构造函数的函数体里被调用。</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> weight = <span class="number">120</span>;</span><br><span class="line"><span class="built_in">student</span>(<span class="type">int</span> give_age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">student</span>(give_age, <span class="number">180</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;委托老兄办点事！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">student</span>(<span class="type">int</span> give_age, <span class="type">int</span> give_weight) :<span class="built_in">age</span>(give_age), <span class="built_in">weight</span>(give_weight)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我被委托做一些事情！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> student stu = <span class="built_in">student</span>(<span class="number">20</span>);</span><br><span class="line">std::cout &lt;&lt; stu.age &lt;&lt; std::endl &lt;&lt; stu.weight &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">我被委托做一些事情！</span><br><span class="line">委托老兄办点事！</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们发现我们的“委托构造（伪版）”不成功，并没有被构造为20,120，逐步调用我们发现进入student(give_age, 180);后对象变为20,120，但是完成student(give_age, 180);语句后对象恢复为18,120。忽略了被委托构造函数的初始化列表。原因是这段代码的意思是创建了一个匿名student对象然后销毁了它所以不成功。</span></span><br></pre></td></tr></table></figure><p><strong>2.委托构造函数的初始值列表中，只允许出现被委托的构造函数，而不能直接给成员变量进行初始化</strong></p><p><strong>3.先执行被委托构造函数的初始化列表，然后执行被委托构造函数的函数体，最后返回执行委托构造函数的函数体。</strong></p><p><strong>4.被委托的构造函数同样可以是一个委托构造函数，它继续委托另一个构造函数完成初始化任务。</strong></p><h6 id="移动构造函数"><a class="header-anchor" href="#移动构造函数"></a>移动构造函数</h6><p>C++11 引入的一种特殊的构造函数，用于在对象之间<strong>转移资源的所有权，而不是复制资源</strong>。它通常用于优化那些包含动态分配资源（如指针）的对象的移动操作，以避免不必要的复制和资源分配</p><p>移动构造函数的特点：</p><ol><li>它接受一个右值引用（rvalue reference）作为参数，表示要从中移动资源的对象。</li><li>它将源对象的资源转移到新创建的对象，而不是复制资源。</li><li>在转移资源后，它将源对象的状态设置为有效的默认状态，但不分配任何新的资源</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line"><span class="comment">// 转移资源的所有权</span></span><br><span class="line">data = other.data;</span><br><span class="line"><span class="comment">// 将源对象设置为默认状态</span></span><br><span class="line">other.data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>移动构造函数不应该抛出异常，因此通常被标记为 <code>noexcept</code>。此外，只有在源对象是一个右值（rvalue）时，移动构造函数才会被调用。对于左值（lvalue），仍然会调用常规的拷贝构造函数</strong>。</p><p><em>感觉很像是右值引用的移动语义</em></p><h6 id="拷贝构造函数"><a class="header-anchor" href="#拷贝构造函数"></a>拷贝构造函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; t)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常见的使用场景（什么时候会发起拷贝函数调用）：</span></span><br><span class="line"><span class="comment">//1.以一个对象初始化另一个对象</span></span><br><span class="line"><span class="comment">//2.函数参数的对象传递</span></span><br><span class="line"><span class="comment">//3.作为参数的返回值（无移动构造函数）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;......&#125;;</span><br><span class="line">MyClass a;</span><br><span class="line">MyClass b = a; <span class="comment">// 1.对象初始化</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fun</span>(b); <span class="comment">// 2.将对象b作为参数传入fun</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">fun</span><span class="params">()</span></span>&#123; </span><br><span class="line"> MyClass b; </span><br><span class="line"> <span class="keyword">return</span> b; <span class="comment">//3.返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数默认浅拷贝</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么拷贝构造函数必须传引用不能传值</p><p>会导致无限重复的进行拷贝，导致无限递归和栈溢出</p></blockquote><h6 id="深拷贝浅拷贝"><a class="header-anchor" href="#深拷贝浅拷贝"></a>深拷贝浅拷贝</h6><p><strong>浅拷贝(Shallow Copy)</strong></p><p>浅拷贝是指在创建新对象时,简单地将源对象的非静态数据成员的值复制到新对象中,而不复制指针所指向的动态分配的内存区域。换句话说,源对象和新对象共享相同的动态分配的内存区域。</p><p>浅拷贝可能会导致以下问题:</p><ol><li><strong>资源重复释放</strong>: 当源对象和新对象被销毁时,它们都会尝试释放相同的动态分配的内存区域,从而导致程序崩溃或未定义行为。</li><li><strong>资源泄漏</strong>: 如果只销毁了源对象或新对象中的一个,而另一个对象仍然存在,则动态分配的内存区域将无法被释放,从而导致资源泄漏</li></ol><p><strong>深拷贝(Deep Copy)</strong></p><p>深拷贝是指在创建新对象时,不仅复制源对象的非静态数据成员的值,还为指针类型的数据成员分配新的动态内存区域,并将源对象中指针指向的数据复制到新分配的内存区域中。这样,源对象和新对象就拥有独立的动态分配的内存区域。深拷贝可以避免浅拷贝可能导致的资源重复释放和资源泄漏问题,但是它需要更多的内存和复制开销</p><h6 id="零拷贝"><a class="header-anchor" href="#零拷贝"></a>零拷贝</h6><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p><p>零拷贝技术可以减少数据拷贝和共享总线操作的次数</p><p>例如vector的emplace_back()方法</p><h5 id="列表初始化"><a class="header-anchor" href="#列表初始化"></a>列表初始化</h5><p>初始化列表只做一次赋值操作，相比构造函数体内进行赋值的话，构造函数体内进行赋值会等于是一次默认构造加一次赋值。</p><p>当一个类的对象被创建时，其成员变量的构造过程遵循以下步骤：</p><ol><li><p><strong>内存分配</strong>：首先为对象分配内存，包括其所有成员变量。</p></li><li><p>成员初始化</p><ul><li><strong>使用初始化列表</strong>：如果提供了初始化列表，则成员变量将通过在列表中指定的构造函数直接初始化。这意味着对于类类型成员，将直接调用相应的构造函数（可能是参数化构造函数或复制构造函数），而对于内置类型成员，则直接进行赋值。</li><li><strong>未使用初始化列表</strong>：如果没有为类类型的成员变量提供初始化列表，则这些成员变量首先通过默认构造函数进行初始化。之后，如果在构造函数体内有赋值操作，这些成员变量将经历一次赋值操作。</li></ul></li><li><p><strong>执行构造函数体</strong>：完成成员的初始化后，执行构造函数体中的代码</p></li></ol><p>对于类类型的成员变量，如果在构造函数体内对它们进行赋值，而不是在初始化列表中直接初始化，会发生以下情况：</p><ul><li><strong>默认构造阶段</strong>：在进入构造函数体之前，类类型的成员需要被初始化。如果没有在初始化列表中明确指定如何初始化，那么这些成员将通过默认构造函数进行初始化。这是成员对象的生命周期的开始。</li><li><strong>赋值操作</strong>：在构造函数体内，对这些已经默认构造的成员进行赋值，实际上是调用赋值操作符。这不是成员对象的初始化，而是在一个已经构造的对象上进行的赋值。</li></ul><h5 id="构造-析构执行顺序"><a class="header-anchor" href="#构造-析构执行顺序"></a>构造\析构执行顺序</h5><p>构造：<strong>基类构造函数-&gt;成员对象的构造函数-&gt;派生类构造函数</strong></p><p>虚基类及上⼀层基类的构造函数调⽤、 vptr 被初始化、有成员初始化列表，将在构造函数体内扩展开来，这必须在 vptr 被设定之后才做</p><blockquote><p>构造子类构造函数的参数</p><p>子类调用基类构造函数</p><p>基类设置vptr</p><p>基类初始化列表内容进行构造</p><p>基类函数体调用</p><p>子类设置vptr</p><p>子类初始化列表内容进行构造</p><p>子类构造函数体调用</p></blockquote><p>析构：派生类析构函数&lt;-成员对象的析构函数&lt;-基类析构函数</p><p>析构函数函数体被执⾏、class 拥有成员类对象拥有析构函数，那么它们会以其声明顺序的相反顺序被调用、任何直接的上⼀层⾮虚基类拥有析构函数，以声明顺序被调⽤（如果有多个成员类对象则构造函数的调用顺序是对象在类中<strong>被声明的顺序</strong>，而不是它们出现在成员初始化表中的顺序）</p><h5 id="构造函数析构函数可否抛出异常"><a class="header-anchor" href="#构造函数析构函数可否抛出异常"></a>构造函数析构函数可否抛出异常</h5><p>**构造函数：**当构造函数抛出异常时，对象被认为是没有成功构造的。如果在构造期间抛出异常，C++运行时系统会自动调用已经成功构造的成员对象和基类的析构函数来清理资源，然后将异常传播给上一级的异常处理程序。如果你在构造函数中使用资源（如动态分配内存、文件句柄、锁等），并且在构造过程中抛出异常，你必须确保到目前为止已经构造的部分能够被正确地清理，以避免资源泄漏</p><p>**析构函数：**析构函数抛出异常是非常危险的，通常应该避免。如果析构函数抛出异常，并且没有在析构函数内部捕获它，这可能导致程序的不正常终止，因为析构函数通常在对象生命周期结束时被自动调用，包括在处理其他异常时。如果在处理一个异常的过程中，一个析构函数抛出了另一个异常（这被称为异常嵌套），C++标准规定，程序将调用<code>std::terminate()</code>，导致程序立即终止.</p><h5 id="什么时候合成构造函数"><a class="header-anchor" href="#什么时候合成构造函数"></a>什么时候合成构造函数</h5><ul><li><p>没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数</p></li><li><p>没有任何构造函数的类派生自一个带有默认构造函数的基类</p></li><li><p>带有虚函数的类</p></li><li><p>含有虚基类</p></li></ul><h5 id="什么时候合成拷贝构造函数"><a class="header-anchor" href="#什么时候合成拷贝构造函数"></a>什么时候合成拷贝构造函数</h5><p>被当做参数交给某个函数</p><p>如果返回的对象是一个函数参数或类的成员变量，而不是局部对象，则会调用拷贝构造函数</p><p>没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数</p><p>没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类</p><p>带有虚函数的类</p><p>含有虚基类</p><p><strong>注意：返回一个局部对象，编译器会优先调用移动构造函数来创建返回值，而不是拷贝构造函数</strong></p><blockquote><p>如何禁止自动生成拷贝构造函数</p><p>为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要将他们设置成private</p></blockquote><h4 id="模板"><a class="header-anchor" href="#模板"></a>模板</h4><p>模板是C++中实现泛型编程的工具，它允许程序员编写与数据类型无关的代码。模板可以用于函数和类，使得函数或类可以操作任何类型的数据，从而增加了代码的复用性和灵活性。</p><ul><li><strong>函数模板</strong>：允许以任意类型执行相同的操作。例如，可以写一个排序函数，用于任何可以比较元素的数据类型。</li><li><strong>类模板</strong>：允许生成操作任意类型数据的类的实例。例如，<code>std::vector&lt;T&gt;</code>可以存储任何类型<code>T</code>的动态数组</li></ul><p>模板的底层实现机制称为<strong>模板实例化</strong>。<strong>模板本身不是直接编译成机器代码的</strong>，而是在编译器遇到模板使用时（例如，通过指定模板参数来创建对象或调用函数）【两次编译】<strong>在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译</strong></p><ul><li><strong>函数模板实例化</strong>：当你使用特定类型调用一个函数模板时，编译器会生成一个该类型的特定版本的函数。如果你用相同的类型参数再次调用该函数模板，编译器通常会重用之前生成的实例。这意味着对于每一种类型的函数调用，编译器都可能生成一个专门的函数实例。</li><li><strong>类模板实例化</strong>：类模板的实例化过程与函数模板类似。当你声明一个类模板的实例（即对象）时，需要为模板参数提供具体的类型。编译器随后为这些具体类型生成一个特定的类定义。每个不同的参数化类型都会生成一个新的类实例。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数模板和类模板区别</strong></p><p>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加<T>，而函数模板不必</p><p><strong>模板的声明和实现通常写在哪</strong></p><p><strong>通常都放在头文件中</strong>，这是因为模板需要在编译时实例化。如果编译器在处理模板使用（即实例化）的文件时看不到模板定义，它就无法生成模板实例的代码。将模板的声明和定义分离到不同的文件中会导致链接错误，因为编译器在实例化模板时找不到模板定义，所以不能分开放。</p><h4 id="引用与指针"><a class="header-anchor" href="#引用与指针"></a>引用与指针</h4><p>在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有<code>const</code>和⾮ <code>const</code>区别，甚⾄可以为空，<code>sizeof</code>指针得到的是指针类型的⼤⼩。</p><p>引⽤来说，它只是⼀块内存的别名，在添加到符号表的时候，是将&quot;引⽤变量名-引⽤对象的地址&quot;添加到符号表中，符号表⼀经完成不能改变，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 <code>const</code> 和⾮<code>const</code>区别。</p><ul><li><p>指针是一个变量，存储地址，引用是别名</p></li><li><p>指针可以有多级，引用只有一级</p></li><li><p>指针可以为空，引用必须初始化</p></li><li><p>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</p></li><li><p>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>* a)</span> </span>&#123;</span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//delete *a;</span></span><br><span class="line"><span class="comment">//*a = new int(10);</span></span><br><span class="line"><span class="comment">// 要修改 a 指向的指针所指向的整数，使用 **a。</span></span><br><span class="line"><span class="comment">// 要修改 a 指向的指针本身（即让它指向一个新的整数），使用 *a</span></span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> *v = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; *v &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line"><span class="built_in">f</span>(v);</span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">cout&lt;&lt;*v&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">00000232</span>C16B2E30</span><br><span class="line"><span class="number">00000232</span>C16AC870</span><br><span class="line"><span class="number">00000232</span>C16B2E30</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h5 id="指针参数传递-引用参数传递"><a class="header-anchor" href="#指针参数传递-引用参数传递"></a>指针参数传递&amp;引用参数传递</h5><p>指针参数传递本质上是值传递，它所传递的是一个地址值</p><p>引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址，提高函数调用和运行的效率（避免拷贝构造副本）</p><p><strong>相似之处</strong>：</p><ul><li>都可以用来修改外部变量的值。</li><li>都是通过传递地址来实现的，相比值传递有更好的性能，尤其是对于大型对象。</li></ul><p><strong>不同之处</strong>：</p><ul><li><strong>安全性</strong>：引用更安全，因为它们保证了引用的对象一定存在（除非你非常努力地去破坏这一点）。指针可以为空，使用前需要检查是否为空。</li><li><strong>可选性</strong>：指针可以是 <code>nullptr</code>，这允许表示“没有对象”或“可选”语义。引用必须绑定到一个实际的对象。</li><li><strong>语法</strong>：引用的语法更简洁，不需要使用 <code>*</code>（解引用）和 <code>&amp;</code>（取地址）操作符。</li><li><strong>重新赋值</strong>：指针可以在其生命周期内改变指向的对象，而引用一旦初始化后就不能被改变指向另一个对象。</li></ul><blockquote><p>需要返回函数内局部变量的内存的时候用指针，使用指针传参需开辟内存</p><p>对栈空间大小比较敏感（比如递归）的时候使用引用</p><p>类对象作为参数传递的时候使用引用</p></blockquote><h5 id="指针分辨"><a class="header-anchor" href="#指针分辨"></a>指针分辨</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>]</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>]</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">p</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(*p)</span><span class="params">(<span class="type">int</span>)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>右左法则：</p><p>使用右左法则时，你从变量名开始，然后根据优先级（括号 &gt; 数组/函数 &gt; 指针）向右看，如果到达声明的末尾，就转向左边继续</p></blockquote><p><code>int *p[10]</code></p><ul><li><strong>分析</strong>: 首先看到的是 <code>[]</code>，表示 <code>p</code> 是一个数组；然后移动到左边，看到 <code>*</code>，表示数组的元素是指针；最后到最左边，看到 <code>int</code>，表示这些指针指向整型数据。</li><li><strong>结论</strong>: <code>p</code> 是一个有10个元素的数组，每个元素是指向 <code>int</code> 类型数据的指针。</li><li><strong>类型</strong>: <code>int *[]</code></li></ul><p><code>int (*p)[10]</code></p><ul><li><strong>分析</strong>: 首先看到的是 <code>(*p)</code>，括号表示 <code>p</code> 是被 <code>*</code> 解引用的，所以 <code>p</code> 是一个指针；然后外面是 <code>[]</code>，表示这个指针指向的是一个数组；最后是 <code>int</code>，表示数组的元素是整型数据。</li><li><strong>结论</strong>: <code>p</code> 是一个指针，指向一个有10个整型元素的数组。</li><li><strong>类型</strong>: <code>int (*)[]</code></li></ul><p><code>int *p(int)</code></p><ul><li><strong>分析</strong>: 这是一个函数声明。首先看到的是 <code>(int)</code>，表示有一个整型参数的函数；然后到左边，看到 <code>*p</code>，这里 <code>p</code> 是函数名，<code>*</code> 表示函数返回的是指针；最后到最左边，<code>int</code> 表示这个指针指向整型数据。</li><li><strong>结论</strong>: <code>p</code> 是一个函数，接受一个整型参数，返回一个指向整型数据的指针。</li><li><strong>类型</strong>: <code>int *(int)</code></li></ul><p><code>int (*p)(int)</code></p><ul><li><strong>分析</strong>: 首先看到的是 <code>(*p)</code>，括号里的 <code>*</code> 表示 <code>p</code> 是一个指针；外面的 <code>(int)</code> 表示这个指针指向的是一个接受整型参数的函数；最后是 <code>int</code>，表示这个函数返回整型数据。</li><li><strong>结论</strong>: <code>p</code> 是一个指针，指向一个函数，该函数接受一个整型参数并返回一个整型数据。</li><li><strong>类型</strong>: <code>int (*)(int)</code></li></ul><h5 id="左右值引用"><a class="header-anchor" href="#左右值引用"></a>左右值引用</h5><ul><li><strong>左值</strong>：<strong>指的是表达式结束后依然存在的对象</strong>。左值可以出现在赋值表达式的左侧。例如，变量、对数组元素的引用、解引用指针、返回引用的函数调用都是左值。</li><li><strong>右值</strong>：<strong>通常指的是表达式结束就不再存在的临时对象</strong>。右值不能出现在赋值表达式的左侧。字面量（除了字符串字面量外）、返回非引用的函数调用、算术表达式的结果都是右值。</li></ul><p><strong>左值引用（略）</strong></p><p><strong>右值引用</strong></p><blockquote><p>解决什么问题：</p><p>右值引用能够绑定到一个临时将要被销毁的对象上，避免不必要复制，提升程序性能，</p><p>同时还能将右值引用的对象的资源移动到另外的对象中去【移动语义】，</p><p>使得资源转移更加高效。允许函数模板以透明的方式转发参数，保持原有的左值或右值属性【完美转发】</p></blockquote><p>优点：</p><ol><li><p>支持移动语义：<strong>右值引用允许将资源（如动态分配的内存）从一个对象移动到另一个对象，而不是传统的复制，从而提高性能和效率</strong>。</p><blockquote><p>允许对象“窃取”另一个对象的资源而不是拷贝它们</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = std::<span class="built_in">move</span>(otherVector);</span><br></pre></td></tr></table></figure><p><code>std::move</code>将<code>otherVector</code>转换为一个右值引用，这允许<code>v</code>的构造函数接管<code>otherVector</code>的内部数据，而不是复制它们。<code>otherVector</code>在操作后变为处于有效但不可预测的状态，并且应该不再使用</p></li><li><p>可用于完美转发：右值引用可以用于实现完美转发，即在函数模板中将参数以原始形式传递给其他函数，保留参数的值类别（左值或右值）【即左值被处理后仍然是左值】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将arg完美转发给另一个函数</span></span><br><span class="line"><span class="built_in">otherFunction</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="野指针-与-悬空指针"><a class="header-anchor" href="#野指针-与-悬空指针"></a>野指针 与 悬空指针</h5><p>野指针（Wild Pointer）</p><p>野指针是指未初始化的指针。其指向的内存地址是不确定的，因为它没有被明确初始化为NULL或指向有效的内存地址。使用野指针的结果是不可预测的，因为它可能指向任何内存地址，包括系统保留的内存。尝试访问或操作野指针所指向的内存通常会导致不可预测的行为，包括程序崩溃、数据损坏或者安全漏洞。</p><p>悬空指针（Dangling Pointer）</p><p>悬空指针是指向了一块已经被释放的内存的指针。当使用例如<code>free</code>或<code>delete</code>操作释放了一块内存之后，原本指向那块内存的指针就成了悬空指针。与野指针不同，悬空指针之前是指向有效内存的，但在内存释放后继续使用它就变得危险了。因为那块内存可能已经被重新分配给其他用途，对悬空指针的引用或操作可能会导致数据损坏或者不稳定的行为。</p><h4 id="智能指针"><a class="header-anchor" href="#智能指针"></a>智能指针</h4><p><strong>智能指针是一个类，指向动态分配对象，负责自动释放动态分配的对象，防止内存泄漏</strong></p><p><strong>auto_ptr</strong></p><p>C++98 引入的一种智能指针,可以自动管理动态分配（使用 <code>new</code>）的对象的生命周期，以避免内存泄漏,当 <code>std::auto_ptr</code> 的实例离开作用域时，它会自动删除所管理的对象. 由于缺陷建议被3大智能指针替代</p><p><code>std::auto_ptr</code> 的主要问题:</p><ol><li><strong>所有权转移</strong>：<code>std::auto_ptr</code> 在进行拷贝或赋值时，会发生所有权的转移。这意味着原 <code>std::auto_ptr</code> 会失去对对象的所有权（变为 <code>nullptr</code>），而新的 <code>std::auto_ptr</code> 获得所有权。这种行为很容易导致意外的所有权转移，造成资源管理上的困惑。</li><li><strong>容器兼容性</strong>：由于所有权转移的行为，<code>std::auto_ptr</code> 不能安全地用于标准容器（如 <code>std::vector</code>、<code>std::list</code> 等）。尝试存储 <code>std::auto_ptr</code> 的拷贝在容器中会导致未定义行为，因为容器操作经常需要元素的复制和赋值。</li><li><strong>多线程问题</strong>：<code>std::auto_ptr</code> 没有考虑到多线程环境中的安全性问题。其设计不包含对并发访问的保护，这在多线程程序中可能会导致数据竞争和其他同步问题。</li></ol><p><strong>新版智能指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::unique_ptr</span></span><br><span class="line"><span class="comment">// std::shared_ptr </span></span><br><span class="line"><span class="comment">// std::weak_ptr</span></span><br></pre></td></tr></table></figure><p><strong><code>std::unique_ptr</code></strong>：是一种<strong>独占所有权</strong>的智能指针，意味着同一时间内只能有一个<code>unique_ptr</code>指向给定资源。当<code>unique_ptr</code>离开作用域时，它指向的对象会被自动销毁。<strong>这种智能指针不允许复制，确保了资源的独占性，但它允许移动，使得资源的所有权可以转移</strong></p><p><strong><code>std::shared_ptr</code></strong>：是一种<strong>共享所有权</strong>的智能指针，允许多个<code>shared_ptr</code>实例指向同一个对象。内部使用引用计数机制来跟踪有多少个<code>shared_ptr</code>共享同一个资源。当最后一个指向对象的<code>shared_ptr</code>被销毁时，对象会被自动删除。<code>shared_ptr</code>适用于需要通过多个指针访问同一资源的情况。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要<strong>加锁</strong></p><p><strong><code>std::weak_ptr</code></strong>：是一种<strong>不拥有对象</strong>的智能指针，它设计用来解决<code>shared_ptr</code>间的<strong>循环引用问题</strong>。<em><code>weak_ptr</code>指向<code>shared_ptr</code>管理的对象，但不增加引用计数</em>。因此，<code>weak_ptr</code>不会阻止其指向的对·象被销毁。通常，<code>weak_ptr</code>用于临时访问<code>shared_ptr</code>管理的对象，而不希望对对象的生命周期产生影响。可以通过lock函数检查对象是否失效，未失效则转换到<code>shared_ptr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 输出: 10</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// ptr会在这里自动释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// ptr2现在与ptr1共享所有权</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl; <span class="comment">// 输出: 10</span></span><br><span class="line">std::cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出: 2，因为有两个shared_ptr指向同一个对象</span></span><br><span class="line"><span class="comment">// ptr1和ptr2会在这里自动释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; weakPtr = sharedPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> tempSharedPtr = weakPtr.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试获取一个shared_ptr</span></span><br><span class="line">std::cout &lt;&lt; *tempSharedPtr &lt;&lt; std::endl; <span class="comment">// 输出: 10</span></span><br><span class="line"><span class="comment">// tempSharedPtr会在这里自动释放内存</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;对象已被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>循环引用</strong>：指两个或多个对象相互持有对方的强引用（如 <code>shared_ptr</code>），导致这些对象的引用计数永远不会降为零，从而造成内存泄漏。<code>a</code> 和 <code>b</code> 就形成了循环引用。当 <code>a</code> 和 <code>b</code> 离开作用域时，它们的引用计数都是 2，因为它们分别被对方持有一次引用。结果是，<code>a</code> 和 <code>b</code> 的引用计数永远不会降到 0，它们占用的内存就无法被释放，导致内存泄漏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 智能指针的循环引用 导致内存泄漏</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::shared_ptr&lt;A&gt; a_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">a-&gt;b_ptr = b;</span><br><span class="line">b-&gt;a_ptr = a;</span><br></pre></td></tr></table></figure><p><strong>拷贝</strong></p><p>当使用一个智能指针来初始化另一个智能指针时,会调用智能指针的拷贝构造函数。不同的智能指针类型,其拷贝构造行为也不尽相同:</p><ul><li><code>std::unique_ptr</code>: 由于<code>unique_ptr</code>是独占所有权的,不允许拷贝构造,只能进行移动构造。</li><li><code>std::shared_ptr</code>: 拷贝构造会使新的<code>shared_ptr</code>与原<code>shared_ptr</code>共享同一个控制块,从而共享对象的所有权。引用计数会加1。</li><li><code>std::weak_ptr</code>: 拷贝构造不会影响引用计数,新旧<code>weak_ptr</code>指向同一个控制块。</li></ul><p><strong>赋值</strong></p><p>对智能指针进行赋值操作时,行为也因类型而异:</p><ul><li><code>std::unique_ptr</code>: 不允许普通的赋值操作,只能通过移动赋值转移所有权。</li><li><code>std::shared_ptr</code>: 赋值后,两个<code>shared_ptr</code>共享同一个控制块,引用计数会加1。</li><li><code>std::weak_ptr</code>: 赋值不会影响引用计数</li></ul><p><strong>总结</strong></p><table><thead><tr><th></th><th>拷贝</th><th>赋值</th></tr></thead><tbody><tr><td>shared_ptr</td><td>T</td><td>T</td></tr><tr><td>unique_ptr</td><td>F</td><td>F</td></tr><tr><td>weak_ptr</td><td>T</td><td>T</td></tr></tbody></table><h4 id="RAII"><a class="header-anchor" href="#RAII"></a>RAII</h4><p>Resource Acquisition Is Initialization(RAII)</p><p>核心思想是：在对象的生命周期内获取所需的资源，并在对象销毁时释放这些资源。这种方式利用了C++的构造函数和析构函数自动调用的特性，确保资源使用安全且高效，这也是为什么C++比C安全的原因之一。智能指针便是RAII最具代表的实现。</p><h4 id="RTTI"><a class="header-anchor" href="#RTTI"></a>RTTI</h4><p>Run Time Type Identification</p><p>通过运行时类型识别，程序能够使用<strong>基类的指针或引用</strong>来<strong>检查着这些指针或引用所指的对象的实际派生类型</strong></p><ul><li><p>typeid操作符，返回指针和引用所指的实际类型；</p></li><li><p>dynamic_cast操作符，将基类类型的指针或引用安全地转换为其派生类类型的指针或引用</p></li></ul><h4 id="面向对象"><a class="header-anchor" href="#面向对象"></a>面向对象</h4><p><strong>封装</strong>:信息隐藏</p><p><strong>继承</strong>:继承是使用已存在的类的定义作为基础建立新类</p><p><strong>多态</strong></p><ul><li>多态:发出的方法调用在编程时并不确定，而是在程序运行期间才确定</li><li>多态是以封装和继承为基础的。</li><li>C++ 多态分类及实现：<ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol></li></ul><p><strong>静态多态</strong> - 函数重载</p><p><strong>动态多态</strong> -</p><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li><li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li></ul><p><strong>注意：</strong></p><ul><li><p>可以将派生类的对象赋值给基类的指针或引用，反之不可</p></li><li><p>普通函数（非类成员函数）不能是虚函数</p></li><li><p>静态函数（static）不能是虚函数</p></li><li><p>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</p></li><li><p>内联函数不能是表现多态性时的虚函数</p></li><li><p>引用和指针可以调用多态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">A* p = &amp;b;</span><br><span class="line">A&amp; r = b;</span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">f</span>();</span><br><span class="line">r.<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用和指针才能展现多态</p><p>非指针和非引用将导致<strong>切割问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">A a = b;</span><br><span class="line">    a.<span class="built_in">f</span>(); <span class="comment">// A::f()</span></span><br><span class="line"></span><br><span class="line">    A* c = &amp;b;</span><br><span class="line">    c-&gt;<span class="built_in">f</span>(); <span class="comment">// B::f()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>对象切割</strong>：在 <code>A a = b;</code> 的赋值过程中，<code>b</code> 对象的 <code>A</code> 部分被复制到 <code>a</code> 中，而 <code>B</code> 部分被丢弃。<ul><li>内存中的 <code>a</code> 对象只包含 <code>A</code> 类的部分，没有 <code>B</code> 类的部分。</li><li>因此，当 <code>a.f()</code> 被调用时，它调用的是 <code>A</code> 类的 <code>f()</code> 函数，因为 <code>a</code> 只是一个 <code>A</code> 对象。</li></ul></li><li><strong>指针和虚函数表</strong>：在 <code>A* c = &amp;b;</code> 的赋值过程中，<code>c</code> 是一个指向 <code>A</code> 类型的指针，但它指向的实际对象是 <code>B</code> 类型。<ul><li>虚函数表包含了派生类的函数指针，因此即使通过 <code>A*</code> 类型的指针调用虚函数，实际调用的仍然是 <code>B</code> 类中的函数。</li><li>当 <code>c-&gt;f()</code> 被调用时，虚函数表中的函数指针指向的是 <code>B::f()</code>，因此调用的是 <code>B::f()</code> 函数</li></ul></li></ol><p>为什么是指针类型的时候就能按照多态的行为去解释（即去查虚函数表，然后实现运行时多态），而非指针类型，直接使用基类类型不会按照多态行为解释？</p><p>运行时类型信息</p><ul><li><strong>指针和引用</strong>：在运行时指向实际的对象。通过指针或引用调用虚函数时，编译器会根据对象的实际类型来查找虚函数表，进而调用正确的虚函数。这种机制使得运行时多态成为可能。</li><li><strong>对象切割</strong>：当对象被切割成基类类型时，只保留了基类部分，派生类的信息被丢弃。因此，编译器只能调用基类的函数，因为对象的类型在编译时已经确定为基类类型。</li><li><strong>对象切割导致类型信息丢失</strong>：对象切割时，基类对象只保留基类部分，虚函数表指针丢失，无法实现运行时多态。</li><li><strong>指针和引用保留类型信息</strong>：指针和引用在运行时指向实际的对象，保留了派生类的所有信息，包括虚函数表指针，从而能够实现多态。</li></ul></li></ul><h4 id="重载重写重定义"><a class="header-anchor" href="#重载重写重定义"></a>重载重写重定义</h4><p>重载</p><p>重载是指在同一个作用域内声明多个具有相同名字但参数列表不同的函数或运算符。编译器通过参数的数量和类型来区分这些函数或运算符。</p><p>重写</p><p>重写是指在派生类中重新定义基类中已存在的虚函数。重写的函数必须具有与基类中被重写函数相同的名称、参数列表和返回类型</p><p>重定义</p><p>重定义是指在派生类中重新定义基类中非虚函数</p><h4 id="友元"><a class="header-anchor" href="#友元"></a>友元</h4><p>友元函数和友元类</p><ul><li>能访问私有成员</li><li>破坏封装性</li><li>友元关系的单向性</li><li>友元关系不可传递（不可被继承不可被传递）</li><li>友元关系的单向性</li><li>友元声明的形式及数量不受限制</li></ul><h4 id="多线程"><a class="header-anchor" href="#多线程"></a>多线程</h4><h5 id="基本"><a class="header-anchor" href="#基本"></a>基本</h5><ol><li><p><strong><code>std::mutex</code></strong>:</p><ul><li>最基本的互斥锁。</li><li>提供了排他性访问，即一次只有一个线程可以持有锁。</li><li>使用 <code>lock()</code> 加锁，使用 <code>unlock()</code> 解锁。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_thread_id</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::thread threads[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">threads[i] = std::<span class="built_in">thread</span>(print_thread_id, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::recursive_mutex</code></strong>:</p><ul><li>递归互斥锁，允许同一个线程多次获取同一互斥锁。</li><li>对于递归函数或循环中需要多次加锁的情况很有用。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::recursive_mutex rmtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursive_function</span><span class="params">(<span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (depth &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">rmtx.<span class="built_in">lock</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Depth: &quot;</span> &lt;&lt; depth &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">recursive_function</span>(depth - <span class="number">1</span>);</span><br><span class="line">rmtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(recursive_function, <span class="number">5</span>)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::timed_mutex</code></strong> 和 <strong><code>std::recursive_timed_mutex</code></strong>:</p><ul><li>这些锁提供了基于时间的锁定功能。</li><li>允许尝试在指定的时间段内获取锁。</li><li>如果在指定时间内无法获得锁，线程可以停止等待，执行其他操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::timed_mutex tmtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">attempt_lock</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tmtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>))) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; acquired the lock.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">tmtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; could not acquire the lock.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::thread threads[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">threads[i] = std::<span class="built_in">thread</span>(attempt_lock, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::recursive_timed_mutex rtm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursive_function</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (depth &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (rtm.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>))) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; acquired the lock. Depth: &quot;</span> &lt;&lt; depth &lt;&lt; std::endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line"><span class="built_in">recursive_function</span>(id, depth - <span class="number">1</span>);</span><br><span class="line">rtm.<span class="built_in">unlock</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; could not acquire the lock. Depth: &quot;</span> &lt;&lt; depth &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(recursive_function, <span class="number">1</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(recursive_function, <span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::shared_mutex</code></strong> (自 C++14 开始支持, 在 C++17 中更名为 <code>std::shared_timed_mutex</code>):</p><ul><li>允许多个线程同时读取共享数据，但写入时需要独占访问。</li><li>适用于读多写少的场景，可以提高并发性。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_mutex smtx;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_data</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">smtx.<span class="built_in">lock_shared</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; reading data: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d : data) &#123;</span><br><span class="line">std::cout &lt;&lt; d &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">smtx.<span class="built_in">unlock_shared</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_data</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">smtx.<span class="built_in">lock</span>();</span><br><span class="line">data.<span class="built_in">push_back</span>(value);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Writing data: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">smtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::thread readers[<span class="number">5</span>], writers[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">writers[i] = std::<span class="built_in">thread</span>(write_data, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">readers[i] = std::<span class="built_in">thread</span>(read_data, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : readers) &#123;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : writers) &#123;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::lock_guard</code></strong>:</p><ul><li>是一个作用域锁，保护一个代码段，使之在多线程环境下线程安全，使用 RAII（资源获取即初始化）方式管理 <code>std::mutex</code>。</li><li>当 <code>std::lock_guard</code> 对象创建时自动加锁，当作用域结束时自动解锁，避免忘记解锁的问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_thread_id</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::thread threads[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">threads[i] = std::<span class="built_in">thread</span>(print_thread_id, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>std::unique_lock</code></strong>:</p><ul><li>比 <code>std::lock_guard</code> 更灵活的作用域锁。</li><li>可以在生命周期内多次锁定和解锁。</li><li>支持条件变量 <code>std::condition_variable</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; shared_data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_vector</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">shared_data.<span class="built_in">push_back</span>(id);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; added to vector.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// lock automatically released when unique_lock goes out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_add_to_vector_with_timeout</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>; <span class="comment">// Create but don&#x27;t lock immediately</span></span><br><span class="line"><span class="keyword">if</span> (lock.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>))) &#123;</span><br><span class="line">shared_data.<span class="built_in">push_back</span>(id);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; added to vector with timeout.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; could not acquire lock in time.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::thread threads[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">threads[i] = std::<span class="built_in">thread</span>(add_to_vector, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">threads[i] = std::<span class="built_in">thread</span>(try_add_to_vector_with_timeout, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Final vector content: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; n : shared_data) &#123;</span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="问题"><a class="header-anchor" href="#问题"></a>问题</h5><p>（注意C++并没有提供线程池的官方实现）</p><ul><li>使用线程池可能带来哪些风险和有哪些好处？</li></ul><p>好处：减少创建和销毁线程的开销与降低系统资源消耗、更好的线程管理和调度</p><p>风险：资源争用和死锁、复杂性增加</p><ul><li>线程池参数有哪些？</li></ul><p>大小、任务队列容量、线程创建策略、线程拒绝策略、线程活跃时间、核心线程数、最大线程数量、线程优先级</p><ul><li>线程池大小如何确定合理？是否和处理器有关？</li></ul><p>CPU密集型任务：如果任务主要是计算密集型的（例如数学运算），那么线程池的大小通常设为处理器核心数的1到1.5倍。这样可以最大化CPU使用率，同时留有少量空间处理其他可能同时发生的系统任务或其他程序。在完全的CPU密集型场景中，线程数设置为核心数相等通常也是合理的，因为更多的线程不会带来性能提升，反而可能因上下文切换导致效率下降。</p><p>I/O密集型任务：如果任务涉及大量的输入/输出操作，如文件操作、网络通信等，这些操作通常涉及等待，此时CPU核心会空闲。在这种情况下，线程池大小可以设置得比核心数多，通常是核心数的2到3倍，甚至更多，以确保CPU在等待I/O操作完成时可以切换到其他任务。</p><ul><li>常用的线程池工作队列</li></ul><p>无界队列、有界队列、优先级队列、同步队列、延迟队列</p><h4 id="C-11新特性简介（部分）"><a class="header-anchor" href="#C-11新特性简介（部分）"></a>C++ 11新特性简介（部分）</h4><p>空指针 <code>nullptr</code>、右值引用、类型推导、范围<code>for</code>循环、<code>final</code>、<code>override</code>、智能指针</p><p><code>lambda</code>表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 1:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指明返回类型，托尾返回类型</span></span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"> <span class="comment">// ⾃动推断返回类型</span></span><br><span class="line"><span class="keyword">auto</span> multiply = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line"> <span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">5</span>); </span><br><span class="line"><span class="comment">// 输出：7</span></span><br><span class="line"> <span class="type">int</span> product = <span class="built_in">multiply</span>(<span class="number">2</span>, <span class="number">5</span>);<span class="comment">// 输出：10</span></span><br><span class="line"><span class="comment">//[] 是 lambda 表达式的⼀个很重要的功能，就是 闭包,表达式就会返回⼀个匿名的闭包实例，其实⼀个右值。所以，lambda 表达式的结果就是⼀个闭包,闭包的⼀个强⼤之处是其可以通过传值或者引⽤的⽅式捕捉其封装作⽤域内的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> add_x = [x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + x; &#125;;</span><br><span class="line"><span class="comment">// 表达式⽆法修改此变量</span></span><br><span class="line"><span class="keyword">auto</span> multiply_x = [&amp;x](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a * x; &#125;;<span class="comment">// 引⽤捕捉x，lambda</span></span><br><span class="line"><span class="comment">// 表达式可以修改此变量</span></span><br><span class="line"><span class="comment">// 输出：20 100</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 3</span></span><br><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> count = std::<span class="built_in">count_if</span>(v.<span class="built_in">beigin</span>(), v.<span class="built_in">end</span>(), [val](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; </span><br><span class="line">val; &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>[]：默认不捕获任何变量；</p><p>[=]：默认以值捕获所有变量；</p><p>[&amp;]：默认以引⽤捕获所有变量；</p><p>[x]：仅以值捕获x，其它变量不捕获；</p><p>[&amp;x]：仅以引⽤捕获x，其它变量不捕获；</p><p>[=, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引⽤捕获；</p><p>[&amp;, x]：默认以引⽤捕获所有变量，但是x是例外，通过值捕获；</p><p>[this]：通过引⽤捕获当前对象（其实是复制指针）；</p><p>[*this]：通过传值⽅式捕获当前对象；</p></blockquote><h3 id="其它-🌮"><a class="header-anchor" href="#其它-🌮"></a>其它 🌮</h3><h4 id="分布式相关知识"><a class="header-anchor" href="#分布式相关知识"></a>分布式相关知识</h4><p>分布式系统中的通信方式有哪些？</p><blockquote><ul><li><strong>消息传递</strong>：节点之间通过发送和接收消息进行通信。</li><li><strong>远程过程调用（RPC）</strong>：允许程序调用远程节点上的函数或方法。</li><li><strong>共享存储</strong>：节点通过共享的存储系统进行数据交换。</li></ul></blockquote><p><strong>什么是一致性问题？</strong></p><blockquote><p>一致性问题指在分布式系统中，多个副本的数据状态需要保持一致。常见的一致性模型包括：</p><ul><li><strong>强一致性</strong>：所有读操作都能看到最新的写操作结果。</li><li><strong>弱一致性</strong>：系统不保证读操作能看到最新的写操作结果。</li><li><strong>最终一致性</strong>：在没有新更新的情况下，所有副本最终会达到一致状态</li></ul></blockquote><p><strong>分布式系统中的负载均衡是什么？</strong></p><blockquote><p>负载均衡是将工作负载均匀分配到多个节点上的技术，以提高系统的性能和可靠性。常见的负载均衡算法包括：</p><ul><li><strong>轮询（Round Robin）</strong>：依次将请求分配给每个节点。</li><li><strong>最小连接数（Least Connections）</strong>：将请求分配给当前连接数最少的节点。</li></ul></blockquote><p><strong>分布式系统中的故障处理有哪些策略？</strong></p><blockquote><ul><li><strong>容错（Fault Tolerance）</strong>：通过冗余设计和备份来应对节点故障。</li><li><strong>重试机制</strong>：在操作失败时自动重试，以应对暂时性故障。</li><li><strong>故障检测和恢复</strong>：检测故障节点并自动恢复服务</li></ul></blockquote><p><strong>分布式系统中的一致性协议有哪些？</strong></p><blockquote><ul><li><strong>Paxos</strong>：一种广泛使用的分布式一致性协议，保证在部分节点故障情况下仍能达成一致。</li><li><strong>Raft</strong>：一种相对易于理解和实现的一致性协议，提供领导选举和日志复制机制。</li></ul></blockquote><p><strong>什么是CAP定理？</strong></p><blockquote><p>CAP定理指出，在分布式系统中，无法同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）。在设计系统时，必须在这三者之间进行权衡。通常选择分区容忍性，然后在一致性和可用性之间做出取舍</p></blockquote><p><strong>分布式系统中的事务处理如何实现？</strong></p><blockquote><p>分布式事务处理需要确保跨多个节点的操作要么全部成功，要么全部失败。常见模型包括：</p><ul><li><strong>两阶段提交（2PC）</strong>：协调者首先请求所有参与者准备提交，然后在所有参与者准备好后发出提交命令。</li><li><strong>三阶段提交（3PC）</strong>：在两阶段提交基础上增加一个预提交阶段，以提高容错性。</li></ul></blockquote><h3 id="例题-📘"><a class="header-anchor" href="#例题-📘"></a>例题 📘</h3><h4 id="区别对比与特性"><a class="header-anchor" href="#区别对比与特性"></a>区别对比与特性</h4><p>C++与C区别<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">^{7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><ol><li><strong>面向对象支持</strong>：C++是一种面向对象的编程语言，支持类封装、继承、多态等面向对象的特性。而C语言则是一种面向过程的编程语言，没有直接支持面向对象的特性。</li><li>扩展性和封装性：C++可以实现数据与方法的封装，继承和多态，C语言相对简单，更适合于较小规模的项目或者需要对硬件进行底层操作的场景。</li><li><strong>标准库</strong>：C标准库主要提供了基本输入输出、字符串处理等功能函数。而C++标准库除了包含了所有C标准库函数外，还添加了对面向对象特性（如容器、算法）的支持，以及更重要的STL库</li><li><strong>异常处理机制</strong>：C++引入了异常处理机制，而C语言没有内置的异常处理机制，错误通常通过返回特定值或使用全局变量来处理。</li><li>编译器支持：C++编译器一般也可以编译C代码，因为C++是在C的基础上发展起来的。但是C编译器不一定能够完全支持C++语法和特性</li></ol></blockquote><p>C++与C#区别<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mtext>补充</mtext></msup></mrow><annotation encoding="application/x-tex">^{补充}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">补充</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p><strong>运行环境：</strong></p><p>C#通常运行在托管环境中，例如.NET Framework或.NET Core。它依赖于CLR（Common Language Runtime）来执行代码，并使用CIL（Common Intermediate Language）作为中间语言</p><p>C++可以编译为本地机器代码，不依赖于特定的运行时环境</p><p><strong>内存管理：</strong></p><p>C#具有自动垃圾回收机制，开发人员不需要手动释放内存。CLR会周期性地检查不再使用的对象，并自动释放它们所占用的内存</p><p>C++需要手动管理内存，开发人员需要显式地分配和释放内存，避免内存泄漏和野指针等问题</p><p><strong>跨平台：</strong></p><p>C#通过.NET Core实现了跨平台支持</p><p>C++本身是跨平台的，可以通过适当的编译器和工具链在各种平台上进行开发和运行</p><p><strong>标准库和框架：</strong></p><p>前者STL库，后者.NET框架库</p></blockquote><p>C++11的新特性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">^{9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>智能指针、<code>nullptr</code>、右值引用、类型推导、范围<code>for</code>循环、<code>final</code>、<code>override</code>、<code>lambda</code>、委托构造、静态assertion</p></blockquote><p>C++的特性<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">^{7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>上面二者合并</p></blockquote><p>C++的执行过程</p><blockquote><p>加载程序：操作系统的加载器（Loader）将负责从磁盘读取可执行文件的内容。这个过程包括将程序的代码和数据加载到进程的地址空间中</p><p>动态链接：加载DLL</p><p>设置运行环境：初始化程序所需的任何系统资源（如文件句柄和网络连接），设置堆（heap）和栈（stack）空间等</p><p>执行入口点：加载和链接完成后，操作系统将控制权传递给程序的入口点，这通常是 <code>main</code> 函数</p><p>程序执行</p><p>清理与退出</p></blockquote><p>C++有啥不好的地方</p><blockquote><p>复杂性、内存管理、标准库较小、错误信息难以理解</p></blockquote><h4 id="关键字"><a class="header-anchor" href="#关键字"></a>关键字</h4><p><code>const</code>的作用是什么</p><blockquote><p>对被修饰对象进行限定，在初始化后对象在后续过程中不能进行修改操作，类似于将其视作常量。</p><p>其有4种修饰类型：修饰变量、修饰指针、修饰引用、修饰函数</p><p>特殊的：底层<code>const</code>和顶层<code>const</code></p></blockquote><p><code>define</code>和<code>const</code>区别</p><blockquote><p><strong><code>#define</code></strong>：在预处理阶段处理，将所有的宏名称直接替换</p><p><strong><code>const</code></strong>：用于定义常量变量，编译时处理的</p><p><strong><code>#define</code></strong>：由于宏只是简单的文本替换，没有类型信息，它们不是类型安全的</p><p><strong><code>const</code></strong>：能够执行类型检查</p><p><strong><code>#define</code></strong>：没有作用域的概念，其作用范围从定义点到文件末尾，或者到被 <code>#undef</code> 指令取消。</p><p><strong><code>const</code></strong>：常量具有确定的作用域，通常在它被声明的块中</p><p><strong><code>#define</code></strong>：宏不分配内存，它仅仅是替换文本</p><p><strong><code>const</code></strong>：常量变量实际上是存储在内存</p></blockquote><p><code>const</code>和<code>constexpr</code>的区别</p><blockquote><p><strong><code>const</code></strong>：常量的值在运行时确定，</p><p><strong><code>constexpr</code></strong>：必须在编译时就能确定其值。</p></blockquote><p><code>static</code>关键字的作用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><code>static</code>介绍一下用于成员函数呢？全局变量使用static作用域？<code>static</code>修饰的变量放在哪里，函数中修饰的static变量呢？</p><blockquote><p><strong>范围限定</strong>：当 <code>static</code> 用于全局变量或函数时，它限制了这些变量或函数的作用域，仅限于定义它们的文件</p><p><strong>生命周期修改</strong>：保持变量内容的持久（<code>static</code>变量中的记忆功能和全局生存期）存储在<strong>静态数据区</strong>，会在程序刚开始运行时就完成初始化，共有两种变量存储在静态存储区：全局变量和<code>static</code>变量，只不过和全局变量比起来，<code>static</code>可以控制变量的可见范围</p><p><strong>静态类成员</strong>：类成员，类函数</p></blockquote><p><code>new</code>和<code>malloc</code>的区别<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p><code>new</code>:</p><p>类型安全，编译时进行类型检查</p><p><code>new</code> 分配内存并调用构造函数</p><p>无须指定内存块的大小，编译器会根据类型信息自行计算</p><p><code>new</code>返回目标对象类型的指针</p><p><code>malloc</code>:</p><p>类型不安全，需要显式类型转换</p><p><code>malloc</code> 只分配内存，不调用构造函数</p><p>显式地指出所需内存的大小</p><p><code>malloc</code>返回<code>void</code>的指针</p></blockquote><p><code>new</code>内部调用<code>malloc</code>具体是怎么调用的</p><blockquote><ol><li><p>调用名为 <code>operator new</code> 的函数，该函数负责分配内存。这个函数通常使用 <code>malloc</code> 来分配所需的内存，但也可以被重载以使用其他内存分配策略</p></li><li><p><code>new</code> 使用该内存地址作为对象的存储位置，并在此地址上调用构造函数</p></li></ol></blockquote><p><code>malloc</code>实现机制</p><blockquote><p><code>malloc</code>其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块</p></blockquote><p><code>new</code> 和<code>delete</code> 的区别</p><blockquote><p><code>new</code> 分配内存并调用构造函数</p><p><code>delete</code> 调用析构函数并释放内存</p></blockquote><p><code>delete</code> 和<code>free</code>的不同</p><blockquote><p><code>delete</code>:</p><p><code>delete</code> 调用析构函数并释放内存</p><p>拥有类型安全与错误处理</p><p><code>free</code>：</p><p>显式地指出所需内存的大小</p><p>接受任何类型的 <code>void*</code> 指针，不进行类型检查</p></blockquote><p><code>this</code>指针能被<code>delete</code> 吗</p><blockquote><p>可以，但是需要谨慎</p></blockquote><p><code>inline</code>函数</p><blockquote><p>内联函数是C++中的一种函数声明方式，它告诉（<strong>建议</strong>）编译器在调用函数时将函数的代码插入到调用处，而不是像普通函数那样通过跳转执行…</p></blockquote><p>include&lt;&gt;和“”的区别</p><blockquote><ol><li><strong>尖括号 <code>&lt;...&gt;</code></strong>：这种方式主要用于引入标准库或第三方库的头文件。编译器将从标准库的安装路径开始搜索，通常这些路径是在编译器配置中预设的。不会搜索源文件的相对路径或当前文件目录。</li><li><strong>双引号 <code>&quot;...&quot;</code></strong>：这种方式主要用于引入项目内部的头文件或用户自定义的头文件。编译器首先会在包含该 <code>#include</code> 指令的源文件的当前目录下搜索头文件，如果没有找到，编译器则会转而从标准库的路径搜索，就像尖括号一样</li></ol></blockquote><p><code>volitale</code></p><p>编译器不会对volitale变量的读取和写入进行优化，每次需要读取或写入这个变量时，都会直接从内存中读取或写入数据，而不是使用寄存器中的缓存值</p><p>C++中的类型转换<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p><code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpret_cast</code></p></blockquote><p><code>dynamic_cast</code>是否安全？（在面试官的指导下，我知道了它是安全的！如果两个不相关的指针之间发生类型转换的话就会返回NULL，并抛出异常）</p><p>C中<code>struct</code>与C++中<code>class</code>的区别，为什么C++中两者都有</p><blockquote><p>二者区别在于默认访问控制权限以及<code>sizeof</code>运算结果</p></blockquote><h4 id="指针与引用"><a class="header-anchor" href="#指针与引用"></a>指针与引用</h4><p>指针和引用的区别<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有<code>const</code>和⾮ <code>const</code>区别，甚⾄可以为空，<code>sizeof</code>指针得到的是指针类型的⼤⼩。</p><p>引⽤来说，它只是⼀块内存的<strong>别名</strong>，在添加到符号表的时候，是将&quot;引⽤变量名-引⽤对象的地址&quot;添加到符号表中，符号表⼀经完成不能改变，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 <code>const</code> 和⾮<code>const</code>区别。</p><ul><li>指针是一个变量，存储地址，引用是<strong>内存地址别名</strong></li><li>指针可以有多级，引用只有一级</li><li>指针可以为空，引用必须初始化</li><li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li><li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以</li></ul></blockquote><p>指针传递和引用传递的区别</p><blockquote><p><strong>指针传递</strong>是通过传递变量地址的方式来让函数访问原始数据。函数参数是指针类型，这意味着函数接收一个内存地址，通过这个地址可以修改原始变量的值；实际传递给函数的是变量地址的副本。这意味着，函数内部可以通过指针访问和修改外部变量的值。</p><p><strong>引用传递</strong>是通过将参数声明为引用类型来实现的，这使得函数参数成为调用者提供的变量的别名；实际传递的是变量的别名（或引用），而不是副本。这意味着函数内的任何修改都会直接反映到原始数据上</p></blockquote><p>右值引用解决什么问题</p><blockquote><p>右值引用能够绑定到一个临时将要被销毁的对象上，避免不必要复制，提升程序性能，</p><p>同时还能将右值引用的对象的资源移动到另外的对象中去【移动语义】，</p><p>使得资源转移更加高效。允许函数模板以透明的方式转发参数，保持原有的左值或右值属性【完美转发】</p></blockquote><p>引用是什么，返回值是引用时会怎么样？如果返回值是引用类型，可以return 一个局部变量吗？</p><blockquote><p>用是对另一个变量（对象）的直接引用，相当于该变量的别名，一旦初始化后不可更改</p><p>返回局部变量的引用是危险的，因为局部变量的生命周期仅限于其声明的函数内。一旦函数执行完毕，局部变量占用的栈内存会被释放，此时返回的引用将指向不再有效的内存。这就产生了<strong>悬挂引用</strong>，其后续使用可能导致未定义行为，如程序崩溃或数据损坏。<em>如果需要通过引用返回函数内部的数据，应确保数据的生命周期超过函数的作用域</em></p></blockquote><p>什么是野指针\空指针</p><blockquote><p>野指针是指未初始化的指针。其指向的内存地址是不确定的，因为它没有被明确初始化为NULL或指向有效的内存地址</p><p>悬空指针是指向了一块已经被释放的内存的指针。当使用例如<code>free</code>或<code>delete</code>操作释放了一块内存之后，原本指向那块内存的指针就成了悬空指针</p></blockquote><h4 id="STL"><a class="header-anchor" href="#STL"></a>STL</h4><p>STL库</p><blockquote><p>C++标准库的一个重要部分，提供了一系·列预定义的模板类和函数</p><p><strong>容器</strong>：数据结构，容器通过迭代器暴露其元素，使得算法可以操作这些元素</p><p><strong>迭代器</strong>：访问容器的泛型指针，让用户通过特定的接口访问容器的数据，不需要了解容器内部底层数据结构</p><p><strong>算法</strong>：数据操作方式</p><p><strong>函数对象（仿函数）</strong>：函数对象是重载了函数调用操作符（<code>()</code>）的类实例。STL中的函数对象可以用作算法的某些操作，如定义比较行为（<code>less</code>，<code>greater</code>等），定义算法作用与容器的行为。</p><p><strong>适配器</strong>：可以修改或扩展迭代器、容器和仿函数的行为，使其能够以新的方式被算法使用或操作。</p><p><strong>空间配置器</strong>：在更底层被容器使用来管理内存分配的，但它通常对于 STL 的使用者是透明的，除非需要自定义内存管理行为。<strong>【可以作为说是STL优化策略】</strong>【堆中申请内存】</p></blockquote><p>STL有哪些容器区别是什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列式容器: string,vector,array,deque,list,forward_list</span></span><br><span class="line"><span class="comment">//容器适配器: stack,queue,priority_queue</span></span><br><span class="line"><span class="comment">//关联式容器: </span></span><br><span class="line"><span class="comment">//红黑树结构：map,set,multimap,multiset</span></span><br><span class="line"><span class="comment">//哈希结构：unordered_map,unordered_set,unordered_multimap,unordered_multiset</span></span><br></pre></td></tr></table></figure><p>STL好处</p><blockquote><p>代码重用、泛型编程、高性能、易于使用和维护</p></blockquote><p><code>vector</code>底层原理、<code>vector</code>的使用以及扩容</p><blockquote><p>参看2.2.1</p></blockquote><p>问<code>vector</code>是否线程安全</p><blockquote><p><code>vector</code> 本身并不是线程安全的，如果是多线程只读情况是安全的，但是一旦涉及到存在写操作则需要使用同步机制来防止数据竞争</p></blockquote><p><code>vector</code>和<code>list</code>的区别<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>参看2.3.1</p></blockquote><p><code>vector</code>的<code>emplace_back</code>为什么比<code>push_back</code>高效</p><blockquote><p>参看2.2 QA</p></blockquote><p><code>vector</code>，<code>list</code>，<code>deque</code>的底层，使用场景</p><blockquote><p>2.2.1 2.2.2 2.2.3</p></blockquote><p>如果要在一个循环中将<code>vector</code>中的奇数位元素全部删除，应该怎么做，要注意什么</p><blockquote><p>如果正向去删除将会有迭代器失效问题，使用反向迭代器从容器末尾进行迭代会好点</p></blockquote><p><code>map</code>/<code>set</code>底层原理</p><blockquote><p>2.2.4 2.2.5</p></blockquote><p><code>unordered_map </code>的原理</p><blockquote><p>2.2.8</p></blockquote><p><code>unordered_map</code>和传统98的<code>map</code>有啥区别？(这里说的就是<code>map</code>)</p><blockquote><p><strong><code>std::map</code></strong>（在C++98中引入）底层通常实现为红黑树，这是一种自平衡的二叉搜索树。由于这种结构的特性，<code>std::map</code> 中的元素总是按照键的顺序（使用比较函数排序）来存储和访问。</p><p><strong><code>std::unordered_map</code></strong>（在C++11中引入）使用哈希表作为其底层结构。它通过哈希函数来确定元素的存储位置，因此元素的存储顺序是无序的</p></blockquote><p><code>unordered_map</code>的key是一个自定义的复合类型，需要做啥操作？（这里我真的无能为力。。。其实这个问题还是涉及到函数重载的内容）</p><blockquote><ol><li>由于 <code>std::unordered_map</code> 使用哈希表来存储元素，你需要为自定义类型提供一个哈希函数</li><li><code>std::unordered_map</code> 还需要能够比较键是否相等。因此，你的自定义类型需要能够支持等价比较（通常通过重载 <code>operator==</code> 实现）</li></ol></blockquote><p>通过下标访问<code>map</code>这个元素，那么这个元素不存在会对<code>map</code>有啥影响？</p><blockquote><p>添加该元素</p></blockquote><p><code>set</code>和<code>map</code>使用的是什么数据结构存储，追问红黑树结构是什么</p><blockquote><p>红黑树？</p><p>RBT是二叉排序树，但是没有AVL树限制严格</p><ul><li>中所有节点非红即黑。</li><li>根节点必为黑节点。</li><li>红节点的子节点必为黑（黑节点子节点可为黑）</li><li><strong>从根到叶子的任何路径上黑结点数相同</strong></li><li>O(log2n) 查询</li></ul></blockquote><p>二叉树相关的树</p><blockquote><p>AVL、RB、B、B+</p></blockquote><p>哈希表及原理</p><blockquote><p>使用哈希函数组织数据以支持快速插入、删除和查找操作的数据结构，它是一种通过把关键码值映射为唯一键值，然后存到表中一个位置来访问记录的方法。</p></blockquote><p>如何解决哈希表的冲突问题、散列表的解决冲突的方案有哪些</p><blockquote><p>线性探测、再散列、开链法</p></blockquote><p>STL用到的模板？（我不清楚，简单的介绍一下模板是什么，怎么用）</p><blockquote><p>3.12</p></blockquote><blockquote><p>STL广泛使用了类模板和函数模板来实现其各种容器、迭代器、算法和函数适配器。</p><ul><li><strong>容器模板</strong>：如<code>std::vector&lt;T&gt;</code>, <code>std::list&lt;T&gt;</code>, <code>std::map&lt;Key, Value&gt;</code>等，这些模板允许创建存储任何特定类型的容器。</li><li><strong>迭代器模板</strong>：STL提供了多种迭代器模板，例如<code>std::vector&lt;T&gt;::iterator</code>或<code>std::map&lt;Key, Value&gt;::iterator</code>，它们支持对容器进行有效的遍历和元素访问。</li><li><strong>算法模板</strong>：STL的算法如<code>std::sort</code>, <code>std::find</code>等是以模板函数的形式实现的，它们可以工作在任何容器的迭代器上，对容器进行操作。</li><li><strong>函数对象和适配器模板</strong>：例如<code>std::function</code>和<code>std::bind</code>，这些高级工具允许更灵活地处理函数和方法。</li></ul></blockquote><p>STL中的算法？（我是一脸懵，简要的回答了各类容器的算法？<code>find</code>函数？仿函数）</p><blockquote><p><code>find count search sort</code>列举即可，也可以说Numeric Algorithms的<code>accumulate</code>等</p></blockquote><p><code>sort()</code>是怎么进行排序的</p><blockquote><p>在SGI STL中的函数<code>sort</code>使用的排序算法其实就是内省式的排序算法。快排的递归层次过深的时候，很可能会退化成O(n^2)。内省式排序使用k来控制快排的递归深度，当快排的递归深度到达k的时候选择使用<code>heap</code>排序。</p></blockquote><p>讲一下常用的排序算法和他们的时间复杂度</p><p><img src="https://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_3.png" alt=""></p><p>STL插入大量数据性能调优</p><blockquote><p>选择合适的容器</p><p>对于<code>std::vector</code>和<code>std::deque</code>，使用<code>reserve()</code>方法预先分配足够的内存可以减少因扩容而产生的重复内存分配和元素复制</p><p>批量插入数据</p><p><code>emplace()</code>而非<code>push_back()</code>或<code>insert()</code>，可以在容器中直接构造对象，避免了额外的复制或移动操作</p><p>利用C++11引入的移动语义，可以通过<code>std::move()</code>在插入大对象时避免复制开销，直接将资源从源对象转移到容器中的新对象</p></blockquote><p>数组和链表的区别<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>参看<code>vector</code>和<code>list</code>区别</p></blockquote><p>栈和队的区别<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">^{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>，实际开发的过程中有哪里会用到栈和队列</p><p>用队列实现栈、用栈实现队列</p><blockquote><p>使用两个队列（<code>queue1</code> 和 <code>queue2</code>）可以实现一个栈的所有操作。主要思想是使用一个队列来存储栈的所有元素（保持栈的顺序），另一个用于在执行操作时帮助重新排列元素</p><p>使用两个栈（<code>stack1</code> 和 <code>stack2</code>）可以实现一个队列的所有操作。这里的主要思想是使用一个栈来处理入队操作，另一个栈来处理出队和获取队首元素的操作</p></blockquote><h4 id="智能指针-v2"><a class="header-anchor" href="#智能指针-v2"></a>智能指针</h4><p>C++智能指针特性、原理、使用、作用；追问智能指针有几种；为什么要使用智能指针、优缺点</p><blockquote><p>智能指针</p><p>C++中的智能指针是一种用于自动管理动态分配（堆分配）内存的类模板，主要目的是为了防止内存泄漏，简化内存管理。这些智能指针通过自动化资源管理（RAII，Resource Acquisition Is Initialization）的方式，确保在对象（智能指针）生命周期结束时，自动释放其管理的资源</p><p>类型</p><p><code>std::unique_ptr</code> <code>std::shared_ptr</code> <code>std::weak_ptr</code></p><p>为什么用</p><ol><li><strong>自动内存管理</strong>：智能指针自动释放所管理的内存，减少内存泄漏的风险。</li><li><strong>异常安全</strong>：在异常发生时，智能指针确保资源被适时释放，增强程序的稳定性。</li><li><strong>简化资源管理</strong>：智能指针避免了手动管理内存的复杂性，使代码更加简洁和安全。</li><li><strong>所有权语义清晰</strong>：通过 <code>unique_ptr</code> 和 <code>shared_ptr</code> 的使用，代码中的所有权和生命周期更加明确</li></ol><p>优缺点</p><ol><li><p><strong>减少内存泄漏</strong>：自动管理内存生命周期。</p></li><li><p><strong>简化代码</strong>：减少手动删除内存的需要。</p></li><li><p><strong>提高安全性</strong>：通过管理权限和所有权，提高代码的安全性。</p></li><li><p><strong>性能开销</strong>：<code>shared_ptr</code> 使用引用计数机制，这可能引入额外的性能开销。</p></li><li><p><strong>循环引用问题</strong>：<code>shared_ptr</code> 之间的循环引用可以导致内存泄漏，需要通过 <code>weak_ptr</code> 解决。</p></li><li><p><strong>复杂度</strong>：对于简单应用，智能指针可能增加不必要的复杂度</p></li></ol></blockquote><p>多线程下的智能指针会出什么问题</p><blockquote><p>线程安全：</p><p><code>std::shared_ptr </code>在多线程中使用时是线程安全的，指针的复制和销毁（修改引用计数）是原子操作(引用计数修改是线程安全的)。但是，对象的读写不是线程安全的，需要用户自己保证。yinyt<br><code>std::unique_ptr</code> 和 <code>std::weak_ptr </code>不是线程安全的。如果需要在多线程环境中传递 <code>unique_ptr</code>，通常需要额外的同步机制，如互斥锁。<br>性能问题：</p><p>频繁地修改 <code>shared_ptr</code>（尤其是创建和销毁）会涉及到原子操作，这在高并发场景下可能成为性能瓶颈。<br>死锁风险：</p><p>使用智能指针容易引起死锁，特别是当两个或多个线程在没有适当顺序的情况下，相互等待对方释放智能指针控制的资源时。</p></blockquote><p>智能指针相关的<code>auto_ptr</code>为什么被废除，引入的三个智能指针底层还有一些关系</p><blockquote><p>C++98 引入的一种智能指针,可以自动管理动态分配（使用 <code>new</code>）的对象的生命周期，以避免内存泄漏,当 <code>std::auto_ptr</code> 的实例离开作用域时，它会自动删除所管理的对象. 由于缺陷建议被3大智能指针替代</p><p><code>std::auto_ptr</code> 的主要问题:</p><ol><li><strong>所有权转移</strong>：<code>std::auto_ptr</code> 在进行拷贝或赋值时，会发生所有权的转移。这意味着原 <code>std::auto_ptr</code> 会失去对对象的所有权（变为 <code>nullptr</code>），而新的 <code>std::auto_ptr</code> 获得所有权。这种行为很容易导致意外的所有权转移，造成资源管理上的困惑。</li><li><strong>容器兼容性</strong>：由于所有权转移的行为，<code>std::auto_ptr</code> 不能安全地用于标准容器（如 <code>std::vector</code>、<code>std::list</code> 等）。尝试存储 <code>std::auto_ptr</code> 的拷贝在容器中会导致未定义行为，因为容器操作经常需要元素的复制和赋值。</li><li><strong>多线程问题</strong>：<code>std::auto_ptr</code> 没有考虑到多线程环境中的安全性问题。其设计不包含对并发访问的保护，这在多线程程序中可能会导致数据竞争和其他同步问题。</li></ol></blockquote><p><code>std::weak_ptr</code>指针原理</p><blockquote><p><code>std::weak_ptr</code> 是 C++ 标准库中的一种智能指针，它设计用来解决 <code>std::shared_ptr</code> 可能引起的循环引用问题。<code>std::weak_ptr</code> 不对其指向的对象拥有所有权，也就是说，它的存在不会增加对象的引用计数。这使得 <code>std::weak_ptr</code> 可以安全地引用由 <code>std::shared_ptr</code> 管理的对象，而不会阻止该对象被适时销毁。</p><p><code>std::weak_ptr</code>和<code>std::shared_ptr</code>源码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_EXPORT_STD <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> : <span class="keyword">public</span> _Ptr_base&lt;_Ty&gt;;</span><br><span class="line">_EXPORT_STD <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weak_ptr</span> : <span class="keyword">public</span> _Ptr_base&lt;_Ty&gt;;</span><br></pre></td></tr></table></figure><p><code>std::weak_ptr</code> 的工作原理主要依赖于与 <code>std::shared_ptr</code> 共享底层的控制块（control block）。控制块包含了两个关键的计数器：</p><ol><li><strong>引用计数（Reference Count）</strong>：这个计数器追踪有多少个 <code>std::shared_ptr</code> 实例正在指向该对象。只要这个计数不为零，对象就不会被销毁。</li><li><strong>弱引用计数（Weak Count）</strong>：这个计数器追踪有多少个 <code>std::weak_ptr</code> 实例正在引用该对象的控制块。这包括由 <code>std::shared_ptr</code> 创建的所有 <code>std::weak_ptr</code> 实例。</li></ol><p>当最后一个指向对象的 <code>std::shared_ptr</code> 被销毁时，对象将被析构，但其控制块不会被释放，直到最后一个与之相关的 <code>std::weak_ptr</code> 也被销毁。这确保了即使对象已被删除，<code>std::weak_ptr</code> 依然可以安全地访问控制块来检查对象是否还存在。</p></blockquote><p><code>std::shared_ptr</code>怎么析构的</p><blockquote><p>减少控制块中关联对象引用计数</p><p>检查引用技术，如果是0则对象销毁</p><p>销毁对象释放内存</p><p>减少控制块中弱引用计数</p><p>检查弱引用计数，如果是0则控制块也销毁</p></blockquote><p><code>std::unique_ptr</code>是不是不能进行赋值，需要赋值的话，应该怎么操作</p><blockquote><p><code>std::unique_ptr</code> 的复制构造函数和复制赋值操作符都被显式删除，这防止了智能指针的复制行为。试图复制 <code>std::unique_ptr</code> 将导致编译错误。</p><p><code>std::unique_ptr</code> 支持移动语义。它的移动构造函数和移动赋值操作符是有效的，并且当一个 <code>std::unique_ptr</code> 被另一个 <code>std::unique_ptr</code> “移动”时，资源的所有权会从源指针转移到目标指针。源指针在操作后将变为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass created\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>; <span class="comment">// 创建一个unique_ptr管理MyClass实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;MyClass&gt; up2 = up1; // 编译错误，不能复制</span></span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;MyClass&gt; up3 = std::<span class="built_in">move</span>(up1); <span class="comment">// 使用std::move进行资源转移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!up1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;up1 is now empty\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><code>std::shared_ptr</code>怎么实现</p><blockquote><p>智能指针由2部分组成：控制块&amp;对应智能指针操作</p><p>控制块：</p><ul><li><strong>引用计数</strong>：追踪有多少个 <code>std::shared_ptr</code> 指向同一个对象。</li><li><strong>弱引用计数</strong>：追踪有多少个 <code>std::weak_ptr</code> 指向同一个控制块。</li><li><strong>对象指针</strong>：指向被管理的对象。</li><li><strong>删除器</strong>：一旦引用计数降到0，这个函数或函数对象会被调用来销毁对象和释放资源。</li><li><strong>分配器</strong>：用于控制块和对象内存分配的分配器。</li></ul><p>对应智能指针的操作：</p><ul><li><strong>构造函数</strong>：可以通过直接指定一个对象指针来构造 <code>std::shared_ptr</code>。构造时，会创建一个新的控制块。</li><li><strong>复制构造函数和赋值运算符</strong>：这些操作会增加控制块中的引用计数，但是<code>std::unique_ptr</code>是<code>delete</code>了这个部分</li><li><strong>移动构造函数和赋值运算符</strong>：这些操作会将资源从一个 <code>std::shared_ptr</code> 转移给另一个，不增加引用计数。</li><li><strong>析构函数</strong>：减少引用计数，并在计数达到0时销毁对象和释放资源</li></ul></blockquote><p><code>std::unique_ptr</code>和<code>auto_ptr</code>之间的区别</p><blockquote><p>所有权语义：</p><p><code>std::auto_ptr</code> 拷贝或赋值操作可以将资源的所有权从一个 <code>std::auto_ptr</code> 转移给另一个 <code>std::auto_ptr</code></p><p><code>std::unique_ptr</code> 明确地使用移动语义，只允许通过移动构造函数和移动赋值操作符进行所有权的转移</p><p>容器兼容性：</p><p><code>std::auto_ptr</code>其拷贝时移动的语义，不能安全地用在标准容器中</p><p><code>std::unique_ptr</code>可以安全地存储在标准容器中</p><p>删除器自定义：</p><p><code>std::auto_ptr</code> 不支持自定义删除器，这限制了其用途，尤其是在需要对资源进行特殊清理时。</p><p><code>std::unique_ptr</code> 支持自定义删除器，用户可以指定在对象生命周期结束时调用的特定函数，这为资源管理提供了更大的灵活性</p></blockquote><p><code>std::unique_ptr</code>有拷贝构造函数和赋值构造函数吗？（有的！我回答错了，不过面试官提示了一下）</p><p><code>std::unique_ptr</code>不能复制的实现细节</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;)            = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></blockquote><p>如何安全地生成其他额外的 std::shared_ptr 实例</p><p>使用<code>std::enable_shared_from_this&lt;T&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">std::shared_ptr&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Bad</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Bad::~Bad() called&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 错误的示例，每个shared_ptr都认为自己是对象仅有的所有者</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Bad&gt; <span class="title">bp1</span><span class="params">(<span class="keyword">new</span> Bad())</span></span>;</span><br><span class="line">std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;<span class="built_in">getptr</span>();</span><br><span class="line"><span class="comment">// 打印bp1和bp2的引用计数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;bp1.use_count() = &quot;</span> &lt;&lt; bp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;bp2.use_count() = &quot;</span> &lt;&lt; bp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行出现错误，不能这样做，因为2个非共享的shared_ptr指向同一对象，未增加引用计数导致对象被析构了2次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Good</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Good&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">Good</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Good::~Good()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::shared_ptr&lt;Good&gt; gp1 = std::<span class="built_in">make_shared</span>&lt;Good&gt;();</span><br><span class="line">std::shared_ptr&lt;Good&gt; gp2 = gp1-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;gp1.use_count() = &quot;</span> &lt;&lt; gp1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;gp2.use_count() = &quot;</span> &lt;&lt; gp2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样才是正确做法</span></span><br></pre></td></tr></table></figure><p>因为在异步调用中，存在一个保活机制，异步函数执行的时间点我们是无法确定的，然而异步函数可能会使用到异步调用之前就存在的变量。为了保证该变量在异步函数执期间一直有效，我们可以传递一个指向自身的share_ptr给异步函数，这样在异步函数执行期间share_ptr所管理的对象就不会析构，所使用的变量也会一直有效了（保活）</p><p>函数可以返回<code>unique_ptr</code>对象,为什么？</p><p>因为<code>unique_ptr</code>支持<code>copy</code>语义，所以可以从函数中返回<code>unique_ptr</code>对象</p><p>智能指针是异常安全的吗？</p><p>是</p><h4 id="面向对象相关"><a class="header-anchor" href="#面向对象相关"></a>面向对象相关</h4><h5 id="设计模式"><a class="header-anchor" href="#设计模式"></a>设计模式</h5><p>设计模式六大原则</p><blockquote><p>单一职责原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则、迪米特法则</p></blockquote><p>设计模式了解吗<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">^{7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>，讲讲比较了解的（我回答了，单例，工厂，修饰器，观察者，以及上述模式简单的定义，没深入展开）</p><blockquote><p>举例</p><p>工厂模式：</p><p>工厂模式是一种创建型模式，用于创建对象，而不需要指定创建对象的具体类</p><p>单例模式：</p><p>单例模式确保一个类只有一个实例，并提供一个全局访问点来访问这个实例</p><p>生成器模式：</p><p>生成器模式是一种创建型设计模式，允许逐步构建复杂对象的不同部分</p><p>原型模式：</p><p>原型模式是创建型设计模式之一，它通过复制一个已存在的实例来返回对象，而不是新建实例</p><p>适配器模式：<br>适配器模式是一种结构型设计模式，它允许两个不兼容的接口之间可以一起工作。适配器做为一个转换器，捕捉对一个对象的调用，并将这些调用转换成另一个对象可以识别的调用</p></blockquote><p>简单说一下工厂模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>、几种工厂模式的区别</p><blockquote><p>工厂模式：</p><p>工厂模式是一种创建型模式，用于创建对象，而不需要指定创建对象的具体类</p><p>工厂模式通过定义一个用于创建对象的接口，让子类决定实例化哪一个类。该模式的核心在于，类的实例化推迟到其子类。工厂模式主要用于创建单个类型的对象</p><p>抽象工厂模式提供了一个接口，用于创建一系列相关或依赖对象的家族，而不需要指定具体类。这个模式通常用于创建产品族，并且要保证客户端始终只使用同一个产品族中的对象</p></blockquote><p>单例模式？单例模式使用场景，实现</p><blockquote><p>单例模式：</p><p>单例模式确保一个类只有一个实例，并提供一个全局访问点来访问这个实例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程不安全 - 懒汉模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line"><span class="type">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; pa) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; pa) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程安全 - 懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line"><span class="type">static</span> Singleton* instance;</span><br><span class="line"><span class="type">static</span> mutex mtx;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; pa) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; pa) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">mutex Singleton::mtx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line"><span class="type">static</span> Singleton* instance;</span><br><span class="line"><span class="type">static</span> mutex mtx;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; pa) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; pa) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">mutex Singleton::mtx;</span><br></pre></td></tr></table></figure><h5 id="虚函数-v2"><a class="header-anchor" href="#虚函数-v2"></a>虚函数</h5><p>虚函数了解吗？介绍下虚函数；虚函数的作用是什么，具体讲讲<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">^{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>通过在函数声明前添加<code>virtual</code>关键字来定义虚函数。虚函数允许派生类重写（<code>override</code>）基类中的成员函数，<strong>实现运行时多态</strong></p></blockquote><p>虚函数的底层实现；追问在继承中子类虚函数表生成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>虚函数实现C++的运行时多态，而vptr和vtable是实现C++的多态特征的底层机制</p><p>剩余内容参考3.9.2</p><p>继承中的虚函数表</p><p>当涉及到继承时，虚函数表的处理变得更加复杂，具体过程取决于是否有新的虚函数被引入以及虚函数是否被覆盖。以下是详细的步骤：</p><ol><li><strong>无新虚函数，无覆盖</strong>：<ul><li>如果派生类没有引入新的虚函数，也没有重写基类的任何虚函数，则派生类可以直接使用基类的虚函数表。</li></ul></li><li><strong>覆盖基类虚函数</strong>：<ul><li>如果派生类重写（覆盖）了基类的虚函数，派生类的虚函数表将包含指向新实现的指针，替换掉原有函数的位置。这保证了通过基类指针调用虚函数时，能够执行到派生类中的覆盖版本。</li></ul></li><li><strong>引入新的虚函数</strong>：<ul><li>如果派生类引入了新的虚函数，这些新函数会被添加到虚函数表的末尾。派生类的虚函数表首先包含指向从基类继承的所有虚函数（包括被覆盖的和未被覆盖的）的指针，随后是新增虚函数的指针。</li></ul></li></ol></blockquote><p>虚函数和纯虚函数区别</p><blockquote><p>虚函数是允许在派生类中被重写的函数。它在基类中用 <code>virtual</code> 关键字声明，通常在基类中提供一个实现。当通过基类的指针或引用调用一个虚函数时，将执行调用对象的实际类型对应的函数版本，这是多态行为的基础。</p><p>纯虚函数是在基类中声明但不提供实现的虚函数。纯虚函数的声明以 <code>= 0</code> 结束，表明派生类必须重写该函数才能实例化对象。含有纯虚函数的类称为抽象类，<strong>不能直接实例化</strong>。纯虚函数主要用于定义接口规范，强制派生类遵循特定的接口设计。</p></blockquote><p>虚函数与普通函数有什么区别</p><blockquote><p>多态性；实现机制；效率性能；语法声明；</p></blockquote><p>构造和构析函数能不能写为虚函数</p><blockquote><p>构造不可以，析构可以</p><p>原因参考3.9.3</p></blockquote><p>构造函数和析构函数可以调用虚函数吗</p><blockquote><p>effective c++: <strong>绝不在构造和析构过程中调用虚函数</strong></p><p>语法上讲可以，但不推荐这种做法</p><ul><li>父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编【<strong>构造函数和析构函数调用虚函数时都不使用动态联编</strong>】</li><li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数</li></ul><p>《Effective C++》的解释是： 派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型</p><ul><li>在构造函数中调用虚函数,调用的是当前<strong>正在构造</strong>的类的版本,而不是最终的重写版本</li><li>在析构函数中调用虚函数,调用的是当前<strong>正在析构</strong>的类的版本,而不是原始的基类版本</li></ul></blockquote><p>虚继承\虚继承为了解决什么问题？</p><blockquote><p>虚继承通过引入虚基类来解决菱形继承问题。在虚继承中，无论基类被继承了多少次，派生类中只会包含一个基类的实例</p></blockquote><p>虚继承的内存模型长啥样？</p><blockquote><ol><li>虚基类表，内置指向虚基类的指针：<code>Derived</code> 类将包含指向虚基类 <code>Base</code> 的指针。这通常是通过一个或多个虚基类表实现的</li><li>虚函数表中放置虚基类的偏移量：每个继承 <code>Base</code> 的类都可能需要存储一个偏移量，来确定 <code>Base</code> 类的实际位置。这是因为虚基类的具体位置可能由于最派生类的布局而有所不同。</li></ol></blockquote><p>example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">v</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">w</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> d;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">y</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |   <span class="number">32</span> (vbase_offset)   |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">d --&gt; +----------+    |            |         B::<span class="built_in">w</span>()        |</span><br><span class="line">      |  vtptr   |----+            +-----------------------+</span><br><span class="line">      +----------+                 |         D::<span class="built_in">y</span>()        |</span><br><span class="line">      |pad  |b   |                 +-----------------------+</span><br><span class="line">      +----------+                 |   <span class="number">16</span> (vbase_offset)   |</span><br><span class="line">      |  vtptr   |---------+       +-----------------------+</span><br><span class="line">      +----------+         |       |    <span class="number">-16</span> (top_offset)    |</span><br><span class="line">      |  d  | c  |         |       +-----------------------+</span><br><span class="line">      +----------+         |       | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">      |  vtptr   |----+    +-----&gt; +-----------------------+</span><br><span class="line">      +----------+    |            |         C::<span class="built_in">x</span>()        |</span><br><span class="line">      | pad | a  |    |            +-----------------------+</span><br><span class="line">      +----------+    |            |    <span class="number">0</span> (vbase_offset)   |</span><br><span class="line">                      |            +-----------------------+</span><br><span class="line">                      |            |   <span class="number">-32</span> (top_offset)    |</span><br><span class="line">                      |            +-----------------------+</span><br><span class="line">                      |            | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">                                   |         A::<span class="built_in">v</span>()        |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line"><span class="comment">// top_offset 表示this指针对子类的偏移，用于子类和继承类之间dynamic_cast转换（还需要typeinfo数据），实现多态</span></span><br><span class="line"><span class="comment">// vbase_offset 表示this指针对基类的偏移，用于共享基类</span></span><br><span class="line"><span class="comment">// 虚函数表地址的前面设置了一个指向type_info的指针，RTTI（Run Time Type Identification）运行时类型识别是有编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI是为多态而生成的信息，所以只有具有虚函数的对象在会生成。</span></span><br></pre></td></tr></table></figure><h5 id="模板-v2"><a class="header-anchor" href="#模板-v2"></a>模板</h5><p>模板了解么</p><blockquote><p>模板是C++中实现泛型编程的工具，它允许程序员编写与数据类型无关的代码，函数模板和类模板构成</p><p>参考3.12</p></blockquote><p>虚函数和模板有什么区别，分别适合什么</p><blockquote><ul><li>虚函数实现的是运行时多态，即代码的行为在运行时可以变化。</li></ul><p>用于实现接口和抽象基类，允许派生类定制或替换基类的行为。</p><p>适用于类的设计中需要预留可扩展点，以支持未来的功能扩展或修改。</p><p>在设计模式中频繁使用，如策略模式、工厂模式等。</p><ul><li>模板实现的是编译时多态，即代码在编译时根据提供的类型参数被实例化和优化。</li></ul><p>用于创建可重用的算法和容器，如标准模板库（STL）中的 <code>vector</code>、<code>map</code>、<code>sort</code> 等。</p><p>适用于需要处理多种数据类型但执行相同操作的情况，提高代码重用性和灵活性。</p><p>非常适合用于库的设计，用户可以定制数据类型而无需修改库代码。</p></blockquote><p>用过模板函数吗？你用模板解决啥问题？</p><p>假设你设计的模板能够适用于大部分场景，但是有些场景不适用，你咋做？（模板具体化）</p><blockquote><p>完全模板特化</p><p>完全模板特化是指为一个模板提供一个专门的定义，这个定义针对特定的完全指定的模板参数。当模板的所有参数都被具体化时，这种特化就会被使用。</p><p>模板偏特化</p><p>模板偏特化允许开发者特化模板的一部分参数，而不是全部参数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全特化 - 语法</span></span><br><span class="line"><span class="comment">// template&lt;&gt; // 注意特化时使用空的模板参数列表</span></span><br><span class="line"><span class="comment">// class TemplateClass&lt;T1, T2&gt; &#123; ... &#125;; // 特化定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化 - 示例</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">swap</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span>&amp; a, <span class="type">char</span>&amp; b) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Swapping chars\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 偏特化 - 语法</span></span><br><span class="line"><span class="comment">// template&lt;typename T1, typename T2&gt;</span></span><br><span class="line"><span class="comment">// class TemplateClass&lt;T1, T2*&gt; &#123; ... &#125;; // 偏特化定义，特化第二个参数为指针类型</span></span><br><span class="line"><span class="comment">// 偏特化 - 示例</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T* content;</span><br><span class="line">    <span class="comment">// 特化的成员函数定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数重载怎么重载？对于重载方法来说，如果输入参数一样而返回类型不一样的函数是否能重载？</p><blockquote><ol><li><strong>相同的函数名</strong>：所有重载函数必须使用相同的函数名。</li><li>不同的参数列表<ul><li>参数的类型不同；</li><li>参数的数量不同；</li><li>参数的顺序不同（如果类型也不相同）。</li></ul></li></ol><p>注意，仅返回类型的不同不足以构成重载。此外，函数的参数必须有足够的差异，以便编译器可以根据传递的参数确定调用哪个函数。</p></blockquote><p>假设有三个函数，函数名相同，普通函数，具体化函数，非具体化模板函数，那么调用顺序怎么搞？</p><blockquote><p>普通函数（非模板函数）-具体化的模板函数（显式特化）-非具体化的模板函数（泛型模板）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Normal function: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体化的模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span> x) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized template function for double: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非具体化模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Generic template function: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="封装继承多态"><a class="header-anchor" href="#封装继承多态"></a>封装继承多态</h5><p>面向对象和面向过程的区别</p><table><thead><tr><th></th><th>OOP</th><th>POP</th></tr></thead><tbody><tr><td>概念</td><td>将问题分解成一系列步骤或称之为过程的操作序列。编程的焦点是在执行具体任务的过程和函数</td><td>将问题分解成一组相互作用的对象，每个对象代表现实世界中的实体或概念。编程的焦点是对象及其交互</td></tr><tr><td>单位</td><td>函数</td><td>类和对象</td></tr><tr><td>适用场景</td><td>较小、单一任务或脚本，尤其是简单的、逻辑线性的任务</td><td>大型的、复杂的系统，特别是需要多次迭代和维护的项目</td></tr><tr><td>实现抽象</td><td>抽象通常限于函数</td><td>支持较高级别的抽象，如类抽象和多态</td></tr></tbody></table><p>介绍一下C++的封装，继承，多态</p><blockquote><p>3.17</p></blockquote><p>C++中的多态怎么理解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">^{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>、怎么体现出多态的、如何实现多态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">^{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>运行时多态4.6.2 与 编译时多态4.6.3</p><p>理解：</p><p>编译时多态（静态多态）</p><p>编译时多态，又称为静态多态，是通过模板（包括类模板和函数模板）和函数重载实现的。这种多态在编译时就已经确定，不依赖于运行时信息。</p><ol><li><strong>模板</strong>：模板通过允许同一个函数或类操作不同的数据类型来实现多态。编译器根据传入的实际类型参数生成对应的函数或类实例。<ul><li><strong>函数模板</strong>：可以根据不同类型自动生成对应的函数版本。</li><li><strong>类模板</strong>：类似地，可以生成处理不同数据类型的类实例。</li></ul></li><li><strong>函数重载</strong>：通过定义多个同名函数但参数类型不同来实现多态。编译器根据函数调用时提供的参数类型来决定调用哪个函数。</li></ol><p>运行时多态（动态多态）</p><p>运行时多态，又称为动态多态，主要通过虚函数来实现，这依赖于运行时信息。动态多态允许在运行时选择调用哪个函数，这是通过继承和虚函数实现的。</p><ol><li><strong>虚函数</strong>：在基类中声明虚函数，允许在派生类中重写。这种机制确保了当通过基类的指针或引用调用函数时，能够调用到派生类中的对应函数。</li><li><strong>抽象基类和纯虚函数</strong>：通过定义纯虚函数（即没有实现的虚函数，用 <code>= 0</code> 标记）使得基类成为抽象类，这样的类不能被实例化，只能被用作接口和继承基础。</li><li><strong>多态的使用场景</strong>：例如，设计一个图形界面库，可以有一个基类 <code>Shape</code>，派生出 <code>Circle</code>、<code>Rectangle</code> 等。通过基类的指针操作不同的派生类对象，调用相应的 <code>draw()</code> 方法，可以在不知道具体类型的情况下工作。</li></ol></blockquote><p><code>override</code>与重写的区别</p><blockquote><p>重载是多态的一种形式，它允许你在同一作用域内为相同的函数名定义多个版本，但这些版本的参数列表必须不同（参数的类型、个数或顺序至少有一个不同）。重载的选择是在编译时进行的，这种方式也称为静态多态。</p><p>重写是另一种多态形式，指的是在派生类中重新定义基类中有相同名称和参数列表的虚拟函数。重写只能发生在继承关系的类之间，它允许派生类改变基类中某个虚拟函数的行为。重写发生的多态是运行时的，也称为动态多态。</p></blockquote><p>C++中的封装怎么理解、封装<code>class</code>类的作用</p><blockquote><p>信息隐藏</p></blockquote><p><code>protect</code>变量继承后派生类访问权限？类中的<code>public</code>变量，<code>private</code>变量怎么理解呢？</p><p>父类可以继承子类吗</p><blockquote><p>不可</p></blockquote><p>多级继承</p><p>析构函数、构造函数还有复制构造函数什么时候会被调用</p><p>拷贝构造函数；复制构造函数和=号赋值的区别</p><blockquote><ul><li><strong>拷贝构造函数</strong>：用于创建新的对象作为另一个对象的副本；初始化新对象。</li><li><strong>赋值运算符</strong>：用于将一个对象的状态赋给另一个已经存在的对象；更新已存在对象的状态。</li></ul></blockquote><h4 id="多线程-进程"><a class="header-anchor" href="#多线程-进程"></a>多线程\进程</h4><p>多线程了解吗？线程与进程介绍一下 ；并且二者区别<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">^{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>、多线程与多进程应用场景</p><table><thead><tr><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>定义</td><td>资源分配和拥有的基本单位</td><td>程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td>切换情况</td><td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td>保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr><td>切换过程</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td>调用栈</td><td>内核栈</td><td>内核栈</td><td>用户栈</td></tr><tr><td>拥有资源</td><td>CPU资源、内存资源、文件资源和句柄等</td><td>程序计数器、寄存器、栈和状态字</td><td>拥有自己的寄存器上下文和栈</td></tr><tr><td>并发性</td><td>不同进程之间切换实现并发，各自占有CPU实现并行</td><td>一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td>系统开销</td><td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td>切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td>通信方面</td><td>进程间通信需要借助操作系统</td><td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table><blockquote><ul><li>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</li><li>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</li><li>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</li><li>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可</li></ul></blockquote><p>C++11 提供了哪些多线程支持功能？</p><blockquote><ul><li><code>std::thread</code>: 用于创建和管理线程。</li><li><code>std::mutex</code>: 用于互斥访问，保护共享数据不被多个线程同时修改。</li><li><code>std::lock_guard</code> 和 <code>std::unique_lock</code>: 自动管理互斥锁的生命周期，简化锁的获取和释放操作。</li><li><code>std::async</code> 和 <code>std::future</code>: 用于异步执行任务并获取结果。</li><li><code>std::condition_variable</code>: 用于线程之间的同步（等待/通知机制）。</li><li><code>std::atomic</code>: 提供原子操作，用于无锁编程。</li></ul></blockquote><p>解释 <code>std::thread</code>, <code>std::mutex</code>和 <code>std::lock_guard</code> 的用法</p><blockquote><p><code>std::thread</code>：</p><p>创建一个 <code>std::thread</code> 对象通常涉及指定一个函数或一个可调用对象以及其参数，该函数或可调用对象将在新线程中执行。一旦线程开始执行，主线程可以选择等待（通过调用<code>join()</code>）或允许线程独立运行</p><p><code>std::mutex</code>：</p><p><code>std::mutex</code> 提供了 <code>lock()</code> 和 <code>unlock()</code> 两个成员函数，用于对互斥锁的直接操作。一个线程在访问共享数据之前必须先调用 <code>lock()</code> 获得互斥锁，完成操作后调用 <code>unlock()</code> 释放锁</p><p><code>std::lock_guard</code>：</p><p><code>std::lock_guard</code> 的基本用途是保护一个代码段，使之在多线程环境下线程安全。当你创建一个 <code>std::lock_guard</code> 对象时，它需要一个互斥锁（通常是 <code>std::mutex</code>）作为参数，并且立即尝试锁定这个互斥锁</p></blockquote><p>使用线程池可能带来哪些风险和有哪些好处（注意C++没有线程池实现）</p><blockquote><p>好处：减少创建和销毁线程的开销与降低系统资源消耗、更好的线程管理和调度</p><p>风险：资源争用和死锁、复杂性增加</p></blockquote><p>线程池参数有哪些；常用的线程池工作队列</p><blockquote><p>无界队列、有界队列、优先级队列、同步队列、延迟队列</p></blockquote><p>多线程的互斥锁</p><blockquote><p>3.20.1</p></blockquote><p>对于多线程的使用，需要注意哪些地方（线程安全，加锁之类的）</p><p>多线程的情况下为什么会发生死锁，列举导致死锁的几种情况</p><blockquote><p>争夺资源而无限等待对方释放资源的情形</p><ol><li>互斥条件</li></ol><p>每个资源要么已经分配给了一个进程，要么就是可用的。这意味着资源不能被共享，只能被一个线程在同一时间内占用。</p><ol start="2"><li>持有并等待</li></ol><p>进程至少持有一个资源，并且正在等待获取额外的被其他进程持有的资源。</p><ol start="3"><li>非抢占条件</li></ol><p>资源只能由持有它们的进程在完成其任务后主动释放，不能被强制抢占。</p><ol start="4"><li>循环等待</li></ol><p>存在一种进程或线程的循环链，链中的每个进程或线程都在等待下一个进程或线程所持有的资源。</p></blockquote><p>条件变量，信号量的实现及对同步的理解</p><blockquote><p>条件变量：<br>条件变量用于线程间的同步，它允许一个或多个线程在某些条件不满足时挂起，直到其他线程改变条件并通知条件变量。它通常与 <code>std::mutex</code> 一起使用</p><p>信号量的实现：（C++20）<br>信号量是一个同步对象，用于控制多个线程对共享资源的访问。它可以用来实现资源的互斥使用，通过限制资源的同时访问数量</p><p>同步的理解：</p><p>同步是多线程编程中保证数据一致性和避免竞争条件的关键。通过使用互斥锁、条件变量、信号量等同步原语，可以控制线程之间的执行顺序，确保当一个线程访问共享数据或资源时其他线程不能同时访问，从而维护数据的一致性和完整性。</p></blockquote><p>进程间通信方式</p><blockquote><p>管道、共享内存、消息队列、套接字、信号、信号量</p></blockquote><p>线程间通信方式，线程怎么通信</p><blockquote><p>共享内存、条件变量、消息队列</p></blockquote><p><code>pthread_create</code>、<code>join</code>作用</p><blockquote><p><code>pthread_create</code> 函数用于创建一个新的线程。这个函数四个参数分别是：</p><ol><li><strong>线程指针</strong>：指向一个 <code>pthread_t</code> 类型的变量，该变量用于存储新创建线程的标识符。</li><li><strong>线程属性</strong>：指定线程的属性（如堆栈大小等），如果设置为 <code>NULL</code>，线程将使用默认属性。</li><li><strong>启动例程</strong>：一个函数指针，指向线程将要执行的函数。</li><li><strong>参数</strong>：传递给启动例程的参数，可以是指向任何类型的指针。</li></ol><p>创建线程成功时，<code>pthread_create</code> 返回 <code>0</code>；失败时，返回错误码。</p><p><code>pthread_join</code> 函数用于等待一个线程的终止。这是线程同步的一种方式，类似于 C++11 中的 <code>std::thread::join</code>。使用 <code>pthread_join</code> 可以防止主线程（或任何调用 <code>join</code> 的线程）继续执行，直到被等待的线程结束。</p><p><code>pthread_join</code> 接受两个参数：</p><ol><li><strong>线程标识符</strong>：要等待的线程的 <code>pthread_t</code> 标识符。</li><li><strong>返回值指针</strong>：指向一个指针的指针，用于接收线程的返回值。如果不关心返回值，可以设置为 <code>NULL</code>。</li></ol><p>当线程成功结束时，<code>pthread_join</code> 返回 <code>0</code>；如果发生错误，返回错误码</p></blockquote><h4 id="编译与链接"><a class="header-anchor" href="#编译与链接"></a>编译与链接</h4><p>C++编译过程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">^{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>**预处理阶段：**在这个阶段，预处理器处理源文件中的预处理指令，比如 <code>#include</code>、<code>#define</code> 等。预处理器会根据这些指令展开头文件并替换宏定义，生成一个经过预处理的源文件.ii</p><p>**编译阶段：**编译器将预处理后的源文件转换成汇编代码。在这个阶段，编译器会对源文件进行词法分析、语法分析和语义分析，<strong>并生成相应的中间代码或汇编代码 .s</strong></p><p>**汇编阶段：*<em>汇编器将汇编代码转换成机器码或者目标文件。在这个阶段，汇编器会将汇编代码转换成*<em>可重定位的机器码，并生成目标文件 .o</em></em></p><p><strong>链接阶段：链接器将目标文件和库文件链接</strong>在一起，生成最终的可执行文件。在这个阶段，链接器会解析目标文件之间的引用关系，将它们连接到正确的位置上，<strong>并将库文件中的函数和变量链接到可执行文件中</strong>，.out</p></blockquote><h4 id="静态与动态-v2"><a class="header-anchor" href="#静态与动态-v2"></a>静态与动态</h4><p>静态库与动态库的区别</p><blockquote><p>静态库</p><ul><li><strong>定义</strong>：静态库（如 <code>.a</code> 文件在 Unix/Linux 或 <code>.lib</code> 文件在 Windows）是一组预编译的代码，这些代码在编译期间被整合到最终的可执行文件中。</li><li>优点<ul><li>因为所有代码都在一个单一的可执行文件中，所以运行时不需要依赖外部的库文件，这简化了部署。</li><li>可以有选择地链接程序中用到的代码，有助于优化最终的应用程序大小。</li></ul></li><li>缺点<ul><li>更新或修复库中的函数需要重新编译和发布整个应用程序。</li><li>应用程序的大小会因为包含整个库而增加，尤其是当链接多个大型静态库时。</li></ul></li></ul><p>动态库</p><ul><li><strong>定义</strong>：动态库（如 <code>.so</code> 文件在 Unix/Linux 或 <code>.dll</code> 文件在 Windows）包含可以被多个程序共享的代码和数据。</li><li>优点<ul><li>可以在不重新编译整个应用的情况下更新库文件。</li><li>多个应用程序可以共享同一份库的副本，节省系统资源。</li></ul></li><li>缺点<ul><li>运行程序时需要确保动态库可用，否则程序无法运行。</li><li>动态库的版本管理和依赖可能会导致“地狱依赖”问题。</li></ul></li></ul></blockquote><p>静态编译和动态编译</p><blockquote><p>静态编译和动态编译通常指的是程序在编译和链接库文件时的方式：</p><p>静态编译</p><ul><li><strong>定义</strong>：静态编译指的是在编译期间将所有需要的库代码直接整合到可执行文件中。</li><li>特点<ul><li>结果是一个不依赖于外部库文件的独立可执行文件。</li><li>适用于需要高可携带性和简化部署的场景。</li></ul></li></ul><p>动态编译</p><ul><li><strong>定义</strong>：动态编译指的是在编译时，程序只是记录下所需库的引用，并不将其整合进可执行文件中。</li><li>特点<ul><li>可执行文件在运行时依赖动态链接库。</li><li>允许应用程序在不重新编译的情况下利用库的更新。</li></ul></li></ul></blockquote><p>静态成员和这个静态函数跟普通成员和普通函数有什么区别</p><blockquote><p>1.1</p></blockquote><h4 id="内存问题"><a class="header-anchor" href="#内存问题"></a>内存问题</h4><p>内存分区，C++内存管理，C++内存模型，C++的内存分配，C++的内存分布模型，C++程序的内存情况，，内存管理，分别存放什么，C++内存分布，不同变量怎么存储，C++内存管理机制，各内存区放了什么数据，C++内存控制有没有了解？知道C++内存是怎么分配的吗</p><blockquote><p>3.5</p></blockquote><p><code>const</code>存放在哪里</p><blockquote><p>1.2</p><ul><li><strong>全局或静态 <code>const</code> 变量</strong>：通常放在只读数据段。</li><li><strong>局部 <code>const</code> 变量</strong>：可能会存放在栈上，与其他局部变量一样</li></ul></blockquote><p>平时项目中有遇到过内存泄漏么？知不知道用什么设计模式来避免这个问题（不会233，讲了一下只知道C++有智能指针）</p><blockquote><p>RAII、工厂、单例</p></blockquote><p>C++ 为什么会发生内存泄漏，怎么避免内存溢出，内存泄露是什么意思，怎么避免内存泄露，如何观察定位</p><blockquote><p>3.6</p></blockquote><p>堆内存和栈内存？什么样的内存在堆上，什么样的内存在栈上？C++对于内存的分配（堆/栈）？内存类型啥的，记不清问题了（我回答了内存从低地址到高地址的内存分布，代码区，数据区，BSS区，堆，共享区，栈，系统内核区）</p><p>内存对齐的规则</p><blockquote><p>数据对齐：起始位置的偏移量必须是该变量类型大小的整数倍</p></blockquote><p>C++内存模式，如何修改Text 段，常量段和代码段的值如何才能修改</p><blockquote><p>Text 一般不修改，直接修改 Text Segment 通常会导致程序崩溃</p></blockquote><h4 id="内存模型"><a class="header-anchor" href="#内存模型"></a>内存模型</h4><p>内存模型是指如何管理和访问内存的规则和机制。C++内存模型涉及内存分配、存储持续性、作用域、访问权限和多线程内存访问等方面</p><h5 id="内存分区模型"><a class="header-anchor" href="#内存分区模型"></a>内存分区模型</h5><blockquote><p>3.5 内存分配情况</p><ul><li><strong>栈（Stack）</strong>：<ul><li>用于存储函数的局部变量、参数和返回地址。</li><li>由系统自动分配和释放，速度快但容量有限。</li><li>栈的大小通常在程序启动时确定，典型值是几MB到几十MB。</li></ul></li><li><strong>堆（Heap）</strong>：<ul><li>用于动态分配内存，如使用<code>new</code>和<code>delete</code>进行分配和释放。</li><li>由程序员管理，适合存储生命周期不确定的大块内存。</li><li>堆的大小由系统的可用内存决定，通常比栈大。</li></ul></li><li><strong>自由存储区（Free Store）</strong>：<ul><li>一般情况下，堆和自由存储区是同一个区域。</li><li>C++标准库的分配器（allocator）在自由存储区上进行操作。</li></ul></li><li><strong>全局/静态区（Global/Static Area）</strong>：<ul><li>用于存储全局变量和静态变量，在程序生命周期内存在。</li><li>包括已初始化的全局/静态变量和未初始化的全局/静态变量（BSS段）。</li></ul></li><li><strong>常量区（Constant Area）</strong>：<ul><li>用于存储常量和字符串字面量。</li><li>常量区的内容在程序运行时通常是只读的。</li></ul></li></ul></blockquote><h5 id="内存分配和管理"><a class="header-anchor" href="#内存分配和管理"></a>内存分配和管理</h5><blockquote><ul><li><strong>栈分配</strong>：<ul><li>由编译器自动管理，函数调用时分配，函数返回时释放。</li><li>使用的是LIFO（后进先出）策略。</li></ul></li><li><strong>堆分配</strong>：<ul><li>使用<code>new</code>分配内存，使用<code>delete</code>释放内存。</li><li>动态分配的内存需要手动管理，容易导致内存泄漏。</li></ul></li><li><strong>静态分配</strong>：<ul><li>在程序加载时分配，程序退出时释放。</li><li>全局变量和静态变量属于此类。</li></ul></li></ul></blockquote><h5 id="内存模型和多线程模型"><a class="header-anchor" href="#内存模型和多线程模型"></a>内存模型和多线程模型</h5><blockquote><p>在C++11之前，内存模型并未正式标准化，导致不同平台上的行为可能不一致。C++11引入了一个正式的内存模型来解决这一问题，特别是多线程环境下的内存访问问题。</p><ul><li><strong>顺序一致性（Sequential Consistency）</strong>：<ul><li>默认的内存访问顺序，所有操作按照程序顺序执行。</li><li>保证所有线程都能看到一致的内存状态。</li></ul></li><li><strong>内存顺序（Memory Order）</strong>：<ul><li>C++11提供了原子操作和内存顺序控制（<code>memory_order</code>），如<code>memory_order_relaxed</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code>、<code>memory_order_acq_rel</code>和<code>memory_order_seq_cst</code>。</li><li>这些内存顺序控制可以优化多线程性能，提供更细粒度的内存可见性和同步控制。</li></ul></li><li><strong>原子操作（Atomic Operations）</strong>：<ul><li>C++11引入了<code>std::atomic</code>库，用于原子操作，避免数据竞争。</li><li>原子操作是不可中断的，多个线程对原子变量的操作不会产生竞争条件。</li></ul></li></ul></blockquote><h5 id="内存对齐（Memory-Alignment）"><a class="header-anchor" href="#内存对齐（Memory-Alignment）"></a>内存对齐（Memory Alignment）</h5><blockquote><p>对齐要求：</p><p>不同类型的数据在内存中的对齐方式不同，通常要求地址是类型大小的整数倍。<br>对齐可以提高访问速度，因为大多数CPU在处理对齐数据时更高效。<br>填充字节（Padding Bytes）：</p><p>为了满足对齐要求，编译器会在结构体和类中插入填充字节，导致内存浪费。<br>自定义对齐：</p><p>使用alignas关键字可以自定义数据的对齐方式。</p></blockquote><h5 id="内存泄漏和智能指针"><a class="header-anchor" href="#内存泄漏和智能指针"></a>内存泄漏和智能指针</h5><blockquote><ul><li><strong>内存泄漏（Memory Leak）</strong>：<ul><li>未释放的动态分配内存会导致内存泄漏，程序长时间运行可能耗尽系统内存。</li></ul></li><li><strong>智能指针（Smart Pointers）</strong>：<ul><li>C++11引入了智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>）来自动管理动态内存，减少内存泄漏的风险。</li><li>智能指针通过RAII（资源获取即初始化）机制，在超出作用域时自动释放内存</li></ul></li></ul></blockquote><h4 id="动态链接库"><a class="header-anchor" href="#动态链接库"></a>动态链接库</h4><p>什么是动态链接库（.dll）？与静态链接库（.lib）区别</p><blockquote><p>动态链接库（DLL）是包含可以被多个程序共同使用的代码和数据的文件</p><p>区别：</p><ol><li><strong>加载时机和方式</strong>：<ul><li><strong>动态链接库（DLL）</strong>：在程序运行时动态加载。操作系统负责加载DLL文件，并在需要时将其映射到内存中。</li><li><strong>静态链接库</strong>：在程序编译时直接整合到最终的可执行文件中，与程序一起加载到内存。</li></ul></li><li><strong>内存和资源共享</strong>：<ul><li><strong>DLL</strong>：允许多个应用程序共享内存中的同一份代码拷贝，减少了内存消耗。</li><li><strong>静态库</strong>：每个使用静态库的应用程序都有一份库的副本，这可能导致更大的可执行文件和更高的内存使用量。</li></ul></li><li><strong>更新和部署</strong>：<ul><li><strong>DLL</strong>：可以独立于应用程序进行更新。只需替换旧的DLL文件即可，不需要重新编译使用它的应用程序。</li><li><strong>静态库</strong>：更新库后，任何使用该库的应用程序都需要重新编译和部署，以包含新的库代码。</li></ul></li></ol></blockquote><p>DLL地狱是什么，如何避免</p><blockquote><p>多个应用程序共享同一个DLL，当其中一个应用程序更新或替换DLL时，可能会导致其他依赖旧版本的应用程序无法正常运行。</p><ol><li><strong>使用侧边加载（Side-by-side Assemblies）</strong>：<ul><li>Windows提供了一个侧边加载机制，允许同一系统上的不同应用程序使用不同版本的相同DLL。这通过在应用程序的清单文件中指定DLL版本来实现。</li></ul></li><li><strong>避免全局注册DLL</strong>：<ul><li>尽可能将DLL局部化，与应用程序一起存放在同一个目录下，而不是注册到全局的系统目录。这可以减少多个应用程序间的DLL冲突</li></ul></li></ol></blockquote><p>如何创建一个DLL</p><p>如何在应用程序中使用DLL</p><blockquote><p>添加引用、包括头文件、调用DLL函数</p></blockquote><p>如何确保DLL的线程安全</p><blockquote><p>避免使用全局或静态数据</p><p>同步访问共享资源</p></blockquote><p>在一个项目中使用多个版本的同一个DLL应该注意什么</p><blockquote><p>使用侧边加载（Side-by-side Assemblies）技术、独立部署DLL、处理DLL间的依赖关系</p></blockquote><h4 id="LINUX"><a class="header-anchor" href="#LINUX"></a>LINUX</h4><p>对Linux系统了解多少，说几个你知道的linux基本指令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></p><p>gdb<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><h4 id="算法-v2"><a class="header-anchor" href="#算法-v2"></a>算法</h4><p>Dfs和bfs区别、bfs 一般会用到什么数据结构（简单的回答了两个的区别，一个递归，一个用队列，还有两个算法适用的题目类型）图的深度优先遍历算法</p><p>时间复杂度空间复杂度知道吗？（跟面试官说勉强清楚，然后说了几个经典的时间复杂度，以及是怎么算的，然后跟面试官说我知道是怎么回事，但到实际用例上可能算不对）</p><p><img src="https://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_3.png" alt=""></p><p>堆排序的原理，快排等排序原理，冒泡排序算法原理</p><blockquote><p>堆排序是一种基于比较的排序技术，它使用二叉堆数据结构来管理元素。二叉堆可以被视为一种完全二叉树，树中每个节点的值都必须大于或等于其子节点的值（最大堆），或者每个节点的值都必须小于或等于其子节点的值（最小堆）</p><p>快速排序是一种高效的排序算法，使用分治法（Divide and Conquer）策略来把一个序列分为两个子序列。</p><p>算法重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来</p></blockquote><p>堆排序稳定吗？为什么堆排序不稳定？时间复杂度？</p><blockquote><p>在提取堆顶元素后，需要执行堆调整（heapify）过程以维护堆的性质。在堆调整过程中，较大的子节点会上移以填补根位置，这个操作可能会进一步打乱原有相等元素的顺序</p></blockquote><p>常见的排序算法有哪些，你觉得哪个算法最快</p><p>介绍一下分治算法</p><blockquote><p>将问题分隔为多个子问题进行分而治之解决，例如快排和归并排序</p></blockquote><p>哈希算法？hashmap解决冲突的方法？怎么避免哈希冲突？怎么保证尽可能均匀分布？</p><blockquote><p>线性探测、再散列、开链法</p><ol><li><strong>使用高质量的哈希函数</strong>：选择或设计能够减少冲突并均匀分布键的哈希函数，例如 MurmurHash、CityHash 或 SHA-256（对于非加密应用来说可能过于复杂和缓慢）。</li><li><strong>动态调整哈希表大小</strong>：根据哈希表的负载因子（即元素总数与位置总数的比率）动态调整哈希表的大小。一旦负载因子超过某个阈值（如0.75），就增加哈希表的大小并重新哈希所有元素。</li><li><strong>使用质数作为表大小</strong>：使用质数作为哈希表的大小可以减少模运算带来的周期性，从而降低冲突。</li></ol></blockquote><h4 id="其它"><a class="header-anchor" href="#其它"></a>其它</h4><p>C++有什么优势</p><p>C++ 哪些运算符不能重载</p><p>C++数组下标越界发生什么</p><p>库函数是什么为什么要引入库函数</p><p>命名空间的作用</p><p>消息队列怎么实现</p><p>软件开发流程</p><blockquote><p><strong>需求分析 --&gt; 概要设计 --&gt; 详细设计 --&gt; 编码 --&gt; 测试 --&gt; 交付 --&gt; 验收 --&gt; 维护</strong></p></blockquote><p>对代码进行过重构，思路，使用过什么工具</p><p>怎么验证你写的代码的可靠性</p><p>问为什么笔试中的第xxx题没有写出来，现在知不知道怎么解决</p><p>epoll优点、epoll和select的区别</p><p>介绍背包问题的原理</p><p>汇编有啥优点</p><p>介绍IO多路复用</p><p>页表（虚拟内存和物理内存的映射，然后说了缺页中断，去物理内存中开辟）</p><p>还提问了怎么防止一个对象new出来</p><blockquote><p>私有化构造函数、删除类的 <code>operator new</code> 和 <code>operator delete</code>，可以禁用动态内存分配、使用单例模式</p></blockquote><p>数据库的事务，四大特性，四大特性的字母分别代表什么</p><p>数据库相关的会吗？数据库了解吗？（什么2张表啥的，听不明白，因为我没系统学过。我跟他说了说索引，事物，锁等等我知道的，然后被打断，应该不是面试官想要的回答）</p><p>计算机网络七层模型，主要协议、mac地址</p><p>socket编程及tcp应用场景</p><p>熟悉哪些协议</p><p>大端和小端</p><p>介绍一下tcp的三次握手和四次挥手</p><p>tcp如何保证可靠性，tcp通过什么保证稳定性，什么情况下会重发？tcp和udp属于哪一层？有什么区别？</p><p>icmp在哪一层</p><p>DHCP了解吗</p><p>网络通信了解过吗</p><h3 id="C-对象模型笔记-🍵"><a class="header-anchor" href="#C-对象模型笔记-🍵"></a>C++对象模型笔记 🍵</h3><p>同时可阅读<a href="https://notes.tanchuanqi.com/_static/attachment/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B_%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.pdf#page=6.06">深度探索C++对象模型笔记</a></p><h4 id="对象部分"><a class="header-anchor" href="#对象部分"></a>对象部分</h4><p>构成</p><blockquote><p>非静态数据成员配置在class object中，静态数据成员存放在class object之外，virtual funcation由单个class生成一个virtual table中的指针vptr指出，vptr由class的构造函数、析构函数运算符完成设定、重置。同样class关联的type_info由virtual table指出</p></blockquote><p><img src="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/article/ref/cpp1.png" alt=""></p><p>继承</p><p>普通继承情况下，C++采用继承模型不运用任何间接性，直接将base部分放置于derived中；</p><p>在virtual继承情况下，C++2.0引入了virtual base class，此处实现有2种，一种是为关联的virtual base class附加指针，其次是导入virtual base class table</p><p>综上一个 <code>class object</code>至少需要非静态数据成员、内存字节padding部分、<code>virtual</code>产生的内存负担三个部分就能够组成；</p><h4 id="构造函数语义学"><a class="header-anchor" href="#构造函数语义学"></a>构造函数语义学</h4><h5 id="Constructor"><a class="header-anchor" href="#Constructor"></a><strong>Constructor</strong></h5><p>什么时候合成default constructor？在<strong>编译器</strong>需要的时候才合成</p><ol><li><strong>类未定义任何构造函数时</strong>：如果一个类没有定义任何构造函数，编译器将自动生成一个默认构造函数。这个构造函数是无参的，且是公有的。</li><li><strong>当类中含有其他对象成员，且这些成员对象都有默认构造函数时</strong>：如果类的成员对象有默认构造函数，编译器将为这个类合成一个默认构造函数，以确保其成员对象可以被正确初始化。</li><li><strong>类中包含默认成员初始化</strong>：从C++11开始，如果类的成员变量在声明时就被赋了初值，即使类中定义了其他构造函数，编译器也会提供一个默认构造函数，这个构造函数将执行这些默认初始化</li><li>如果类中定义了任何构造函数（包括拷贝构造函数和移动构造函数）：<strong>一旦你为类定义了任何构造函数，编译器就假设你将自行管理所有构造函数的定义，包括默认构造函数</strong>。</li><li>如果类含有引用成员或者常量成员而这些成员没有在类定义中初始化：由于引用和常量成员必须在构造函数初始化列表中初始化，编译器不会为这样的类自动生成默认构造函数。</li><li>如果基类的默认构造函数是被删除的或不可访问的：如果一个类继承自的基类没有可访问的默认构造函数，编译器同样不会为派生类自动生成默认构造函数。</li></ol><p>trivial</p><ol><li><strong>没有用户定义的构造函数</strong>：类没有定义任何构造函数，包括拷贝构造函数、移动构造函数等。</li><li><strong>没有虚函数或虚继承</strong>：类没有虚函数，也没有从虚基类继承。也就是说带有 虚函数的类是no-trivial的</li><li><strong>所有成员的默认构造函数都是trivial的</strong>：类的每个成员都必须具有trivial的默认构造函数。</li><li><strong>没有非静态成员初始化</strong>：从C++11开始，成员变量可以在类定义中直接初始化，如果使用了这种初始化方式，即使是基础类型的直接赋值，也会使默认构造函数变为non-trivial。</li><li><strong>没有需要非trivial操作的成员</strong>：比如类中没有包含需要动态内存分配的对象</li></ol><p>no-trivial</p><ul><li>如果类中定义了任何用户定义的构造函数。</li><li>类包含虚函数或通过虚继承。</li><li>类中至少有一个成员的默认构造函数是non-trivial的。</li><li>类使用了非静态成员初始化表达式。</li><li>类包含需要在构造时执行特殊操作的成员，如动态内存分配、文件操作等</li></ul><p>会导致no-trivial的构造函数：带有数据成员的类、带有default class的基类、带有<code>virtual</code>函数的类、带有<code>virtual</code>基类的类</p><blockquote><p>1．任何class 如果没有定义default constructor，就会被合成出一个来<br>2．编译器合成出来的 default constructor会显式设定“class内每一个data member的默认值”<br>都是错误的</p></blockquote><h5 id="Copy"><a class="header-anchor" href="#Copy"></a><strong>Copy</strong></h5><p><strong>什么时候合成copy constructor？</strong></p><p>在<strong>编译器</strong>需要的时候才合成，对于大部分的class 来说，拷贝构造函数仅仅需要按位拷贝就可以。</p><p><strong>什么时候一个 class 不展现出 bitwise copy semantics 呢？</strong></p><p>当 class 内含一个 member object 而后者声明了一个 copy constructor 时</p><p>当 class 继承自一个存在有 copy constructor 的 base class时</p><p>当 class 声明了一个或多个 virtual functions 时</p><p>当 class 派生自一个继承串链，其中一个或多个 virtual base classes 时</p><p><strong>成员初始化列表</strong></p><p>编译器会一一操作初始化列表，把其中的初始化操作以 member 声明的次序在 constructor 内安插初始化操作，并且在任何 explicit user code 之前；初始化列表中的实际执行顺序中 以 member ”声明的次序 来决定的</p><h5 id="Data"><a class="header-anchor" href="#Data"></a><strong>Data</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Cat) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">8</span> <span class="number">8</span> <span class="number">16</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 内存实况</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> Cat       <span class="title">size</span><span class="params">(<span class="number">16</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | +--- (base class B)</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | | &#123;</span>vbptr&#125;</span><br><span class="line">        | +---</span><br><span class="line"> <span class="number">8</span>      | +--- (base <span class="keyword">class</span> C)</span><br><span class="line"> <span class="number">8</span>      | | &#123;vbptr&#125;</span><br><span class="line">        | +---</span><br><span class="line">        +---</span><br><span class="line">        +--- (<span class="keyword">virtual</span> base A)</span><br><span class="line">        +---</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="comment">// 多重继承中，可能会有多个 vptr 指针，视其继承体系而定：派生类中 vptr 的数目最等于所有基类的 vptr 数目的总和</span></span><br></pre></td></tr></table></figure><p><strong>一个对象的内存布局大小（通常由 3 部分组成）：</strong></p><ol><li>其 nonstatic data member 的总和大小；</li><li>任何由于位对齐所需要的填补上去的空间；</li><li>加上了为了支持 virtual 机制而引起的额外负担</li></ol><p><strong>支持多态所带来的 4 个负担</strong></p><p>导入 virtual table 用来存放每一个 virtual functions 的地址</p><p>class object 中安插一个 vptr 指向相应的 vtable</p><p>constructor 中安插代码以正确设置 vptr</p><p>destructor 中安插代码以正确设置 vptr</p><p><strong>类型成员与防御性编程</strong></p><p>对 member functions 本身的分析会直到整个 <code>class </code>的声明都出现了才开始。所以 <code>class </code>的 member functions 可以引用声明在后面的成员；</p><p>但是<code>class </code>中的 <code>typedef </code>并不具备这个性质。因此，类中的 typedef 的影响会受到函数与 <code>typedef </code>的先后顺序的影响, 所以，对于 <code>typedef</code>需要防御性的程序风格：始终把 nested type声明（即 typedef）放在<code>class</code>起始处</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> length;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(length l)</span></span>&#123; cout &lt;&lt; l &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">typedef</span> string length;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(length l)</span></span>&#123; cout &lt;&lt; l &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// f1 绑定的 length 类型是 int; 而 f2 绑定的 length 类型才是 string</span></span><br></pre></td></tr></table></figure><p><strong>vptr会被放在哪</strong>、</p><p>一般被安放在所有被明确声明的 member 的最后，但也有放前面的VC放前面GNU放后面</p><p><strong>Data Member存取</strong></p><p>由一个对象存取一个 member 会比由一个指针存取一个 member 更快捷。但是对于经由一个对象来存取和由一个指针来存取一个静态的 member 来说，是完全一样的，都会被编译器所扩展</p><p><strong>简单来说：当类型 X 是一个继承体系中有虚基类的子类，并且 x 成员又正好是虚基类中的成员时，这<br>两种写法在编译器看来就会有重大的区别了（这种情况下的 offset计算方式不同，其它情况的offset也可以直接算出）。因为 x 的类型是固定的，编译器可以直接进行offset 扩展，但是对于 pt 来说，由于无法确定 pt 指向真正类型，所以只能借由一个执行期的间接来得到成员的具体地址</strong></p><p>指向 Data Members 的指针内部实际保存的是这个 data member 相对于对象起始地址的偏移地址（offset）</p><p><strong>static member存取情况</strong></p><p>经由一个函数调用的结果来存取静态成员，C++标准要求编译器必须对这个函数进行求值，虽然这个求值的结果并无用处；实际上静态成员存放在数据段和类无关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>().static_member = <span class="number">100</span>; =&gt; (<span class="type">void</span>) <span class="built_in">foo</span>();</span><br><span class="line">X::static_member = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>nonstatic member情况</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">origin.y_ = <span class="number">10</span>; =&gt; &amp;origin + (&amp;Point3d::y_ - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>虚拟继承内存布局</strong></p><p>虚拟继承把一个类切割为 2 部分：一个不变局部和一个共享局部:使用一个指针指向虚基类、vbtable 中放置 virtual base class 的 offset</p><p>普通封装不会带来任何执行期的成本，编译器可以轻松优化掉普通封装带来的任何成本。但是一旦涉及到虚拟继承，效率就会大幅降低，</p><h5 id="析构、构造、拷贝"><a class="header-anchor" href="#析构、构造、拷贝"></a>析构、构造、拷贝</h5><p><strong>constructor 会被编译器安插大量的代码，一般而言编译器所做的扩充操作大约如下</strong></p><p>初始化成员：使用 member initialization list 或者调用默认构造函数；</p><p>在那之前，如果 class object 有 vptr，它们必须被正确的设置；</p><p>在那之前，所有的上一层的 base class construcotrs 必须被调用，以 base classes 声明的顺序。使用 member initialization list 或者调用默认构造函数，同时如果 base class是多重继承下的非第 1 基类，还需要调整 this 指针；</p><p>在那之前，所有的 virtual base class constructors 必须被调用，从左到右，从深到浅。并同时设置好 virtual base class 所需要使用的各种机制；</p><p>即处理顺序为：virtual base classes → base class → vptr → member。</p><p><strong>析构</strong></p><p>如果 object 内带有 vptr，那么首先重设相关的 vtable；</p><p>destructor 函数本身现在会被执行，也就是说 vptr 会在程序员的代码执行之前被重设；</p><p>以声明顺序的相反顺序调用 members 的析构函数；</p><p>如果有任何直接的（上一层）nonvirtual base classed 拥有 destructor，那么会以其声明顺序的相反顺序被调用；</p><p>如果有任何 virtual base classes 拥有 destructor，而当前讨论的这个 class 是最尾端的，那么它们会以其原来的构造顺序的相反顺序被调用</p><p>构造函数和析构函数中都不具有多态性：这并不是语言的弱点，而是正确的语意所要求的（因为那个时候的对象不完整）</p><p>由于析构函数中的重设 vptr 会在任何代码之前被执行，这样就保证了在析构函数中也不具有多态性，从而不会用子类的函数。因为此时子类已经不完整了，子类中的成员已经不存在了，而子类的函数有可能需要使用这些成员</p>]]></content>
    
    
    <summary type="html">知识点总结</summary>
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
    <category term="C++" scheme="https://ninokz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://ninokz.github.io/2024/04/24/DesignPatterns/"/>
    <id>https://ninokz.github.io/2024/04/24/DesignPatterns/</id>
    <published>2024-04-24T05:37:04.014Z</published>
    <updated>2024-05-28T03:48:54.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2><blockquote><p>https://refactoringguru.cn/</p></blockquote><p><img src="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/article/ref/design1.png" alt=""></p><p>设计模式六大原则</p><p><strong>单一职责原则（Single Responsibility Principle, SRP）</strong></p><p>单一职责原则指一个类应该只有一个引起它变化的原因。这意味着一个类应该只有一个任务或责任。遵循这个原则可以帮助开发者减少类之间的依赖性，使系统更容易理解和维护。</p><p><strong>开闭原则（Open/Closed Principle, OCP）</strong></p><p>开闭原则指软件实体应当对扩展开放，对修改关闭。这意味着应该能在不修改现有代码的情况下扩展模块的功能，从而使得系统在变化的需求面前保持稳定。通常通过使用接口和抽象类来达到这一目标。</p><p><strong>里氏替换原则（Liskov Substitution Principle, LSP）</strong></p><p>里氏替换原则指如果对每一个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。简单来说，子类在设计时应当可以替换它们的基类，而不改变程序的行为。</p><p><strong>接口隔离原则（Interface Segregation Principle, ISP）</strong></p><p>接口隔离原则指不应该强迫任何客户端依赖于它不使用的方法。一个类对另一个类的依赖应该建立在最小的接口上。这个原则鼓励将大接口拆分成更小和更具体的接口，这样可以减少接口的改变对依赖它们的类的影响。</p><p><strong>依赖倒置原则（Dependency Inversion Principle, DIP）</strong></p><p>依赖倒置原则指设计代码时，高层模块不应该依赖低层模块，两者都应依赖于抽象；抽象不应依赖于细节，细节应依赖于抽象。这个原则用于减少类间的直接依赖关系，通过使用接口或抽象类间接关联（依赖注入是实现这一原则的常用方式）。</p><p><strong>迪米特法则（Law of Demeter, LoD）或最少知道原则</strong></p><p>迪米特法则指一个对象应该对其他对象有尽可能少的了解。通俗来说，一个类应该只和它的直接朋友通信，不与陌生的类随意交互。这有助于降低系统中各类之间的耦合度。</p><h2 id="创建型"><a class="header-anchor" href="#创建型"></a>创建型</h2><h3 id="工厂模式"><a class="header-anchor" href="#工厂模式"></a>工厂模式</h3><h4 id="UML类图"><a class="header-anchor" href="#UML类图"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/factory-method/structure-indexed.png" alt=""></p><blockquote><ol><li><p><strong>产品</strong> （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。</p></li><li><p><strong>具体产品</strong> （Concrete Products） 是产品接口的不同实现。</p></li><li><p><strong>创建者</strong> （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。</p><p>你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。</p><p>注意， 尽管它的名字是创建者， 但它最主要的职责并<strong>不是</strong>创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。</p></li><li><p><strong>具体创建者</strong> （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。</p><p>注意， 并不一定每次调用工厂方法都会<strong>创建</strong>新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。</p></li></ol></blockquote><h4 id="Code"><a class="header-anchor" href="#Code"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">DoStuff</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Creator</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IProduct <span class="title">Create</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">SomeOperation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Creator: The same creator&#x27;s code has just worked with &quot;</span> + Create().DoStuff();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteCreatorA</span> : <span class="title">Creator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IProduct <span class="title">Create</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteCreatorB</span> : <span class="title">Creator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> IProduct <span class="title">Create</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> : <span class="title">IProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">DoStuff</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;ConcreteProductA&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> : <span class="title">IProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">DoStuff</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;ConcreteProductB&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IProduct product = new ConcreteCreatorA().Create();</span></span><br><span class="line"><span class="comment">//Console.WriteLine(product.DoStuff());</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a class="header-anchor" href="#总结"></a>总结</h4><p>工厂依赖产品接口，生产产品，具体工厂与具体产品分别继承工厂和实现产品接口</p><h3 id="抽象工厂模式"><a class="header-anchor" href="#抽象工厂模式"></a>抽象工厂模式</h3><h4 id="UML类图-v2"><a class="header-anchor" href="#UML类图-v2"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/structure-indexed.png" alt=""></p><blockquote><ol><li><strong>抽象产品</strong> （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。</li><li><strong>具体产品</strong> （Concrete Product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。</li><li><strong>抽象工厂</strong> （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。</li><li><strong>具体工厂</strong> （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</li><li>尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的<em>抽象</em>产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 <strong>客户端</strong> （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。</li></ol></blockquote><h4 id="Code-v2"><a class="header-anchor" href="#Code-v2"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列</span></span><br><span class="line"><span class="comment">// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产</span></span><br><span class="line"><span class="comment">// 品可有多个变体，但不同变体的产品不能搭配使用。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">AbstractProductA <span class="title">CreateProductA</span>()</span>;</span><br><span class="line"><span class="function">AbstractProductB <span class="title">CreateProductB</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配</span></span><br><span class="line"><span class="comment">// 使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进</span></span><br><span class="line"><span class="comment">// 行实例化</span></span><br><span class="line"><span class="comment">// 每个具体工厂中都会包含一个相应的产品变体。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">CreateProductA</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">CreateProductB</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">CreateProductA</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">CreateProductB</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">AbstractProductA</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ProductA1</span> : <span class="title">AbstractProductA</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ProductA2</span> : <span class="title">AbstractProductA</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">AbstractProductB</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ProductB1</span> : <span class="title">AbstractProductB</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ProductB2</span> : <span class="title">AbstractProductB</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractProductA abstractProductA = new ConcreteFactory1().CreateProductA();</span></span><br><span class="line"><span class="comment">//AbstractProductB abstractProductB = new ConcreteFactory1().CreateProductB();</span></span><br></pre></td></tr></table></figure><h4 id="总结-v2"><a class="header-anchor" href="#总结-v2"></a>总结</h4><p>抽象工厂生产抽象产品，具体工厂继承抽象工厂，具体产品继承抽象产品</p><h3 id="生成器模式"><a class="header-anchor" href="#生成器模式"></a>生成器模式</h3><h4 id="UML类图-v3"><a class="header-anchor" href="#UML类图-v3"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/builder/structure.png" alt="生成器设计模式结构"></p><blockquote><ol><li><strong>生成器</strong> （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。</li><li><strong>具体生成器</strong> （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。</li><li><strong>产品</strong> （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。</li><li><strong>主管</strong> （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。</li><li><strong>客户端</strong> （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。</li></ol></blockquote><h4 id="Code-v3"><a class="header-anchor" href="#Code-v3"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step1</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step2</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step3</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteA</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteABuilder</span>: <span class="title">IBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> ConcreteA product;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteABuilder</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.product = <span class="keyword">new</span> ConcreteA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConcreteA <span class="title">getResult</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.product = <span class="keyword">new</span> ConcreteA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;ConcreteABuilder step1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;ConcreteABuilder step2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step3</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;ConcreteABuilder step3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteB</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteBBuilder</span>: <span class="title">IBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> ConcreteB product;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteBBuilder</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.product = <span class="keyword">new</span> ConcreteB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConcreteB <span class="title">getResult</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.product = <span class="keyword">new</span> ConcreteB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;ConcreteBBuilder step1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;ConcreteBBuilder step2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">step3</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;ConcreteBBuilder step3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Director</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通</span></span><br><span class="line">    <span class="comment">// 过这种方式改变最新组装完毕的产品的最终类型。主管可使用同样的生成步</span></span><br><span class="line">    <span class="comment">// 骤创建多个产品变体</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConstructA</span>(<span class="params">IBuilder abuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">abuilder.reset();</span><br><span class="line">abuilder.step1();</span><br><span class="line">abuilder.step2();</span><br><span class="line">abuilder.step3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConstructB</span>(<span class="params">IBuilder bbuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">bbuilder.reset();</span><br><span class="line">bbuilder.step1();</span><br><span class="line">bbuilder.step2();</span><br><span class="line">bbuilder.step3();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Director director = new Director();</span></span><br><span class="line"><span class="comment">//ConcreteABuilder abuilder = new ConcreteABuilder();</span></span><br><span class="line"><span class="comment">//ConcreteBBuilder bbuilder = new ConcreteBBuilder();</span></span><br><span class="line"><span class="comment">//director.ConstructA(abuilder);</span></span><br><span class="line"><span class="comment">//ConcreteA concreteA = abuilder.getResult();</span></span><br><span class="line"><span class="comment">//director.ConstructB(bbuilder);</span></span><br><span class="line"><span class="comment">//ConcreteB concreteB = bbuilder.getResult();</span></span><br></pre></td></tr></table></figure><h4 id="总结-v3"><a class="header-anchor" href="#总结-v3"></a>总结</h4><p>具体Builder继承接口Builder，然后由Director使用</p><h3 id="原型模式"><a class="header-anchor" href="#原型模式"></a>原型模式</h3><h4 id="UML类图-v4"><a class="header-anchor" href="#UML类图-v4"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-prototype-cache-indexed.png" alt=""></p><blockquote><ol><li><strong>原型</strong> （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 <code>clone</code>克隆的方法。</li><li><strong>具体原型</strong> （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。</li><li><strong>客户端</strong> （Client） 可以复制实现了原型接口的任何对象。</li></ol></blockquote><h4 id="Code-v4"><a class="header-anchor" href="#Code-v4"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础原型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IPrototype</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeMethod</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">IPrototype <span class="title">Clone</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运</span></span><br><span class="line"><span class="comment">// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生</span></span><br><span class="line"><span class="comment">// 成的克隆对象。这可以保持克隆结果的一致</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteInstance</span> : <span class="title">IPrototype</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IPrototype <span class="title">Clone</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcreteInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">PrototypeManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;IPrototype&gt; prototypes = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddPrototype</span>(<span class="params">IPrototype prototype</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">prototypes.Add(prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IPrototype <span class="title">GetPrototype</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> prototypes[index].Clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-v4"><a class="header-anchor" href="#总结-v4"></a>总结</h4><p>具体原型继承原型接口，再由其他一个类聚合</p><h3 id="单例模式"><a class="header-anchor" href="#单例模式"></a>单例模式</h3><h4 id="UML类图-v5"><a class="header-anchor" href="#UML类图-v5"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/singleton/structure-zh-indexed.png" alt=""></p><blockquote><ol><li><p><strong>单例</strong> （Singleton） 类声明了一个名为 <code>get­Instance</code>获取实例的静态方法来返回其所属类的一个相同实例。</p><p>单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 <code>获取实例</code>方法必须是获取单例对象的唯一方式。</p></li></ol></blockquote><h4 id="Code-v5"><a class="header-anchor" href="#Code-v5"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> lockObject = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">lock</span> (lockObject)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-v5"><a class="header-anchor" href="#总结-v5"></a>总结</h4><p>单例需要注意多线程问题，屏蔽拷贝和构造，留出静态获取实例</p><h2 id="结构型"><a class="header-anchor" href="#结构型"></a>结构型</h2><h3 id="适配器"><a class="header-anchor" href="#适配器"></a>适配器</h3><h4 id="UML类图-v6"><a class="header-anchor" href="#UML类图-v6"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/structure-object-adapter-indexed.png" alt=""></p><blockquote><ol><li><strong>客户端</strong> （Client） 是包含当前程序业务逻辑的类。</li><li><strong>客户端接口</strong> （Client Interface） 描述了其他类与客户端代码合作时必须遵循的协议。</li><li><strong>服务</strong> （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。</li><li><strong>适配器</strong> （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。</li><li>客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。</li></ol></blockquote><p><img src="https://refactoringguru.cn/images/patterns/diagrams/adapter/solution-zh.png" alt=""></p><h4 id="Code-v6"><a class="header-anchor" href="#Code-v6"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target 定义客户端代码使用的特定于域的接口。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITarget</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">GetRequest</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adaptee 包含一些有用的行为，但它的接口是与现有客户端代码不兼容。</span></span><br><span class="line"><span class="comment">// 被适应者需要一些在客户端代码可以使用它之前进行调整</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Adaptee</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetSpecificRequest</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Specific request.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 适配器使被适应者的界面与目标的接口兼容接口。</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Adapter</span> : <span class="title">ITarget</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> Adaptee _adaptee;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span>(<span class="params">Adaptee adaptee</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>._adaptee = adaptee;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetRequest</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">$&quot;This is &#x27;<span class="subst">&#123;<span class="keyword">this</span>._adaptee.GetSpecificRequest()&#125;</span>&#x27;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">daptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">ITarget target = <span class="keyword">new</span> Adapter(adaptee);</span><br><span class="line">Console.WriteLine(target.GetRequest());</span><br></pre></td></tr></table></figure><h4 id="总结-v6"><a class="header-anchor" href="#总结-v6"></a>总结</h4><h3 id="桥接"><a class="header-anchor" href="#桥接"></a>桥接</h3><h4 id="UML类图-v7"><a class="header-anchor" href="#UML类图-v7"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/bridge/structure-zh-indexed.png" alt=""></p><blockquote><ol><li><p><strong>抽象部分</strong> （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。</p></li><li><p><strong>实现部分</strong> （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。</p><p>抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。</p></li><li><p><strong>具体实现</strong> （Concrete Implementations） 中包括特定于平台的代码。</p></li><li><p><strong>精确抽象</strong> （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。</p></li><li><p>通常情况下， <strong>客户端</strong> （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。</p></li></ol></blockquote><p><img src="https://refactoringguru.cn/images/patterns/diagrams/bridge/example-zh.png" alt=""></p><h4 id="Code-v7"><a class="header-anchor" href="#Code-v7"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Abstraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> IImplementation _implementation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span>(<span class="params">IImplementation implementation</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_implementation = implementation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">_implementation.Method1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">_implementation.Method1();</span><br><span class="line">_implementation.Method2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ExtendedAbstraction</span> : <span class="title">Abstraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExtendedAbstraction</span>(<span class="params">IImplementation implementation</span>) : <span class="title">base</span>(<span class="params">implementation</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">_implementation.Method2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IImplementation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method1</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method2</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteImplementationA</span> : <span class="title">IImplementation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;A Method1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;A Method2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteImplementationB</span> : <span class="title">IImplementation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;B Method1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;B Method2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Abstraction abstraction;</span><br><span class="line">abstraction = <span class="keyword">new</span> Abstraction(<span class="keyword">new</span> ConcreteImplementationA());</span><br><span class="line">abstraction.Operation2();</span><br><span class="line"></span><br><span class="line">abstraction = <span class="keyword">new</span> ExtendedAbstraction(<span class="keyword">new</span> ConcreteImplementationB());</span><br><span class="line">abstraction.Operation2();</span><br></pre></td></tr></table></figure><h4 id="总结-v7"><a class="header-anchor" href="#总结-v7"></a>总结</h4><h3 id="组合"><a class="header-anchor" href="#组合"></a>组合</h3><h4 id="UML类图-v8"><a class="header-anchor" href="#UML类图-v8"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/composite/structure-zh-indexed.png" alt=""></p><blockquote><ol><li><p><strong>组件</strong> （Component） 接口描述了树中简单项目和复杂项目所共有的操作。</p></li><li><p><strong>叶节点</strong> （Leaf） 是树的基本结构， 它不包含子项目。</p><p>一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。</p></li><li><p><strong>容器</strong> （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。</p><p>容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。</p></li><li><p><strong>客户端</strong> （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。</p></li></ol></blockquote><h4 id="Code-v8"><a class="header-anchor" href="#Code-v8"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Leaf</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Leaf</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">num = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;Leaf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Composite</span> : <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;Component&gt; children = <span class="keyword">new</span> List&lt;Component&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params">Component component</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">children.Add(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params">Component component</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">children.Remove(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;Composite&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (Component component <span class="keyword">in</span> children)</span><br><span class="line">&#123;</span><br><span class="line">component.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-v8"><a class="header-anchor" href="#总结-v8"></a>总结</h4><h3 id="装饰"><a class="header-anchor" href="#装饰"></a>装饰</h3><h4 id="UML类图-v9"><a class="header-anchor" href="#UML类图-v9"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/structure-indexed.png" alt=""></p><blockquote><ol><li><strong>部件</strong> （Component） 声明封装器和被封装对象的公用接口。</li><li><strong>具体部件</strong> （Concrete Component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。</li><li><strong>基础装饰</strong> （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。</li><li><strong>具体装饰类</strong> （Concrete Decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。</li><li><strong>客户端</strong> （Client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。</li></ol></blockquote><p><img src="https://refactoringguru.cn/images/patterns/diagrams/decorator/solution2-zh.png" alt=""></p><h4 id="Code-v9"><a class="header-anchor" href="#Code-v9"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IComponent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> : <span class="title">IComponent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;ConcreteComponent&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">BaseDecorator</span> : <span class="title">IComponent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> IComponent component;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDecorator</span>(<span class="params">IComponent component</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetComponent</span>(<span class="params">IComponent component</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">component.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> : <span class="title">BaseDecorator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span>(<span class="params">IComponent component</span>) : <span class="title">base</span>(<span class="params">component</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">execute</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">base</span>.execute();</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;ConcreteDecoratorA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> simple = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">simple.execute();</span><br><span class="line">ConcreteDecoratorA decorator1 = <span class="keyword">new</span> ConcreteDecoratorA(simple);</span><br><span class="line">decorator1.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcreteComponent</span></span><br><span class="line"><span class="comment">//Decorating...</span></span><br><span class="line"><span class="comment">//ConcreteComponent</span></span><br><span class="line"><span class="comment">//ConcreteDecoratorA</span></span><br><span class="line"><span class="comment">//ConcreteDecoratorB</span></span><br></pre></td></tr></table></figure><h3 id="外观"><a class="header-anchor" href="#外观"></a>外观</h3><h4 id="UML类图-v10"><a class="header-anchor" href="#UML类图-v10"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/facade/structure-indexed.png" alt=""></p><blockquote><ol><li><p><strong>外观</strong> （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。</p></li><li><p>创建<strong>附加外观</strong> （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。</p></li><li><p><strong>复杂子系统</strong> （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。</p><p>子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。</p></li><li><p><strong>客户端</strong> （Client） 使用外观代替对子系统对象的直接调用。</p></li></ol></blockquote><h4 id="Code-v10"><a class="header-anchor" href="#Code-v10"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Subsystem1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;Subsystem1: Ready!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationN</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;Subsystem1: Go!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Subsystem2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;Subsystem2: Get ready!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationZ</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;Subsystem2: Fire!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Facade</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> Subsystem1 _subsystem1;</span><br><span class="line"><span class="keyword">private</span> Subsystem2 _subsystem2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Facade</span>(<span class="params">Subsystem1 subsystem1, Subsystem2 subsystem2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>._subsystem1 = subsystem1;</span><br><span class="line"><span class="keyword">this</span>._subsystem2 = subsystem2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;Facade initializes subsystems:&quot;</span>);</span><br><span class="line">_subsystem1.Operation1();</span><br><span class="line">_subsystem2.Operation1();</span><br><span class="line">System.Console.WriteLine(<span class="string">&quot;Facade orders subsystems to perform the action:&quot;</span>);</span><br><span class="line">_subsystem1.OperationN();</span><br><span class="line">_subsystem2.OperationZ();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Facade facade = <span class="keyword">new</span> Facade(<span class="keyword">new</span> Subsystem1(), <span class="keyword">new</span> Subsystem2());</span><br><span class="line">facade.Operation();</span><br></pre></td></tr></table></figure><h3 id="享元模式"><a class="header-anchor" href="#享元模式"></a>享元模式</h3><p>对象的常量数据通常被称为<em>内在状态</em>， 其位于对象中， 其他对象只能读取但不能修改其数值。 而对象的其他状态常常能被其他对象 “从外部” 改变， 因此被称为<em>外在状态</em>。享元模式建议不在对象中存储外在状态， 而是将其传递给依赖于它的一个特殊方法。 程序只在对象中保存内在状态， 以方便在不同情景下重用。</p><h4 id="UML"><a class="header-anchor" href="#UML"></a>UML</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/flyweight/structure-indexed.png" alt=""></p><blockquote><ol><li>享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。</li><li><strong>享元</strong> （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。</li><li><strong>情景</strong> （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。</li><li>通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。</li><li><strong>客户端</strong> （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。</li><li><strong>享元工厂</strong> （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。</li></ol></blockquote><h4 id="Code-v11"><a class="header-anchor" href="#Code-v11"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">FlyweightFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> Dictionary&lt;<span class="built_in">string</span>, Flyweight&gt; flyweights = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Flyweight&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Flyweight <span class="title">GetFlyweight</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!flyweights.ContainsKey(key))</span><br><span class="line">&#123;</span><br><span class="line">flyweights[key] = <span class="keyword">new</span> Flyweight();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> flyweights[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Flyweight</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Flyweight Operation&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> Flyweight repeatingState &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> uniqueState &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Context</span>(<span class="params">Flyweight repeatingState,<span class="built_in">string</span> uniqueState</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.repeatingState = repeatingState;</span><br><span class="line"><span class="keyword">this</span>.uniqueState = uniqueState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Some Operations&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FlyweightFactory factory = <span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">Flyweight flyweight = factory.GetFlyweight(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">Context context = <span class="keyword">new</span> Context(flyweight, <span class="string">&quot;uniqueState&quot;</span>);</span><br><span class="line">context.Operation();</span><br></pre></td></tr></table></figure><h3 id="代理"><a class="header-anchor" href="#代理"></a>代理</h3><h4 id="UML类图-v11"><a class="header-anchor" href="#UML类图-v11"></a>UML类图</h4><p><img src="https://refactoringguru.cn/images/patterns/diagrams/proxy/structure-indexed.png" alt=""></p><blockquote><ol><li><p><strong>服务接口</strong> （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。</p></li><li><p><strong>服务</strong> （Service） 类提供了一些实用的业务逻辑。</p></li><li><p><strong>代理</strong> （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。</p><p>通常情况下， 代理会对其服务对象的整个生命周期进行管理。</p></li><li><p><strong>客户端</strong> （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。</p></li></ol></blockquote><h4 id="Code-v12"><a class="header-anchor" href="#Code-v12"></a>Code</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ServiceInterface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Operationn</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Service</span> : <span class="title">ServiceInterface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operationn</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ServiceProxy</span> : <span class="title">ServiceInterface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> ServiceInterface _service;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceProxy</span>(<span class="params">ServiceInterface service</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operationn</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Do something before</span></span><br><span class="line">_service.Operationn();</span><br><span class="line"><span class="comment">// Do something after</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Service service = <span class="keyword">new</span> Service();</span><br><span class="line">ServiceProxy serviceProxy = <span class="keyword">new</span> ServiceProxy(service);</span><br><span class="line">serviceProxy.Operationn();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="行为"><a class="header-anchor" href="#行为"></a>行为</h3><h4 id="责任链"><a class="header-anchor" href="#责任链"></a>责任链</h4><h5 id="UML类图-v12"><a class="header-anchor" href="#UML类图-v12"></a>UML类图</h5><p><img src="https://refactoringguru.cn/images/patterns/diagrams/chain-of-responsibility/structure-indexed.png" alt=""></p><blockquote><ol><li><p><strong>处理者</strong> （Handler） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。</p></li><li><p><strong>基础处理者</strong> （Base Handler） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。</p><p>通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。</p></li><li><p><strong>具体处理者</strong> （Concrete Handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。</p><p>处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。</p></li><li><p><strong>客户端</strong> （Client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。</p></li></ol></blockquote><h5 id="Code-v13"><a class="header-anchor" href="#Code-v13"></a>Code</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">IHandler <span class="title">SetNext</span>(<span class="params">IHandler handler</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">object</span>? Handle(<span class="built_in">object</span> request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">AbstractHandler</span> : <span class="title">IHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> IHandler? _nextHandler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IHandler <span class="title">SetNext</span>(<span class="params">IHandler handler</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>._nextHandler = handler;</span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">object</span>? Handle(<span class="built_in">object</span> request)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>._nextHandler != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>._nextHandler.Handle(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">AHandler</span>: <span class="title">AbstractHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>? Handle(<span class="built_in">object</span> request)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((request <span class="keyword">as</span> <span class="built_in">string</span>) == <span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;A processes Request&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">base</span>.Handle(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">BHandler</span> : <span class="title">AbstractHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>? Handle(<span class="built_in">object</span> request)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((request <span class="keyword">as</span> <span class="built_in">string</span>) == <span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;B processes Request&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">base</span>.Handle(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">CHandler</span> : <span class="title">AbstractHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>? Handle(<span class="built_in">object</span> request)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((request <span class="keyword">as</span> <span class="built_in">string</span>) == <span class="string">&quot;C&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;C processes Request&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">base</span>.Handle(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">EHandler</span> : <span class="title">AbstractHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">object</span>? Handle(<span class="built_in">object</span> request)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((request <span class="keyword">as</span> <span class="built_in">string</span>) == <span class="string">&quot;E&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;E processes Request&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">base</span>.Handle(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aH = <span class="keyword">new</span> AHandler();</span><br><span class="line"><span class="keyword">var</span> bH = <span class="keyword">new</span> BHandler();</span><br><span class="line"><span class="keyword">var</span> cH = <span class="keyword">new</span> CHandler();</span><br><span class="line"><span class="keyword">var</span> eH = <span class="keyword">new</span> EHandler();</span><br><span class="line">aH.SetNext(bH).SetNext(cH).SetNext(eH);</span><br><span class="line"></span><br><span class="line">AbstractHandler abstractHandler = aH;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> t <span class="keyword">in</span> <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> ,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;\nClient: Who wants a <span class="subst">&#123;t&#125;</span>?&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> result = abstractHandler.Handle(t);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">Console.Write(<span class="string">$&quot;   <span class="subst">&#123;result&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;   <span class="subst">&#123;t&#125;</span> was left untouched.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令"><a class="header-anchor" href="#命令"></a>命令</h4><h5 id="UML类图-v13"><a class="header-anchor" href="#UML类图-v13"></a>UML类图</h5><p><img src="https://refactoringguru.cn/images/patterns/diagrams/command/structure-indexed.png" alt=""></p><blockquote><ol><li><p><strong>发送者</strong> （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。</p></li><li><p><strong>命令</strong> （Command） 接口通常仅声明一个执行命令的方法。</p></li><li><p><strong>具体命令</strong> （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。</p><p>接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。</p></li><li><p><strong>接收者</strong> （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。</p></li><li><p><strong>客户端</strong> （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了</p></li></ol></blockquote><h5 id="Code-v14"><a class="header-anchor" href="#Code-v14"></a>Code</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteCommand_A</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span> &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Do command A&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Receiver_4_B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething_1</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">           Console.WriteLine(s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething_2</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteCommand_B</span>: <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> Receiver_4_B receiver;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> para1 = <span class="built_in">string</span>.Empty;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> para2 = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand_B</span>(<span class="params">Receiver_4_B receiver, <span class="built_in">string</span> para1,<span class="built_in">string</span> para2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.receiver = receiver;</span><br><span class="line"><span class="keyword">this</span>.para1 = para1;</span><br><span class="line"><span class="keyword">this</span>.para2 = para2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Do command B&quot;</span>);</span><br><span class="line">receiver.DoSomething_1(<span class="keyword">this</span>.para1);</span><br><span class="line">receiver.DoSomething_2(<span class="keyword">this</span>.para2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Invoker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> ICommand? cmd_1;</span><br><span class="line"><span class="keyword">private</span> ICommand? cmd_2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCmd1</span> (<span class="params">ICommand cmd</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.cmd_1 = cmd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCmd2</span>(<span class="params">ICommand cmd</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.cmd_2 = cmd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dosomething</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cmd_1 <span class="keyword">is</span> ICommand)</span><br><span class="line">&#123;</span><br><span class="line">cmd_1.Execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cmd_2 <span class="keyword">is</span> ICommand)</span><br><span class="line">&#123;</span><br><span class="line">cmd_2.Execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">invoker.SetCmd1(<span class="keyword">new</span> ConcreteCommand_A());</span><br><span class="line">Receiver_4_B receiver = <span class="keyword">new</span> Receiver_4_B();</span><br><span class="line">invoker.SetCmd2(<span class="keyword">new</span> ConcreteCommand_B(receiver, <span class="string">&quot;para1&quot;</span>, <span class="string">&quot;para2&quot;</span>));</span><br><span class="line">invoker.Dosomething();</span><br></pre></td></tr></table></figure><h4 id="迭代器"><a class="header-anchor" href="#迭代器"></a>迭代器</h4><h5 id="UML类图-v14"><a class="header-anchor" href="#UML类图-v14"></a>UML类图</h5><p><img src="https://refactoringguru.cn/images/patterns/diagrams/iterator/structure-indexed.png" alt=""></p><blockquote><ol><li><p><strong>迭代器</strong> （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。</p></li><li><p><strong>具体迭代器</strong> （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。</p></li><li><p><strong>集合</strong> （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。</p></li><li><p><strong>具体集合</strong> （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。</p></li><li><p><strong>客户端</strong> （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。</p><p><strong>客户端通常不会自行创建迭代器， 而是会从集合中获取。</strong> 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。</p></li></ol></blockquote><h5 id="Code-v15"><a class="header-anchor" href="#Code-v15"></a>Code</h5><p>(暂略)</p><h4 id="中介模式"><a class="header-anchor" href="#中介模式"></a>中介模式</h4><h5 id="UML类图-v15"><a class="header-anchor" href="#UML类图-v15"></a>UML类图</h5><p><img src="https://refactoringguru.cn/images/patterns/diagrams/mediator/structure-indexed.png" alt=""></p><blockquote><ol><li><p><strong>组件</strong> （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。</p></li><li><p><strong>中介者</strong> （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。</p></li><li><p><strong>具体中介者</strong> （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。</p></li><li><p>组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。</p><p>对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。</p></li></ol></blockquote><h5 id="Code-v16"><a class="header-anchor" href="#Code-v16"></a>Code</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IMediator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"><span class="built_in">object</span> sender</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">BaseComponent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> IMediator? mediator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseComponent</span>(<span class="params">IMediator? mediator=<span class="literal">null</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMediator</span>(<span class="params">IMediator? mediator</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Base Operation&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ComponentA</span>:<span class="title">BaseComponent</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Operation A&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>.mediator?.Notify(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ComponentB</span> : <span class="title">BaseComponent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Operation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Operation B&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>.mediator?.Notify(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> : <span class="title">IMediator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> ComponentA _componentA;</span><br><span class="line"><span class="keyword">private</span> ComponentB _componentB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span>(<span class="params">ComponentA componentA, ComponentB componentB</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_componentA = componentA;</span><br><span class="line">_componentA.SetMediator(<span class="keyword">this</span>);</span><br><span class="line">_componentB = componentB;</span><br><span class="line">_componentB.SetMediator(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"><span class="built_in">object</span> sender</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sender <span class="keyword">is</span> ComponentA)</span><br><span class="line">&#123;</span><br><span class="line">ReactOnA();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sender <span class="keyword">is</span> ComponentB)</span><br><span class="line">&#123;</span><br><span class="line">ReactOnB();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReactOnA</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Mediator ReactOnA&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReactOnB</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Mediator ReactOnB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ComponentA componentA = <span class="keyword">new</span> ComponentA();</span><br><span class="line">ComponentB componentB = <span class="keyword">new</span> ComponentB();</span><br><span class="line"></span><br><span class="line">ConcreteMediator mediator = <span class="keyword">new</span> ConcreteMediator(componentA, componentB);</span><br><span class="line">componentA.Operation();</span><br><span class="line">componentB.Operation();</span><br></pre></td></tr></table></figure><h4 id="备忘录"><a class="header-anchor" href="#备忘录"></a>备忘录</h4><h5 id="UML类图-v16"><a class="header-anchor" href="#UML类图-v16"></a>UML类图</h5><p><img src="https://refactoringguru.cn/images/patterns/diagrams/memento/structure1-indexed.png" alt=""></p><blockquote><ol><li><p><strong>原发器</strong> （Originator） 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。</p></li><li><p><strong>备忘录</strong> （Memento） 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。</p></li><li><p><strong>负责人</strong> （Caretaker） 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。</p><p>负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时， 负责人将从栈中获取最顶部的备忘录， 并将其传递给原发器的恢复 （restoration） 方法。</p></li><li><p>在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。</p></li></ol></blockquote><h5 id="Code-v17"><a class="header-anchor" href="#Code-v17"></a>Code</h5><p>(暂略)</p><h4 id="观察者"><a class="header-anchor" href="#观察者"></a>观察者</h4><h5 id="UML类图-v17"><a class="header-anchor" href="#UML类图-v17"></a>UML类图</h5><p><img src="https://refactoringguru.cn/images/patterns/diagrams/observer/structure-indexed.png" alt=""></p><blockquote><ol><li><strong>发布者</strong> （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。</li><li>当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。</li><li><strong>订阅者</strong> （Subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 <code>update</code>更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。</li><li><strong>具体订阅者</strong> （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。</li><li>订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。</li><li><strong>客户端</strong> （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。</li></ol></blockquote><h5 id="Code-v18"><a class="header-anchor" href="#Code-v18"></a>Code</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="状态"><a class="header-anchor" href="#状态"></a>状态</h4><h5 id="UML类图-v18"><a class="header-anchor" href="#UML类图-v18"></a>UML类图</h5><p><img src="https://refactoringguru.cn/images/patterns/diagrams/state/structure-zh-indexed.png" alt=""></p><blockquote><ol><li><p><strong>上下文</strong> （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。</p></li><li><p><strong>状态</strong> （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。</p></li><li><p><strong>具体状态</strong> （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。</p><p>状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。</p></li><li><p>上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。</p></li></ol></blockquote><h5 id="Code-v19"><a class="header-anchor" href="#Code-v19"></a>Code</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="策略"><a class="header-anchor" href="#策略"></a>策略</h4><h5 id="UML类图-v19"><a class="header-anchor" href="#UML类图-v19"></a>UML类图</h5><p><img src="https://refactoringguru.cn/images/patterns/diagrams/strategy/structure-indexed.png" alt=""></p><blockquote><ol><li><strong>上下文</strong> （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。</li><li><strong>策略</strong> （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。</li><li><strong>具体策略</strong> （Concrete Strategies） 实现了上下文所用算法的各种不同变体。</li><li>当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。</li><li><strong>客户端</strong> （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。</li></ol></blockquote><h5 id="Code-v20"><a class="header-anchor" href="#Code-v20"></a>Code</h5><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStrategy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">object</span> <span class="title">DoAlgorithm</span>(<span class="params"><span class="built_in">object</span> data</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> IStrategy? _strategy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Context</span>()</span></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Context</span>(<span class="params">IStrategy strategy</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>._strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetStrategy</span>(<span class="params">IStrategy strategy</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>._strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomeBusinessLogic</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">this</span>._strategy?.DoAlgorithm(<span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span> &#125;);</span><br><span class="line"><span class="keyword">if</span>(result != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> l = result <span class="keyword">as</span> List&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> l)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> : <span class="title">IStrategy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">DoAlgorithm</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> list = data <span class="keyword">as</span> List&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">list.Sort();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> : <span class="title">IStrategy</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">DoAlgorithm</span>(<span class="params"><span class="built_in">object</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> list = data <span class="keyword">as</span> List&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">list.Sort();</span><br><span class="line">list.Reverse();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> context = <span class="keyword">new</span> Context();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            context.SetStrategy(<span class="keyword">new</span> ConcreteStrategyA());</span><br><span class="line">context.DoSomeBusinessLogic();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            context.SetStrategy(<span class="keyword">new</span> ConcreteStrategyB());</span><br><span class="line">context.DoSomeBusinessLogic();</span><br></pre></td></tr></table></figure><h4 id="模板方法"><a class="header-anchor" href="#模板方法"></a>模板方法</h4><h5 id="UML类图-v20"><a class="header-anchor" href="#UML类图-v20"></a>UML类图</h5><p><img src="https://refactoringguru.cn/images/patterns/diagrams/template-method/structure-indexed.png" alt=""></p><blockquote><ol><li><strong>抽象类</strong> （Abstract­Class） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为 <code>抽象</code>类型， 也可以提供一些默认实现。</li><li><strong>具体类</strong> （Concrete­Class） 可以重写所有步骤， 但不能重写模板方法自身。</li></ol></blockquote><h5 id="Code-v21"><a class="header-anchor" href="#Code-v21"></a>Code</h5><p>就是简而言之的父类，父类事先定义好逻辑，然后被继承，派生类可以更改内部虚函数实现细节</p><h4 id="访问者"><a class="header-anchor" href="#访问者"></a>访问者</h4><h5 id="UML类图-v21"><a class="header-anchor" href="#UML类图-v21"></a>UML类图</h5><p><img src="https://refactoringguru.cn/images/patterns/diagrams/visitor/structure-zh-indexed.png" alt=""></p><blockquote><ol><li><strong>访问者</strong> （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。</li><li><strong>具体访问者</strong> （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。</li><li><strong>元素</strong> （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。</li><li><strong>具体元素</strong> （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。</li><li><strong>客户端</strong> （Client） 通常会作为集合或其他复杂对象 （例如一个<a href="https://refactoringguru.cn/design-patterns/composite">组合</a>树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。</li></ol></blockquote><h5 id="Code-v22"><a class="header-anchor" href="#Code-v22"></a>Code</h5><p>（暂略）</p>]]></content>
    
    
    <summary type="html">有关经典设计模式的学习</summary>
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>GNN 学习回顾</title>
    <link href="https://ninokz.github.io/2024/03/31/GNN/"/>
    <id>https://ninokz.github.io/2024/03/31/GNN/</id>
    <published>2024-03-31T14:52:55.605Z</published>
    <updated>2024-04-23T13:30:25.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="header-anchor" href="#前言"></a>前言</h1><p>​研一刚入学时分到的大方向是时间序列（Time-series）领域相关的方向，特别是关于多元时间序列相关的任务，本来想好了毕业相关课题做什么，但是出于一些客观原因，没有做纯时间序列相关的内容了，拓宽了一部分到网络异常方面，做时间序列+网络异常检测结合领域的东西。同时我导提出了关于再结合Dynamic Graph的建议，现在做的大概是时间序列+网络异常检测+动态图的三领域重叠的部分，也挺有挑战性，感觉有点不好下手。平时项目也多，GNN也是突然间就给加过来的，以前没怎么做过GNN方面，花了大半个月读Survey和Review入门了GNN&amp;动态图，发现结合动态图还真不太好去结合，现在我都还没找到合适的结合点切入去做实验设计，比较焦虑这一部分的内容。</p><p>​前不久看了一篇 AAAI 21 的关于多变量时间序列异常检测的<a href="https://arxiv.org/abs/2106.06947">论文</a>，但是这是多变量时间序列异常检测的邻域内容，也是属于纯时间序列相关的部分，我甚至将原作者的代码修改的更易于阅读了一点[<a href="https://github.com/Ninokz/GDN_remake">修改版</a>]。虽然发现了其中的文章作者提出的模型有部分可以修改的地方，但还是与网络异常检测+动态图找不到合适的结合点。也许，我可能还需要补充回顾一下关于GNN相关知识才能找到网络异常检测+动态图的结合点？</p><h1 id="GCN"><a class="header-anchor" href="#GCN"></a>GCN</h1><p><strong>首先是区别于数据的问题：</strong></p><p>对于传统的多层感知机（MLP）来说，它通常处理的是一个由多个独立样本组成的数据集，每个样本都有自己的特征向量和标签（对于监督学习任务）。每个样本都是独立处理的，模型在这些样本上进行训练，以学习特征与标签之间的映射关系。 而对于图卷积网络（GCN），情况有所不同。在GCN中，整个图被视为一个单一的数据实体，即使这个图可能包含成百上千个节点。在这种情况下，每个节点及其特征向量可以被看作是一个“样本”，而节点间的边则定义了这些样本之间的关系。因此，尽管整个数据集可能只包含一张图，这张图却包含了大量通过边相互连接的样本（即节点）</p><p>以前个人对GCN理解还是蛮有疑惑的，主要疑惑来自于，这个GNN相关的 * 数据怎么和我通常见到的TS常见数据集类型不一样，不是一条条的，<strong>直到看到了下述图片a才有所理解</strong>。</p><p><img src="https://picx.zhimg.com/70/v2-6ad8f3cf2e8d3701922cf65986c8533c_1440w.image?source=172ae18b&amp;biz_tag=Post" alt="怎么搭好一个GCN？只需这四步"></p><p>顺便一提，关于这里卷积有点意思，可以看下<a href="https://zhuanlan.zhihu.com/p/492303139">这篇文章</a></p><p><strong>GCN的工作过程：</strong></p><ol><li><p><strong>节点表示初始化</strong>：每个节点被初始化一个表示（如，节点的特征向量）。</p></li><li><p><strong>邻居信息聚合</strong>：每个节点通过聚合其邻居节点的表示来更新自己的表示。这个过程可以迭代多次，每次迭代称为一层GCN。</p></li><li><p><strong>特征变换</strong>：在聚合邻居信息的同时，通常会对特征进行线性变换（例如，通过乘以一个权重矩阵）。</p></li><li><p><strong>非线性激活</strong>：对更新后的节点表示应用非线性激活函数，如ReLU。</p></li><li><p><strong>读出（Readout）</strong>：对于图级别的任务，所有节点的表示会被进一步聚合以形成图的表示。</p></li></ol><p><strong>数学表达：</strong></p><p>给定一个图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>是节点集合，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>是边集合。每个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>都有一个特征向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。GCN的一层可以用下面的公式表示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi>σ</mi><mrow><mo fence="true">(</mo><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mover accent="true"><mi>A</mi><mo>~</mo></mover><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">H^{(l+1)} = \sigma\left(\tilde{D}^{-\frac{1}{2}}\tilde{A}\tilde{D}^{-\frac{1}{2}}H^{(l)}W^{(l)}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.938em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span></span></p><p>其中：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">H^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的节点表示矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">H^{(0)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">0</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>是初始的节点特征矩阵。</p><ul><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>~</mo></mover><mo>=</mo><mi>A</mi><mo>+</mo><msub><mi>I</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">\tilde{A} = A + I_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是图的邻接矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>加上单位矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">I_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>是节点的数量），这样做是为了在聚合邻居信息的同时保留自身的信息。</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>D</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span></span></span></span>的度矩阵的对角矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>=</mo><msub><mo>∑</mo><mi>j</mi></msub><msub><mover accent="true"><mi>A</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\tilde{D}_{ii} = \sum_j \tilde{A}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0702em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ii</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.356em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>是非线性激活函数，如ReLU</p></li><li><p><strong>邻居信息聚合</strong>：通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mover accent="true"><mi>A</mi><mo>~</mo></mover><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\tilde{D}^{-\frac{1}{2}}\tilde{A}\tilde{D}^{-\frac{1}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.954em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>这个矩阵乘法，每个节点可以聚合其邻居（包括自己）的信息。</p></li><li><p><strong>特征变换</strong>：通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，可以对聚合后的特征进行线性变换</p></li><li><p><strong>非线性激活</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>引入非线性，增加模型的表达能力</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的可学习权重矩阵</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>在图卷积网络（GCN）中的作用非常关键，它主要用于特征变换。具体来说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的可学习权重矩阵，用于对每个节点聚合邻居信息后的特征进行线性变换</p><ol><li><strong>维度变换</strong>：通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，可以改变节点特征的维度，即可以从较高维度映射到较低维度（降维），或从较低维度映射到较高维度（升维），以适应后续层的需要或是最终任务的需求。</li><li><strong>特征提取</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>可以视为一种特征提取器，它可以帮助模型学习到在当前任务中更为重要的特征表示。通过训练过程中的梯度下降，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>会被优化，以更好地捕捉和提取对当前任务有用的信息。</li><li><strong>提高模型表达能力</strong>：通过引入可学习的参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，GCN可以学习到更加复杂的特征表示，增强模型的非线性表达能力。这对于处理复杂的图结构数据，如社交网络、分子结构等，是非常必要的。</li><li><strong>促进信息融合</strong>：在多层GCN中，每一层的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>可以帮助模型将不同邻居的信息以及不同特征的信息有效地融合在一起，以便更好地理解节点和图的整体结构</li></ol></li></ul><p><strong>问题</strong></p><ol><li><strong>为什么GCN他这个是一层是通过旧的一层去计算的？</strong></li></ol><p>​GCN通过旧的层去计算新的层是基于图数据的本质和信息传播机制的需要。在图卷积网络（GCN）中，每一层的目的是通过聚合邻居的信息来更新节点的表示，这个过程可以视为在图中进行信息的传播。</p><ul><li><strong>信息传播</strong>：在图结构中，节点之间通过边相互连接，节点的特征信息需要通过这些边来传递和聚合。每一次的传播过程（即一层GCN）可以被看作是节点收集其直接邻居的信息。通过多层的迭代，节点能够间接地收集更远距离邻居的信息，从而获得全局的图结构信息。</li><li><strong>深度学习的层次结构</strong>：GCN借鉴了深度学习中的层次结构概念，其中每一层的输出都会作为下一层的输入。这种设计使得网络可以学习到从局部到全局的特征表示，每一层都在前一层基础上进一步提炼和整合信息。</li><li><strong>非线性特征组合</strong>：通过层与层之间的非线性变换（例如通过ReLU激活函数），GCN能够学习更加复杂和抽象的特征表示。这种层叠的非线性变换是深度学习能够捕获高级抽象特征的关键。</li><li><strong>局部到全局的信息整合</strong>：在图的上下文中，初始层通常捕获节点的局部信息（例如，一个节点及其直接邻居）。随着层数的增加，每个节点能够整合来自更广范围的邻居信息，从而形成更全面的全局视图。</li></ul><ol start="2"><li><p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">W^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span>矩阵问题</strong></p><p>我们的这个矩阵是不停被迭代吗？每经过一次迭代都有一个针对上次的新的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">W^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span>的产生，直至loss收敛且结果最优时，迭代出的w^l就是最好的？</p><p>在图卷积网络（GCN）中，每一层通常都有自己的权重矩阵（记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span>），这与传统的多层感知机（MLP）或深度神经网络中的做法类似，其中每一层也有自己的权重矩阵。在GCN的上下文中，权重矩阵用于转换节点特征，以便在每个图卷积层中学习更高级别的特征表示。</p><p>在一个典型的GCN模型中，你可能有多个图卷积层，每个层都执行以下步骤：</p><ol><li><p><strong>聚合邻居特征</strong>：每个节点收集其邻居的特征信息（以及自身的特征）。</p></li><li><p><strong>特征变换</strong>：聚合得到的特征通过乘以权重矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span>进行变换。每一层都有一个不同的权重矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，这里的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>表示层的索引。</p></li><li><p><strong>非线性激活</strong>：变换后的特征通常会通过一个非线性激活函数，如ReLU，来增加模型的非线性能力。</p></li></ol><p>因此，如果你有一个由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>层组成的GCN，你将有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>个不同的权重矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(1)}, W^{(2)}, ..., W^{(L)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">L</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，每个对应于网络中的一个层。在训练过程中，所有这些权重矩阵都会通过反向传播算法进行更新，以最小化最终的损失函数。</p><p>值得注意的是，在GCN中，并不是每个节点都有一个独立的权重矩阵。相反，同一层内的所有节点共享相同的权重矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>。这种权重共享机制是卷积神经网络（包括GCN）的一个关键特征，它有助于模型泛化，并减少了模型的参数数量。</p><p>总结来说，尽管在GCN中每个图卷积层都有自己的权重矩阵，但这些矩阵是在该层的所有节点间共享的。这使得模型能够学习到在图中普遍适用的特征转换，从而能够更好地泛化到新的节点或图上。</p></li><li><p><strong>输入矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> 与输出矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">H^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span> 是图邻接矩阵？</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>通常指的是图的初始特征矩阵，而不是邻接矩阵。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">H^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span>不是新的邻接矩阵，而是经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层图卷积后每个节点的新的特征表示。这些新的特征可以捕捉到节点的高级结构信息和其邻居的特征信息。在许多应用中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">H^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span>可以用于节点分类、图分类、节点聚类等任务</p><p>这里的概念分开来看：</p><ul><li><p><strong>特征矩阵</strong> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>)：在GCN的输入层，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>表示图中每个节点的特征向量的集合。如果图有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个节点，每个节点有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>个特征，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>的维度将是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">N \times F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>。这是GCN处理的输入数据。</p></li><li><p><strong>邻接矩阵</strong> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>)：邻接矩阵表示图中节点之间的连接情况。如果图有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个节点，则邻接矩阵的维度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。如果节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>和节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>之间存在边，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A_{ij} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>（或者在加权图中为边的权重），否则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A_{ij} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p></li></ul></li></ol><hr><p>待更新 2024.04.15</p>]]></content>
    
    
    <summary type="html">有关我的论文方向的一些想法和笔记</summary>
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
    <category term="Deep Learning" scheme="https://ninokz.github.io/tags/Deep-Learning/"/>
    
  </entry>
  
</feed>
