<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ninokz</title>
  
  <subtitle>你干嘛，哎哟</subtitle>
  <link href="https://ninokz.github.io/atom.xml" rel="self"/>
  
  <link href="https://ninokz.github.io/"/>
  <updated>2024-03-31T16:37:56.757Z</updated>
  <id>https://ninokz.github.io/</id>
  
  <author>
    <name>Ninokz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GNN 学习回顾</title>
    <link href="https://ninokz.github.io/2024/03/31/GNN/"/>
    <id>https://ninokz.github.io/2024/03/31/GNN/</id>
    <published>2024-03-31T14:52:55.605Z</published>
    <updated>2024-03-31T16:37:56.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="header-anchor" href="#前言"></a>前言</h1><p>​研一刚入学时分到的大方向是时间序列（Time-series）领域相关的方向，特别是关于多元时间序列相关的任务，本来想好了毕业相关课题做什么，但是出于一些客观原因，没有做纯时间序列相关的内容了，拓宽了一部分到网络异常方面，做时间序列+网络异常检测结合领域的东西。同时我导提出了关于再结合Dynamic Graph的建议，现在做的大概是时间序列+网络异常检测+动态图的三领域重叠的部分，也挺有挑战性，感觉有点不好下手。平时项目也多，GNN也是突然间就给加过来的，以前没怎么做过GNN方面，花了大半个月读Survey和Review入门了GNN&amp;动态图，发现结合动态图还真不太好去结合，现在我都还没找到合适的结合点切入去做实验设计，比较焦虑这一部分的内容。</p><p>​前不久看了一篇 AAAI 21 的关于多变量时间序列异常检测的<a href="https://arxiv.org/abs/2106.06947">论文</a>，但是这是多变量时间序列异常检测的邻域内容，也是属于纯时间序列相关的部分，我甚至将原作者的代码修改的更易于阅读了一点[<a href="https://github.com/Ninokz/GDN_remake">修改版</a>]。虽然发现了其中的文章作者提出的模型有部分可以修改的地方，但还是与网络异常检测+动态图找不到合适的结合点。也许，我可能还需要补充回顾一下关于GNN相关知识才能找到网络异常检测+动态图的结合点？</p><h1 id="GCN"><a class="header-anchor" href="#GCN"></a>GCN</h1><p><strong>首先是区别于数据的问题：</strong></p><p>对于传统的多层感知机（MLP）来说，它通常处理的是一个由多个独立样本组成的数据集，每个样本都有自己的特征向量和标签（对于监督学习任务）。每个样本都是独立处理的，模型在这些样本上进行训练，以学习特征与标签之间的映射关系。 而对于图卷积网络（GCN），情况有所不同。在GCN中，整个图被视为一个单一的数据实体，即使这个图可能包含成百上千个节点。在这种情况下，每个节点及其特征向量可以被看作是一个“样本”，而节点间的边则定义了这些样本之间的关系。因此，尽管整个数据集可能只包含一张图，这张图却包含了大量通过边相互连接的样本（即节点）</p><p>以前个人对GCN理解还是蛮有疑惑的，主要疑惑来自于，这个GNN相关的 * 数据怎么和我通常见到的TS常见数据集类型不一样，不是一条条的，<strong>直到看到了下述图片a才有所理解</strong>。</p><p><img src="https://picx.zhimg.com/70/v2-6ad8f3cf2e8d3701922cf65986c8533c_1440w.image?source=172ae18b&amp;biz_tag=Post" alt="怎么搭好一个GCN？只需这四步"></p><p>顺便一提，关于这里卷积有点意思，可以看下<a href="https://zhuanlan.zhihu.com/p/492303139">这篇文章</a></p><p><strong>GCN的工作过程：</strong></p><ol><li><p><strong>节点表示初始化</strong>：每个节点被初始化一个表示（如，节点的特征向量）。</p></li><li><p><strong>邻居信息聚合</strong>：每个节点通过聚合其邻居节点的表示来更新自己的表示。这个过程可以迭代多次，每次迭代称为一层GCN。</p></li><li><p><strong>特征变换</strong>：在聚合邻居信息的同时，通常会对特征进行线性变换（例如，通过乘以一个权重矩阵）。</p></li><li><p><strong>非线性激活</strong>：对更新后的节点表示应用非线性激活函数，如ReLU。</p></li><li><p><strong>读出（Readout）</strong>：对于图级别的任务，所有节点的表示会被进一步聚合以形成图的表示。</p></li></ol><p><strong>数学表达：</strong></p><p>给定一个图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>是节点集合，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>是边集合。每个节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>都有一个特征向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。GCN的一层可以用下面的公式表示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi>σ</mi><mrow><mo fence="true">(</mo><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mover accent="true"><mi>A</mi><mo>~</mo></mover><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">H^{(l+1)} = \sigma\left(\tilde{D}^{-\frac{1}{2}}\tilde{A}\tilde{D}^{-\frac{1}{2}}H^{(l)}W^{(l)}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.938em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.004em;"><span style="top:-3.413em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span></span></p><p>其中：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">H^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的节点表示矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">H^{(0)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">0</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>是初始的节点特征矩阵。</p><ul><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>~</mo></mover><mo>=</mo><mi>A</mi><mo>+</mo><msub><mi>I</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">\tilde{A} = A + I_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是图的邻接矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>加上单位矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">I_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>是节点的数量），这样做是为了在聚合邻居信息的同时保留自身的信息。</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>D</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span></span></span></span>的度矩阵的对角矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>=</mo><msub><mo>∑</mo><mi>j</mi></msub><msub><mover accent="true"><mi>A</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\tilde{D}_{ii} = \sum_j \tilde{A}_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0702em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ii</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.356em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>是非线性激活函数，如ReLU</p></li><li><p><strong>邻居信息聚合</strong>：通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mover accent="true"><mi>A</mi><mo>~</mo></mover><msup><mover accent="true"><mi>D</mi><mo>~</mo></mover><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">\tilde{D}^{-\frac{1}{2}}\tilde{A}\tilde{D}^{-\frac{1}{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.954em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">~</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>这个矩阵乘法，每个节点可以聚合其邻居（包括自己）的信息。</p></li><li><p><strong>特征变换</strong>：通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，可以对聚合后的特征进行线性变换</p></li><li><p><strong>非线性激活</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>引入非线性，增加模型的表达能力</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的可学习权重矩阵</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>在图卷积网络（GCN）中的作用非常关键，它主要用于特征变换。具体来说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层的可学习权重矩阵，用于对每个节点聚合邻居信息后的特征进行线性变换</p><ol><li><strong>维度变换</strong>：通过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，可以改变节点特征的维度，即可以从较高维度映射到较低维度（降维），或从较低维度映射到较高维度（升维），以适应后续层的需要或是最终任务的需求。</li><li><strong>特征提取</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>可以视为一种特征提取器，它可以帮助模型学习到在当前任务中更为重要的特征表示。通过训练过程中的梯度下降，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>会被优化，以更好地捕捉和提取对当前任务有用的信息。</li><li><strong>提高模型表达能力</strong>：通过引入可学习的参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，GCN可以学习到更加复杂的特征表示，增强模型的非线性表达能力。这对于处理复杂的图结构数据，如社交网络、分子结构等，是非常必要的。</li><li><strong>促进信息融合</strong>：在多层GCN中，每一层的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>可以帮助模型将不同邻居的信息以及不同特征的信息有效地融合在一起，以便更好地理解节点和图的整体结构</li></ol></li></ul><p><strong>问题</strong></p><ol><li><strong>为什么GCN他这个是一层是通过旧的一层去计算的？</strong></li></ol><p>​GCN通过旧的层去计算新的层是基于图数据的本质和信息传播机制的需要。在图卷积网络（GCN）中，每一层的目的是通过聚合邻居的信息来更新节点的表示，这个过程可以视为在图中进行信息的传播。</p><ul><li><strong>信息传播</strong>：在图结构中，节点之间通过边相互连接，节点的特征信息需要通过这些边来传递和聚合。每一次的传播过程（即一层GCN）可以被看作是节点收集其直接邻居的信息。通过多层的迭代，节点能够间接地收集更远距离邻居的信息，从而获得全局的图结构信息。</li><li><strong>深度学习的层次结构</strong>：GCN借鉴了深度学习中的层次结构概念，其中每一层的输出都会作为下一层的输入。这种设计使得网络可以学习到从局部到全局的特征表示，每一层都在前一层基础上进一步提炼和整合信息。</li><li><strong>非线性特征组合</strong>：通过层与层之间的非线性变换（例如通过ReLU激活函数），GCN能够学习更加复杂和抽象的特征表示。这种层叠的非线性变换是深度学习能够捕获高级抽象特征的关键。</li><li><strong>局部到全局的信息整合</strong>：在图的上下文中，初始层通常捕获节点的局部信息（例如，一个节点及其直接邻居）。随着层数的增加，每个节点能够整合来自更广范围的邻居信息，从而形成更全面的全局视图。</li></ul><ol start="2"><li><p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">W^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span>矩阵问题</strong></p><p>我们的这个矩阵是不停被迭代吗？每经过一次迭代都有一个针对上次的新的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">W^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span>的产生，直至loss收敛且结果最优时，迭代出的w^l就是最好的？</p><p>在图卷积网络（GCN）中，每一层通常都有自己的权重矩阵（记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span>），这与传统的多层感知机（MLP）或深度神经网络中的做法类似，其中每一层也有自己的权重矩阵。在GCN的上下文中，权重矩阵用于转换节点特征，以便在每个图卷积层中学习更高级别的特征表示。</p><p>在一个典型的GCN模型中，你可能有多个图卷积层，每个层都执行以下步骤：</p><ol><li><p><strong>聚合邻居特征</strong>：每个节点收集其邻居的特征信息（以及自身的特征）。</p></li><li><p><strong>特征变换</strong>：聚合得到的特征通过乘以权重矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span>进行变换。每一层都有一个不同的权重矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，这里的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>表示层的索引。</p></li><li><p><strong>非线性激活</strong>：变换后的特征通常会通过一个非线性激活函数，如ReLU，来增加模型的非线性能力。</p></li></ol><p>因此，如果你有一个由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>层组成的GCN，你将有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>个不同的权重矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(1)}, W^{(2)}, ..., W^{(L)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">L</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，每个对应于网络中的一个层。在训练过程中，所有这些权重矩阵都会通过反向传播算法进行更新，以最小化最终的损失函数。</p><p>值得注意的是，在GCN中，并不是每个节点都有一个独立的权重矩阵。相反，同一层内的所有节点共享相同的权重矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">W^{(l)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>。这种权重共享机制是卷积神经网络（包括GCN）的一个关键特征，它有助于模型泛化，并减少了模型的参数数量。</p><p>总结来说，尽管在GCN中每个图卷积层都有自己的权重矩阵，但这些矩阵是在该层的所有节点间共享的。这使得模型能够学习到在图中普遍适用的特征转换，从而能够更好地泛化到新的节点或图上。</p></li><li><p><strong>输入矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> 与输出矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">H^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span> 是图邻接矩阵？</strong></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>通常指的是图的初始特征矩阵，而不是邻接矩阵。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">H^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span>不是新的邻接矩阵，而是经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>层图卷积后每个节点的新的特征表示。这些新的特征可以捕捉到节点的高级结构信息和其邻居的特征信息。在许多应用中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mi>l</mi></msup></mrow><annotation encoding="application/x-tex">H^{l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span></span></span></span></span></span></span></span>可以用于节点分类、图分类、节点聚类等任务</p><p>这里的概念分开来看：</p><ul><li><p><strong>特征矩阵</strong> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>)：在GCN的输入层，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>表示图中每个节点的特征向量的集合。如果图有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个节点，每个节点有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>个特征，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">H^{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>的维度将是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">N \times F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span>。这是GCN处理的输入数据。</p></li><li><p><strong>邻接矩阵</strong> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>)：邻接矩阵表示图中节点之间的连接情况。如果图有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>个节点，则邻接矩阵的维度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N \times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>。如果节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>和节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>之间存在边，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A_{ij} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>（或者在加权图中为边的权重），否则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">A_{ij} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;
&lt;p&gt;​		研一刚入学时分到的大方向是时间序列（Time-series）领域相关的方向，特别是关于多元时间序列相关的任务，本来想好了毕业相关课题做什么，但是出于</summary>
      
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
    <category term="Deep Learning" scheme="https://ninokz.github.io/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>C++ 复习笔记</title>
    <link href="https://ninokz.github.io/2024/03/27/cpp-review-for-interview/"/>
    <id>https://ninokz.github.io/2024/03/27/cpp-review-for-interview/</id>
    <published>2024-03-27T02:38:31.093Z</published>
    <updated>2024-03-31T14:55:19.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起始"><a class="header-anchor" href="#起始"></a>起始</h1><p>这篇文章应该是 blog 里更的第二篇文章，最近开始准备今年夏季实习的事情，虽然C/C++&amp;CSharp都会一点，但是感觉实习面试时的问题我会答不上来，所以准备了这篇笔记，一是记录学习笔记，二是督促一下自己吧。注意本文在使用对象一词时并不单单限定于OO中的面向对象的对象的意思。</p><h1 id="C-C-language"><a class="header-anchor" href="#C-C-language"></a>C/C++ language</h1><h2 id="Keywords-🔑"><a class="header-anchor" href="#Keywords-🔑"></a>Keywords 🔑</h2><h3 id="const"><a class="header-anchor" href="#const"></a>const</h3><p>const限定符用处是：对被修饰<strong>对象</strong>进行限定，在初始化后对象在后续过程中不能进行修改操作，分为修饰变量、修饰指针、修饰引用、修饰函数</p><p><strong>区别于宏</strong></p><table><thead><tr><th>宏定义 #define</th><th>const 常量</th></tr></thead><tbody><tr><td>宏定义，相当于字符替换</td><td>常量声明</td></tr><tr><td>预处理器处理</td><td>编译器处理</td></tr><tr><td><strong>无类型安全检查</strong></td><td><strong>有类型安全检查</strong></td></tr><tr><td>不分配内存</td><td>要分配内存</td></tr><tr><td>存储在代码段</td><td>存储在数据段</td></tr><tr><td>可通过 <code>#undef</code> 取消</td><td>不可取消</td></tr></tbody></table><h4 id="const-引用"><a class="header-anchor" href="#const-引用"></a>const 引用</h4><p>指的是对常量对象进行引用，但是注意const引用是将对const 修饰的某类型对象限定为不可修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; aRef = a;</span><br><span class="line"><span class="type">int</span>&amp; b = aRef; </span><br><span class="line"><span class="comment">// Error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;const int&#x27;</span></span><br><span class="line"><span class="comment">// 因为如果成了，那我们可以根据b修改a的值了，而a本身不可修改</span></span><br></pre></td></tr></table></figure><h4 id="const-指针"><a class="header-anchor" href="#const-指针"></a>const 指针</h4><p>从以下代码看出const修饰的影响，有一个名词叫做<strong>顶层const</strong>和<strong>底层const</strong>，前者表示指针本身是常量（不可更改），后者表示指针所指对象是常量（对象不可更改），通常意义上来讲顶层const的限制弱于底层 const。所以在进行拷贝操作时，顶层const基本上不受影响，而底层const的限制性更大，当进行拷贝考入考出时，左右对象必须是相同的底层const资格</p><p><strong>代码示例1</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* c = &amp;a;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> d = &amp;b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> e = &amp;a;</span><br><span class="line"></span><br><span class="line">c = &amp;b; <span class="comment">// OK</span></span><br><span class="line">*c = <span class="number">6</span>; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">d = &amp;a; <span class="comment">// Error</span></span><br><span class="line">*d = <span class="number">10</span>; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">e = &amp;b; <span class="comment">// Error</span></span><br><span class="line">*e = <span class="number">7</span>; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> e = <span class="number">5</span>;</span><br><span class="line">d = &amp;e; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p><strong>代码示例2</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> c_a = a; <span class="comment">// c_a是带顶层const的，a的值被拷贝给了c_a，a可以改变但c_a不能。</span></span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> ptr_a = &amp;a; <span class="comment">// ptr_a是带顶层const的指针，它不能指向别处，但它指向的值可以改变。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* ptr_c_a = &amp;c_a; <span class="comment">// ptr_c_a是指向带底层const的对象的指针，它可以指向别的const int，但不能通过它来改变所指向的值。</span></span><br><span class="line">  <span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> ptr_c_a_2 = &amp;c_a; <span class="comment">// ptr_c_a_2同时带有顶层const和底层const。</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// c_a = b; // 错误：c_a是const，不能被赋值。</span></span><br><span class="line">  <span class="comment">// ptr_a = &amp;b; // 错误：ptr_a是const指针，不能指向别的地址。</span></span><br><span class="line">  ptr_c_a = &amp;b; <span class="comment">// 正确：ptr_c_a可以指向别的const int。</span></span><br><span class="line">  <span class="comment">// *ptr_c_a = b; // 错误：不能通过ptr_c_a修改所指向的内容，因为它指向的是const int。</span></span><br><span class="line">  <span class="comment">// ptr_c_a_2 = &amp;b; // 错误：ptr_c_a_2自身是const，不能指向别处。</span></span><br><span class="line">  <span class="comment">// *ptr_c_a_2 = b; // 错误：ptr_c_a_2指向的内容是const，不能通过它修改所指向的内容。</span></span><br></pre></td></tr></table></figure><h4 id="const函数"><a class="header-anchor" href="#const函数"></a>const函数</h4><p>修饰成员函数，说明该成员函数内不能修改成员变量</p><p><strong>小结</strong></p><p>这部分讲的大概很复杂很绕，其实不要去记什么常量引用，常量啥的，只需要记住<em><strong>const修饰对象将会导致一个不可更改的对象即可</strong></em>。对待这个东西我个人的处理看待方式就是，先搞清楚目标对象是什么样的const，然后再做处理，也许和指针引用搭配的时候是有点绕。在确定对象是在当前过程中readonly的，那么我们就应该对其const修饰，对于非内部数据的输入参数，应该将单纯的值类型<code>A a</code>更改为<code>const A&amp; a</code>，避免了拷贝，同时避免了对其修改，提高了效率</p><blockquote><p>练习：</p><p>（1）如果函数需要传入一个指针，是否需要为该指针加上const，把const加在指针不同的位置有什么区别；</p><p>（2）如果写的函数需要传入的参数是一个复杂类型的实例，传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const；</p></blockquote><h3 id="static"><a class="header-anchor" href="#static"></a>static</h3><p>对修饰对象更改其存储区域和生命周期，使得变量存储在静态区，在运行前分配了空间。由于直接存储在静态区，在多人开发项目时，为了防止与他人命名空间里的函数重名，通过static修饰能做到这一点。</p><p>修饰变量：变量所在对象只保存一个该变量，而且能够直接访问</p><p>修饰成员函数：不需要生成对象实例就可以访问该函数</p><h3 id="this"><a class="header-anchor" href="#this"></a>this</h3><p><strong>隐式访问</strong>：在类的非静态成员函数中，<code>this</code>指针是隐式可用的，它指向调用成员函数的对象实例</p><p><strong>类型</strong>：在类<code>T</code>的成员函数内，<code>this</code>的类型是<code>T* const</code>。这意味着<code>this</code>是一个指向<code>T</code>类型的常量指针，你不能改变<code>this</code>指针的指向，即不能让<code>this</code>指向另一个对象，但可以修改这个对象的成员（除非成员是<code>const</code>）</p><p><strong>const成员函数</strong>：在const成员函数中，<code>this</code>指针的类型是<code>const T* const</code>，这意味着你既不能改变<code>this</code>指针的指向，也不能通过<code>this</code>指针修改对象的成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数修改对象成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用this指针明确指定成员变量</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">    &#125;   </span><br><span class="line">     <span class="comment">// const成员函数，不修改任何成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出成员变量value的值</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// this-&gt;value = 5; // 错误：这会尝试修改成员变量，但在const成员函数中是不允许的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">10</span>); <span class="comment">// 调用成员函数设置value  此时是 T* const起作用</span></span><br><span class="line">    bj.<span class="built_in">printValue</span>(); <span class="comment">// 调用const成员函数此时是 const T* const起作用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inline"><a class="header-anchor" href="#inline"></a>inline</h3><p><strong>解释：</strong></p><p>内联函数是C++中的一种函数声明方式，它告诉编译器在调用函数时将函数的代码插入到调用处，而不是像普通函数那样通过跳转执行。这样做可以减少函数调用的开销，提高程序的执行效率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c = <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//add()函数被声明为内联函数。当调用add()函数时，编译器会尝试将函数的代码直接插入到调用处，而不是生成一个函数调用的指令</span></span><br></pre></td></tr></table></figure><p><strong>特性：</strong></p><p>编译器不一定会遵循inline关键字，它可能会根据具体情况决定是否将函数内联。通常情况下，编译器会将短小的函数内联，而对于较大的函数，编译器可能会忽略<code>inline</code>关键字</p><p><strong>优点：</strong></p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以</li></ol><p>**缺点：**包括可能导致代码体积增加，因为函数的代码会被复制到每个调用处，以及可能增加编译时间</p><p><strong>虚函数内联：</strong></p><p>虚函数是为了实现运行时多态性而设计的，它允许在派生类中重写基类中的同名函数，而在运行时动态地确定应该调用哪个版本的函数，内联函数允许在调用处直接展开函数的代码，以减少函数调用的开销。但是，对于虚函数来说，编译器需要在运行时确定实际调用的函数版本，这与内联函数的特性相矛盾。因此，虚函数通常不会被声明为内联函数。虚函数的实现通常涉及虚函数表（vtable）和虚函数指针（vptr），而内联函数的展开是在编译期间完成的，这两者的机制不兼容。</p><h3 id="auto"><a class="header-anchor" href="#auto"></a>auto</h3><p>类型推断关键字，但是推断结果有时会和初始类型小有区别，auto一般会忽略顶层const而保存底层const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>, &amp;r = i;</span><br><span class="line">   <span class="keyword">auto</span> b = r; <span class="comment">// b int not const int</span></span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> c = r; <span class="comment">// c const int</span></span><br><span class="line">   <span class="keyword">auto</span> d = &amp;i; <span class="comment">// d const int*</span></span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> e = &amp;i; <span class="comment">// e const int*</span></span><br></pre></td></tr></table></figure><h3 id="decltype"><a class="header-anchor" href="#decltype"></a>decltype</h3><p>decltype：类型推断，应用于想从目标推断定义目标的类型，选择并返回操作数的数据类型。但是注意decltype(目标)和decltype((目标))的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(i).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">decltype</span>((i)) k = i;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(k).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;i &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;j &lt;&lt; std::endl;<span class="comment">// j is an int, so the address of j is different from i</span></span><br><span class="line">std::cout &lt;&lt; &amp;k &lt;&lt; std::endl;<span class="comment">// k is a reference to i, so the address of k is the same as i</span></span><br></pre></td></tr></table></figure><h3 id="volatile"><a class="header-anchor" href="#volatile"></a>volatile</h3><p>编译器会对代码进行各种优化，包括对变量的读写操作进行优化，如将变量的值缓存到寄存器中，以提高程序的执行效率，告诉编译器不要对这些变量的读写操作进行优化。</p><h3 id="extern-“c”"><a class="header-anchor" href="#extern-“c”"></a>extern “c”</h3><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li></ul><h3 id="union"><a class="header-anchor" href="#union"></a>union</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值，当某个成员被赋值后其他成员变为未定义状态。</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li></ul><h3 id="explict"><a class="header-anchor" href="#explict"></a>explict</h3><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// constructor code</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 编译通过，隐式类型转换为 MyClass 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// constructor code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 编译错误，禁止隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="综合-📚"><a class="header-anchor" href="#综合-📚"></a>综合 📚</h2><h3 id="CPP编译步骤"><a class="header-anchor" href="#CPP编译步骤"></a>CPP编译步骤</h3><p>**预处理阶段：**在这个阶段，预处理器处理源文件中的预处理指令，比如 <code>#include</code>、<code>#define</code> 等。预处理器会根据这些指令展开头文件并替换宏定义，生成一个经过预处理的源文件  .ii</p><p>**编译阶段：**编译器将预处理后的源文件转换成汇编代码。在这个阶段，编译器会对源文件进行词法分析、语法分析和语义分析，并生成相应的中间代码或汇编代码 .s</p><p>**汇编阶段：**汇编器将汇编代码转换成机器码或者目标文件。在这个阶段，汇编器会将汇编代码转换成可重定位的机器码，并生成目标文件 .o</p><p>**链接阶段：**链接器将目标文件和库文件链接在一起，生成最终的可执行文件。在这个阶段，链接器会解析目标文件之间的引用关系，将它们连接到正确的位置上，并将库文件中的函数和变量链接到可执行文件中</p><h3 id="变量存储区域"><a class="header-anchor" href="#变量存储区域"></a>变量存储区域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|Text| low address</span><br><span class="line">|---------------|</span><br><span class="line">|data|</span><br><span class="line">|segment|</span><br><span class="line">|---------------|</span><br><span class="line">|HEAP|</span><br><span class="line">|---------------|</span><br><span class="line">|stack| high address</span><br></pre></td></tr></table></figure><p><strong>代码段</strong>：有时也称为文本段。它包含可执行指令（机器代码）。代码段通常是只读的，即<strong>程序代码区</strong></p><p><strong>数据段</strong>：数据段分为两部分：</p><ul><li><p><strong>初始化数据段</strong>：所有全局、静态static和常量数据都存储在数据段中，即<strong>静态存储区</strong></p></li><li><p><strong>未初始化数据段</strong>：所有未初始化的全局变量和静态变量都存储在该段中，也称为<strong>BSS段</strong></p></li></ul><p><strong>堆段</strong>：当程序在运行时使用calloc和malloc函数分配内存时，内存在堆中分配<br><strong>堆栈段</strong>：堆栈用于存储局部变量、函数参数和其他与函数相关的信息</p><h3 id="友元"><a class="header-anchor" href="#友元"></a>友元</h3><ul><li><p>能访问私有成员</p></li><li><p>破坏封装性</p></li><li><p>友元关系的单向性</p></li></ul><h3 id="引用"><a class="header-anchor" href="#引用"></a>引用</h3><p>左值引用（常规）</p><p>右值引用（new）</p><p>解决传统左值引用的一些限制，并支持移动语义。右值引用使用 <code>&amp;&amp;</code> 符号表示，用于绑定到临时对象（右值）或已经失效的对象，通常用于实现移动构造函数和移动赋值运算符，以提高对象的性能和效率</p><p>T&amp;&amp;</p><p>右值引用的主要优点包括：</p><ol><li>支持移动语义：右值引用允许将资源（如动态分配的内存）从一个对象移动到另一个对象，而不是传统的复制，从而提高性能和效率。</li><li>可用于完美转发：右值引用可以用于实现完美转发，即在函数模板中将参数以原始形式传递给其他函数，保留参数的值类别（左值或右值）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Default constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">MyObject</span>(<span class="type">const</span> MyObject&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">MyObject</span>(MyObject&amp;&amp;) <span class="keyword">noexcept</span> &#123; std::cout &lt;&lt; <span class="string">&quot;Move constructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受右值引用参数的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(MyObject&amp;&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// process the object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyObject obj1; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    <span class="function">MyObject <span class="title">obj2</span><span class="params">(obj1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时对象，并传递给 processObject 函数</span></span><br><span class="line">    <span class="built_in">processObject</span>(<span class="built_in">MyObject</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::move 将左值转换为右值</span></span><br><span class="line">    <span class="built_in">processObject</span>(std::<span class="built_in">move</span>(obj1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyObject</code> 类有一个移动构造函数，当创建临时对象并将其传递给 <code>processObject</code> 函数时，会调用移动构造函数。同时，通过使用 <code>std::move</code> 将左值 <code>obj1</code> 转换为右值后，也会调用移动构造函数</p><h3 id="OO"><a class="header-anchor" href="#OO"></a>OO</h3><p><strong>封装、继承</strong></p><p><strong>多态</strong></p><ul><li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li><li>多态是以封装和继承为基础的。</li><li>C++ 多态分类及实现：<ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol></li></ul><p><strong>静态多态</strong> - 函数重载</p><p><strong>动态多态</strong></p><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li><li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li></ul><p><strong>注意：</strong></p><ul><li>可以将派生类的对象赋值给基类的指针或引用，反之不可</li><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数</li></ul><h3 id="虚函数"><a class="header-anchor" href="#虚函数"></a>虚函数</h3><ol><li><strong>虚函数（Virtual Functions）</strong></li></ol><ul><li><strong>定义与目的</strong>：通过在函数声明前添加<code>virtual</code>关键字来定义虚函数。虚函数允许派生类重写（override）基类中的成员函数，实现运行时多态。</li><li><strong>运行时多态</strong>：虚函数的调用是在运行时决定的，而非编译时。这意味着当通过基类指针或引用调用一个虚函数时，将执行对象实际类型的函数版本。</li></ul><ol start="2"><li><strong>纯虚函数（Pure Virtual Functions）</strong></li></ol><ul><li><strong>定义</strong>：纯虚函数是一种没有实现的虚函数，通过在函数声明的结尾处添加<code>= 0</code>来指定。</li><li><strong>抽象基类</strong>：包含至少一个纯虚函数的类称为抽象基类。抽象基类不能实例化对象。</li></ul><ol start="3"><li><strong>虚析构函数（Virtual Destructors）</strong></li></ol><ul><li><strong>目的</strong>：确保通过基类指针删除派生类对象时能够调用正确的析构函数，从而避免资源泄漏。</li><li><strong>实现</strong>：将基类的析构函数声明为虚函数。</li></ul><ol start="4"><li><strong>虚表（Virtual Table，vtable）</strong></li></ol><ul><li><strong>作用</strong>：存储类的虚函数地址的数组。每个拥有虚函数的类都有一个对应的虚表。</li><li><strong>虚指针（vptr）</strong>：类的每个实例都包含一个指向其虚表的指针，即虚指针。</li></ul><ol start="5"><li><strong>虚继承（Virtual Inheritance）</strong></li></ol><ul><li><strong>解决问题</strong>：用于解决多重继承中的菱形继承问题（钻石问题），避免基类被多次继承导致的成员重复。</li><li><strong>实现</strong>：通过在继承时使用<code>virtual</code>关键字（如<code>class Derived : virtual public Base</code>）来声明虚继承。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal speaks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Mammal runs&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bird flies&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承，同时继承自 Mammal 和 Bird</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span> : <span class="keyword">public</span> Mammal, <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bat swoops&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bat bat;</span><br><span class="line">    bat.<span class="built_in">speak</span>(); <span class="comment">// 调用来自 Animal 的虚函数</span></span><br><span class="line">    bat.<span class="built_in">run</span>();   <span class="comment">// 调用来自 Mammal</span></span><br><span class="line">    bat.<span class="built_in">fly</span>();   <span class="comment">// 调用来自 Bird</span></span><br><span class="line">    bat.<span class="built_in">swoop</span>(); <span class="comment">// 调用来自 Bat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存分配"><a class="header-anchor" href="#内存分配"></a>内存分配</h3><p><strong>malloc、calloc、relloc - free</strong></p><ol><li><strong>malloc</strong>：<ul><li><strong>函数原型</strong>：<code>void* malloc(size_t size);</code></li><li><strong>功能</strong>：在堆上分配指定字节数的内存空间，并返回指向分配内存的指针。它不会初始化分配的内存，因此内存中的值是未定义的。</li><li><strong>使用</strong>：通常用于动态分配单个对象或一段连续的内存块。</li></ul></li><li><strong>calloc</strong>：<ul><li><strong>函数原型</strong>：<code>void* calloc(size_t num, size_t size);</code></li><li><strong>功能</strong>：在堆上分配指定数量和大小的连续内存块，并将内存初始化为零。</li><li><strong>使用</strong>：通常用于动态分配数组或结构体等需要初始化为零的内存。</li></ul></li><li><strong>realloc</strong>：<ul><li><strong>函数原型</strong>：<code>void* realloc(void* ptr, size_t size);</code></li><li><strong>功能</strong>：重新分配之前通过 malloc、calloc 或 realloc 分配的内存块的大小。如果旧的内存块大小足够容纳新的大小，则不会分配新的内存，而是扩展或缩小原有内存块。</li><li><strong>使用</strong>：常用于调整动态分配内存的大小，例如在动态数组扩展或缩小时使用。</li></ul></li></ol><p><strong>new - delete</strong></p><ol><li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li></ol><h3 id="delete-this？"><a class="header-anchor" href="#delete-this？"></a>delete this？</h3><p><code>delete this</code> 是合法的，但是要非常小心使用。<code>delete this</code> 语句用于在对象的成员函数中释放该对象的内存，但这种操作需要确保在调用该语句之后，不再访问已释放的内存，否则会导致未定义的行为或程序崩溃</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destroying object...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 使用成员函数中的 delete this</span></span><br><span class="line">        <span class="built_in">destroy</span>();</span><br><span class="line">        <span class="comment">// 试图访问已释放的内存，这是不安全的</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;After deletion...&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">doSomething</span>(); <span class="comment">// 调用 delete this</span></span><br><span class="line">    <span class="comment">// 尝试访问已释放的内存</span></span><br><span class="line">    <span class="comment">// obj-&gt;doSomething();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\\Doing something...</span><br><span class="line">\\Destroying object...</span><br><span class="line">\\Destructor called... </span><br></pre></td></tr></table></figure><h3 id="智能指针"><a class="header-anchor" href="#智能指针"></a>智能指针</h3><p><code>std::shared_ptr</code> 是 C++ 标准库提供的智能指针之一，用于管理动态分配的内存，实现自动的资源管理和内存释放，以避免内存泄漏和悬挂指针等问题。它实现了共享所有权的语义，允许多个 <code>std::shared_ptr</code> 实例共享同一块内存资源，并在不再需要时自动释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个动态分配的整数，由 shared_ptr 管理</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">// 输出指针所指向的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="string">&quot; addr:&quot;</span>&lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享所有权，创建第二个 shared_ptr 实例</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr;</span><br><span class="line">    <span class="comment">// 输出引用计数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference count: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新赋值</span></span><br><span class="line">    ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 输出新的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="string">&quot; addr:&quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出引用计数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference count: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Value: <span class="number">42</span> addr:<span class="number">000001</span>EF951CE780</span><br><span class="line">Reference count: <span class="number">2</span></span><br><span class="line">Value: <span class="number">10</span> addr:<span class="number">000001</span>EF951C5420</span><br><span class="line">Reference count: <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="STL容器一览"><a class="header-anchor" href="#STL容器一览"></a>STL容器一览</h3><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>容器</td><td>底层数据结构</td><td>时间复杂度</td><td>有无序</td><td>可不可重复</td><td>其他</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#array">array</a></td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#vector">vector</a></td><td>数组</td><td>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#deque">deque</a></td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#forward_list">forward_list</a></td><td>单向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#list">list</a></td><td>双向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#stack">stack</a></td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#queue">queue</a></td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue</a></td><td>vector + max-heap</td><td>插入、删除 O(log2n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#set">set</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multiset">multiset</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#map">map</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multimap">multimap</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set">unordered_set</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset">unordered_multiset</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map">unordered_map</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap">unordered_multimap</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table><h3 id="STL-算法一览"><a class="header-anchor" href="#STL-算法一览"></a>STL 算法一览</h3><table><thead><tr><th>算法</th><th>底层算法</th><th>时间复杂度</th><th>可不可重复</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/algorithm/find/">find</a></td><td>顺序查找</td><td>O(n)</td><td>可重复</td></tr><tr><td><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808">sort</a></td><td><a href="https://en.wikipedia.org/wiki/Introsort">内省排序</a></td><td>O(n*log2n)</td><td>可重复</td></tr></tbody></table><h3 id="经典排序"><a class="header-anchor" href="#经典排序"></a>经典排序</h3><p><img src="https://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_3.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起始&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#起始&quot;&gt;&lt;/a&gt;起始&lt;/h1&gt;
&lt;p&gt;这篇文章应该是 blog 里更的第二篇文章，最近开始准备今年夏季实习的事情，虽然C/C++&amp;amp;CSharp都会一点，但是感觉实习面试时的问题我会答不</summary>
      
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
    <category term="C++" scheme="https://ninokz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ninokz.github.io/2023/04/30/hello-world/"/>
    <id>https://ninokz.github.io/2023/04/30/hello-world/</id>
    <published>2023-04-30T15:00:01.604Z</published>
    <updated>2023-04-30T18:28:26.668Z</updated>
    
    <content type="html"><![CDATA[<p>天生万物以养民，民无一善可报天。<br>不知蝗蠹遍天下，苦尽苍生尽王臣。<br>人之生矣有贵贱，贵人长为天恩眷。<br>人生富贵总由天，草民之穷由天谴。<br>忽有狂徒夜磨刀，帝星飘摇荧惑高。<br>翻天覆地从今始，杀人何须惜手劳。<br>不忠之人曰可杀！不孝之人曰可杀！<br>不仁之人曰可杀！不义之人曰可杀！<br>不礼不智不信人，大西王曰杀杀杀！<br>我生不为逐鹿来，都门懒筑黄金台，<br>状元百官都如狗，总是刀下觳觫材。<br>传令麾下四王子，破城不须封刀匕。<br>山头代天树此碑，逆天之人立死跪亦死！</p><p><s>快说，谢谢大西王</s></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;天生万物以养民，民无一善可报天。&lt;br&gt;
不知蝗蠹遍天下，苦尽苍生尽王臣。&lt;br&gt;
人之生矣有贵贱，贵人长为天恩眷。&lt;br&gt;
人生富贵总由天，草民之穷由天谴。&lt;br&gt;
忽有狂徒夜磨刀，帝星飘摇荧惑高。&lt;br&gt;
翻天覆地从今始，杀人何须惜手劳。&lt;br&gt;
不忠之人曰可杀！不孝之</summary>
      
    
    
    
    
  </entry>
  
</feed>
