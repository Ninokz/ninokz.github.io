<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ninokz</title>
  
  <subtitle>你干嘛，哎哟</subtitle>
  <link href="https://ninokz.github.io/atom.xml" rel="self"/>
  
  <link href="https://ninokz.github.io/"/>
  <updated>2024-03-30T09:58:52.792Z</updated>
  <id>https://ninokz.github.io/</id>
  
  <author>
    <name>Ninokz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSharp 复习笔记</title>
    <link href="https://ninokz.github.io/2024/03/30/CSharp-for-interview/"/>
    <id>https://ninokz.github.io/2024/03/30/CSharp-for-interview/</id>
    <published>2024-03-30T08:39:17.981Z</published>
    <updated>2024-03-30T09:58:52.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起始"><a class="header-anchor" href="#起始"></a>起始</h1><blockquote><p>2024/03/30：开始</p></blockquote><h1 id="CSharp"><a class="header-anchor" href="#CSharp"></a>CSharp</h1><h2 id="Keywords-🔑"><a class="header-anchor" href="#Keywords-🔑"></a>Keywords 🔑</h2><h2 id="关键点分析🔨"><a class="header-anchor" href="#关键点分析🔨"></a>关键点分析🔨</h2><h3 id="CLR基础"><a class="header-anchor" href="#CLR基础"></a>CLR基础</h3><ul><li>CLR（Common Language Runtime）</li></ul><p>CLR，通常在.NET环境中指的是公共语言运行时（Common Language Runtime），它是.NET框架的一个重要组成部分。CLR为.NET应用程序提供了一个运行时环境，使得不同语言编写的代码能够在同一个平台上运行。</p><ul><li>CLR执行模型</li></ul><p>1源代码编译（得到托管模块）- 2托管模块合并（得到程序集）- 3加载公共语言运行时 - 4执行程序集代码</p><p><strong>1</strong> .NET环境中，源代码首先被对应语言的编译器编译成微软中间语言（MSIL，又称为CIL，公共中间语言，也成为托管代码）</p><p><strong>2</strong> 程序集是.NET应用程序中的基本构建块，它是一种封装了一组功能的编译后的代码单元，可以是可执行文件(.exe)或库文件(.dll)。程序集包含了执行程序所需的代码、元数据（描述程序集自身的数据）和资源（如图像、字符串等）</p><p><strong>4</strong> CLR的<strong>即时</strong>编译器（JIT）将MSIL编译成机器代码。这个过程是在程序执行的时候进行的，因此称为“即时编译”</p><h3 id="对象类型"><a class="header-anchor" href="#对象类型"></a>对象类型</h3><ul><li><p><strong>引用类型</strong></p><ul><li>引用类型是通过引用访问其数据的类型，它们通常存储在<strong>堆</strong>上。</li><li>引用类型的变量存储的是对对象的引用，而不是对象本身的值。</li><li>例如，类（class）、接口（interface）、委托（delegate）等都是引用类型，字符串（<code>string</code>，虽然表现得像值类型）是引用类型的示例</li></ul></li><li><p><strong>值类型</strong></p><ul><li>值类型是直接包含其数据值的类型，它们通常存储在<strong>栈</strong>上。</li><li>值类型的变量直接包含实际数据，而不是指向数据的引用</li><li>例如 int、double、struct</li></ul><p>如果所有类型都是引用类型，将导致性能显著下降（均在堆分配），所以提供了值类型这一轻量级类型</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> b = a;</span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line">Console.WriteLine(a); <span class="comment">// 输出：10</span></span><br><span class="line">Console.WriteLine(b); <span class="comment">// 输出：20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">Console.WriteLine(arr1[<span class="number">0</span>]); <span class="comment">// 输出：10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1;</span><br><span class="line">s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">Console.WriteLine(s1); <span class="comment">// 输出：hello</span></span><br><span class="line">Console.WriteLine(s2); <span class="comment">// 输出：world</span></span><br></pre></td></tr></table></figure><p><em>值类型设计</em>：</p><ul><li></li></ul><h3 id="装箱拆箱"><a class="header-anchor" href="#装箱拆箱"></a>装箱拆箱</h3><p>引用类型本身不涉及装箱和拆箱操作。装箱和拆箱是在值类型和引用类型之间转换时发生</p><ul><li><strong>装箱</strong>是将值类型转换为引用类型的过程，具体来说是将值类型包装在<code>System.Object</code>或者此值类型实现的任何接口类型的实例中。这个过程会<strong>创建对象在堆上的副本</strong>，并使得值类型像引用类型一样被处理。</li><li><strong>拆箱</strong>是将装箱的对象转换回原始的值类型的过程，这是一个显式的转换过程</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> val = <span class="number">10</span>; <span class="comment">// 这是一个值类型</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 装箱操作</span></span><br><span class="line"><span class="comment">// 将值类型转换为引用类型（这里是object类型）</span></span><br><span class="line"><span class="comment">// 这里，val的值被复制到一个新的object对象中，在堆上分配内存</span></span><br><span class="line"><span class="built_in">object</span> obj = val;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 现在obj持有val的一个装箱副本</span></span><br><span class="line"><span class="comment">// 拆箱操作</span></span><br><span class="line"><span class="comment">// 将引用类型转换回值类型</span></span><br><span class="line"><span class="comment">// 注意：拆箱时需要显式类型转换</span></span><br><span class="line"><span class="built_in">int</span> val2 = (<span class="built_in">int</span>)obj;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 修改val2的值并不会影响obj中的值，因为它们是独立存储的</span></span><br><span class="line">val2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;原始值: &quot;</span> + val); <span class="comment">// 输出：原始值: 10</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;装箱后的对象（通过拆箱后的值）: &quot;</span> + val2); <span class="comment">// 输出：装箱后的对象（通过拆箱后的值）: 20</span></span><br><span class="line"><span class="comment">// 注意：obj仍然保持着原始的装箱值10</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;装箱对象保持的值: &quot;</span> + (<span class="built_in">int</span>)obj); <span class="comment">// 输出：装箱对象保持的值: 10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起始&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#起始&quot;&gt;&lt;/a&gt;起始&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;2024/03/30：开始&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;CSharp&quot;&gt;&lt;a class=&quot;header</summary>
      
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
    <category term="CSharp" scheme="https://ninokz.github.io/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>C++ 复习笔记</title>
    <link href="https://ninokz.github.io/2024/03/27/cpp-review-for-interview/"/>
    <id>https://ninokz.github.io/2024/03/27/cpp-review-for-interview/</id>
    <published>2024-03-27T02:38:31.093Z</published>
    <updated>2024-03-30T08:41:19.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起始"><a class="header-anchor" href="#起始"></a>起始</h1><p>这篇文章应该是 blog 里更的第二篇文章，最近开始准备今年夏季实习的事情，虽然C/C++&amp;CSharp都会一点，但是感觉实习面试时的问题我会答不上来，所以准备了这篇笔记，一是记录学习笔记，二是督促一下自己吧。</p><p>注意本文在使用对象一词时并不单单限定于OO中的面向对象的对象的意思。</p><blockquote><p>2024/03/27：开始</p><p>2024/03/30: 大体差不多了，慢更</p></blockquote><h1 id="C-C-language"><a class="header-anchor" href="#C-C-language"></a>C/C++ language</h1><h2 id="Keywords-🔑"><a class="header-anchor" href="#Keywords-🔑"></a>Keywords 🔑</h2><h3 id="const"><a class="header-anchor" href="#const"></a>const</h3><p>const限定符用处是：对被修饰<strong>对象</strong>进行限定，使得对象在后续过程中不会被赋值修改，作用于函数则说明该函数不能修改成员变量</p><ul><li><p>const 引用（不可修改对象的引用）</p><p>指的是对常量对象进行引用，但是注意const引用是将对const 修饰的某类型对象限定为不可修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; aRef = a;</span><br><span class="line"><span class="type">int</span>&amp; b = aRef; </span><br><span class="line"><span class="comment">// Error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;const int&#x27;</span></span><br><span class="line"><span class="comment">// 因为如果成了，那我们可以根据b修改a的值了，而a本身不可修改</span></span><br></pre></td></tr></table></figure></li><li><p>const 指针（指向不可修改对象的指针、本身是不可修改的指针）</p><p>从以下代码看出const修饰的影响，有一个名词叫做顶层const和底层const，前者表示指针本身是常量（不可更改），后者表示指针所指对象是常量（对象不可更改），通常意义上来讲顶层const的限制弱于底层 const。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line">  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* c = &amp;a;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> d = &amp;b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> e = &amp;a;</span><br><span class="line">  </span><br><span class="line">c = &amp;b; <span class="comment">// OK</span></span><br><span class="line">*c = <span class="number">6</span>; <span class="comment">// Error</span></span><br><span class="line">  </span><br><span class="line">d = &amp;a; <span class="comment">// Error</span></span><br><span class="line">*d = <span class="number">10</span>; <span class="comment">// OK</span></span><br><span class="line">  </span><br><span class="line">e = &amp;b; <span class="comment">// Error</span></span><br><span class="line">*e = <span class="number">7</span>; <span class="comment">// Error</span></span><br><span class="line">  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> e = <span class="number">5</span>;</span><br><span class="line">d = &amp;e; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure></li><li><p>区别于宏</p><table><thead><tr><th>宏定义 #define</th><th>const 常量</th></tr></thead><tbody><tr><td>宏定义，相当于字符替换</td><td>常量声明</td></tr><tr><td>预处理器处理</td><td>编译器处理</td></tr><tr><td>无类型安全检查</td><td>有类型安全检查</td></tr><tr><td>不分配内存</td><td>要分配内存</td></tr><tr><td>存储在代码段</td><td>存储在数据段</td></tr><tr><td>可通过 <code>#undef</code> 取消</td><td>不可取消</td></tr></tbody></table></li></ul><p>这部分讲的大概很复杂很绕，其实不要去记什么常量引用，常量啥的，只需要记住<em><strong>const修饰对象将会导致一个不可更改的对象即可</strong></em>。对待这个东西我个人的处理看待方式就是，先搞清楚目标对象是什么样的const，然后再做处理。</p><h3 id="static"><a class="header-anchor" href="#static"></a>static</h3><p>对修饰对象更改其存储区域和生命周期，使得变量存储在静态区，在运行前分配了空间。由于直接存储在静态区，</p><p>在多人开发项目时，为了防止与他人命名空间里的函数重名。</p><p>修饰变量：变量所在对象只保存一个该变量，而且能够直接访问</p><p>修饰成员函数：不需要生成对象就可以访问该函数</p><h3 id="auto"><a class="header-anchor" href="#auto"></a>auto</h3><p>类型推断关键字，但是推断结果有时会和初始类型小有区别，auto一般会忽略顶层const而保存底层const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>, &amp;r = i;</span><br><span class="line">   <span class="keyword">auto</span> b = r; <span class="comment">// b int not const int</span></span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> c = r; <span class="comment">// c const int</span></span><br><span class="line">   <span class="keyword">auto</span> d = &amp;i; <span class="comment">// d const int*</span></span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> e = &amp;i; <span class="comment">// e const int*</span></span><br></pre></td></tr></table></figure><h3 id="decltype"><a class="header-anchor" href="#decltype"></a>decltype</h3><p>decltype：类型推断，应用于想从目标推断定义目标的类型，选择并返回操作数的数据类型。但是注意decltype(目标)和decltype((目标))的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(i).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">decltype</span>((i)) k = i;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(k).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;i &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;j &lt;&lt; std::endl;<span class="comment">// j is an int, so the address of j is different from i</span></span><br><span class="line">std::cout &lt;&lt; &amp;k &lt;&lt; std::endl;<span class="comment">// k is a reference to i, so the address of k is the same as i</span></span><br></pre></td></tr></table></figure><h3 id="inline内联"><a class="header-anchor" href="#inline内联"></a>inline内联</h3><p><strong>解释：</strong></p><p>内联函数是C++中的一种函数声明方式，它告诉编译器在调用函数时将函数的代码插入到调用处，而不是像普通函数那样通过跳转执行。这样做可以减少函数调用的开销，提高程序的执行效率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c = <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//add()函数被声明为内联函数。当调用add()函数时，编译器会尝试将函数的代码直接插入到调用处，而不是生成一个函数调用的指令</span></span><br></pre></td></tr></table></figure><p><strong>特性：</strong></p><p>编译器不一定会遵循inline关键字，它可能会根据具体情况决定是否将函数内联。通常情况下，编译器会将短小的函数内联，而对于较大的函数，编译器可能会忽略<code>inline</code>关键字</p><p><strong>优点：</strong></p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以</li></ol><p>**缺点：**包括可能导致代码体积增加，因为函数的代码会被复制到每个调用处，以及可能增加编译时间</p><p><strong>虚函数内联：</strong></p><p>虚函数是为了实现运行时多态性而设计的，它允许在派生类中重写基类中的同名函数，而在运行时动态地确定应该调用哪个版本的函数，内联函数允许在调用处直接展开函数的代码，以减少函数调用的开销。但是，对于虚函数来说，编译器需要在运行时确定实际调用的函数版本，这与内联函数的特性相矛盾。因此，虚函数通常不会被声明为内联函数。虚函数的实现通常涉及虚函数表（vtable）和虚函数指针（vptr），而内联函数的展开是在编译期间完成的，这两者的机制不兼容。</p><h3 id="volatile"><a class="header-anchor" href="#volatile"></a>volatile</h3><p>编译器会对代码进行各种优化，包括对变量的读写操作进行优化，如将变量的值缓存到寄存器中，以提高程序的执行效率，告诉编译器不要对这些变量的读写操作进行优化。</p><h3 id="extern-“c”"><a class="header-anchor" href="#extern-“c”"></a>extern “c”</h3><ul><li>被 extern 限定的函数或变量是 extern 类型的</li><li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li></ul><h3 id="union"><a class="header-anchor" href="#union"></a>union</h3><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值，当某个成员被赋值后其他成员变为未定义状态。</p><ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li></ul><h3 id="explict"><a class="header-anchor" href="#explict"></a>explict</h3><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// constructor code</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 编译通过，隐式类型转换为 MyClass 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// constructor code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 编译错误，禁止隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="综合"><a class="header-anchor" href="#综合"></a>综合</h2><h3 id="CPP编译步骤"><a class="header-anchor" href="#CPP编译步骤"></a>CPP编译步骤</h3><p>**预处理阶段：**在这个阶段，预处理器处理源文件中的预处理指令，比如 <code>#include</code>、<code>#define</code> 等。预处理器会根据这些指令展开头文件并替换宏定义，生成一个经过预处理的源文件  .ii</p><p>**编译阶段：**编译器将预处理后的源文件转换成汇编代码。在这个阶段，编译器会对源文件进行词法分析、语法分析和语义分析，并生成相应的中间代码或汇编代码 .s</p><p>**汇编阶段：**汇编器将汇编代码转换成机器码或者目标文件。在这个阶段，汇编器会将汇编代码转换成可重定位的机器码，并生成目标文件 .o</p><p>**链接阶段：**链接器将目标文件和库文件链接在一起，生成最终的可执行文件。在这个阶段，链接器会解析目标文件之间的引用关系，将它们连接到正确的位置上，并将库文件中的函数和变量链接到可执行文件中</p><h3 id="变量存储区域"><a class="header-anchor" href="#变量存储区域"></a>变量存储区域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|Text| low address</span><br><span class="line">|---------------|</span><br><span class="line">|data|</span><br><span class="line">|segment|</span><br><span class="line">|---------------|</span><br><span class="line">|HEAP|</span><br><span class="line">|---------------|</span><br><span class="line">|stack| high address</span><br></pre></td></tr></table></figure><p><strong>代码段</strong>：有时也称为文本段。它包含可执行指令（机器代码）。代码段通常是只读的。 <strong>Text</strong><br><strong>数据段</strong>：数据段分为两部分：<strong>初始化数据段</strong>：所有全局、静态和常量数据都存储在数据段中；<strong>未初始化数据段</strong>：所有未初始化的全局变量和静态变量都存储在该段中，也称为BSS段。<br><strong>堆段</strong>：当程序在运行时使用calloc和malloc函数分配内存时，内存在堆中分配。<br><strong>堆栈段</strong>：堆栈用于存储局部变量、函数参数和其他与函数相关的信息。</p><h3 id="友元"><a class="header-anchor" href="#友元"></a>友元</h3><ul><li><p>能访问私有成员</p></li><li><p>破坏封装性</p></li><li><p>友元关系的单向性</p></li></ul><h3 id="引用"><a class="header-anchor" href="#引用"></a>引用</h3><p>左值引用（常规）</p><p>右值引用（new）</p><p>解决传统左值引用的一些限制，并支持移动语义。右值引用使用 <code>&amp;&amp;</code> 符号表示，用于绑定到临时对象（右值）或已经失效的对象，通常用于实现移动构造函数和移动赋值运算符，以提高对象的性能和效率</p><p>T&amp;&amp;</p><p>右值引用的主要优点包括：</p><ol><li>支持移动语义：右值引用允许将资源（如动态分配的内存）从一个对象移动到另一个对象，而不是传统的复制，从而提高性能和效率。</li><li>可用于完美转发：右值引用可以用于实现完美转发，即在函数模板中将参数以原始形式传递给其他函数，保留参数的值类别（左值或右值）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// for std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyObject</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Default constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">MyObject</span>(<span class="type">const</span> MyObject&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy constructor\n&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">MyObject</span>(MyObject&amp;&amp;) <span class="keyword">noexcept</span> &#123; std::cout &lt;&lt; <span class="string">&quot;Move constructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受右值引用参数的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(MyObject&amp;&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// process the object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyObject obj1; <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    <span class="function">MyObject <span class="title">obj2</span><span class="params">(obj1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时对象，并传递给 processObject 函数</span></span><br><span class="line">    <span class="built_in">processObject</span>(<span class="built_in">MyObject</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::move 将左值转换为右值</span></span><br><span class="line">    <span class="built_in">processObject</span>(std::<span class="built_in">move</span>(obj1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyObject</code> 类有一个移动构造函数，当创建临时对象并将其传递给 <code>processObject</code> 函数时，会调用移动构造函数。同时，通过使用 <code>std::move</code> 将左值 <code>obj1</code> 转换为右值后，也会调用移动构造函数</p><h3 id="OO"><a class="header-anchor" href="#OO"></a>OO</h3><p><strong>封装、继承</strong></p><p><strong>多态</strong></p><ul><li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li><li>多态是以封装和继承为基础的。</li><li>C++ 多态分类及实现：<ol><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ol></li></ul><p><strong>静态多态</strong> - 函数重载</p><p><strong>动态多态</strong></p><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li><li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li></ul><p><strong>注意：</strong></p><ul><li>可以将派生类的对象赋值给基类的指针或引用，反之不可</li><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数</li></ul><h3 id="虚函数"><a class="header-anchor" href="#虚函数"></a>虚函数</h3><ol><li><strong>虚函数（Virtual Functions）</strong></li></ol><ul><li><strong>定义与目的</strong>：通过在函数声明前添加<code>virtual</code>关键字来定义虚函数。虚函数允许派生类重写（override）基类中的成员函数，实现运行时多态。</li><li><strong>运行时多态</strong>：虚函数的调用是在运行时决定的，而非编译时。这意味着当通过基类指针或引用调用一个虚函数时，将执行对象实际类型的函数版本。</li></ul><ol start="2"><li><strong>纯虚函数（Pure Virtual Functions）</strong></li></ol><ul><li><strong>定义</strong>：纯虚函数是一种没有实现的虚函数，通过在函数声明的结尾处添加<code>= 0</code>来指定。</li><li><strong>抽象基类</strong>：包含至少一个纯虚函数的类称为抽象基类。抽象基类不能实例化对象。</li></ul><ol start="3"><li><strong>虚析构函数（Virtual Destructors）</strong></li></ol><ul><li><strong>目的</strong>：确保通过基类指针删除派生类对象时能够调用正确的析构函数，从而避免资源泄漏。</li><li><strong>实现</strong>：将基类的析构函数声明为虚函数。</li></ul><ol start="4"><li><strong>虚表（Virtual Table，vtable）</strong></li></ol><ul><li><strong>作用</strong>：存储类的虚函数地址的数组。每个拥有虚函数的类都有一个对应的虚表。</li><li><strong>虚指针（vptr）</strong>：类的每个实例都包含一个指向其虚表的指针，即虚指针。</li></ul><ol start="5"><li><strong>虚继承（Virtual Inheritance）</strong></li></ol><ul><li><strong>解决问题</strong>：用于解决多重继承中的菱形继承问题（钻石问题），避免基类被多次继承导致的成员重复。</li><li><strong>实现</strong>：通过在继承时使用<code>virtual</code>关键字（如<code>class Derived : virtual public Base</code>）来声明虚继承。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal speaks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Mammal runs&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bird flies&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承，同时继承自 Mammal 和 Bird</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span> : <span class="keyword">public</span> Mammal, <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bat swoops&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bat bat;</span><br><span class="line">    bat.<span class="built_in">speak</span>(); <span class="comment">// 调用来自 Animal 的虚函数</span></span><br><span class="line">    bat.<span class="built_in">run</span>();   <span class="comment">// 调用来自 Mammal</span></span><br><span class="line">    bat.<span class="built_in">fly</span>();   <span class="comment">// 调用来自 Bird</span></span><br><span class="line">    bat.<span class="built_in">swoop</span>(); <span class="comment">// 调用来自 Bat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存分配"><a class="header-anchor" href="#内存分配"></a>内存分配</h3><p><strong>malloc、calloc、relloc - free</strong></p><ol><li><strong>malloc</strong>：<ul><li><strong>函数原型</strong>：<code>void* malloc(size_t size);</code></li><li><strong>功能</strong>：在堆上分配指定字节数的内存空间，并返回指向分配内存的指针。它不会初始化分配的内存，因此内存中的值是未定义的。</li><li><strong>使用</strong>：通常用于动态分配单个对象或一段连续的内存块。</li></ul></li><li><strong>calloc</strong>：<ul><li><strong>函数原型</strong>：<code>void* calloc(size_t num, size_t size);</code></li><li><strong>功能</strong>：在堆上分配指定数量和大小的连续内存块，并将内存初始化为零。</li><li><strong>使用</strong>：通常用于动态分配数组或结构体等需要初始化为零的内存。</li></ul></li><li><strong>realloc</strong>：<ul><li><strong>函数原型</strong>：<code>void* realloc(void* ptr, size_t size);</code></li><li><strong>功能</strong>：重新分配之前通过 malloc、calloc 或 realloc 分配的内存块的大小。如果旧的内存块大小足够容纳新的大小，则不会分配新的内存，而是扩展或缩小原有内存块。</li><li><strong>使用</strong>：常用于调整动态分配内存的大小，例如在动态数组扩展或缩小时使用。</li></ul></li></ol><p><strong>new - delete</strong></p><ol><li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li></ol><h3 id="delete-this？"><a class="header-anchor" href="#delete-this？"></a>delete this？</h3><p><code>delete this</code> 是合法的，但是要非常小心使用。<code>delete this</code> 语句用于在对象的成员函数中释放该对象的内存，但这种操作需要确保在调用该语句之后，不再访问已释放的内存，否则会导致未定义的行为或程序崩溃</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destroying object...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 使用成员函数中的 delete this</span></span><br><span class="line">        <span class="built_in">destroy</span>();</span><br><span class="line">        <span class="comment">// 试图访问已释放的内存，这是不安全的</span></span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;After deletion...&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass* obj = <span class="keyword">new</span> <span class="built_in">MyClass</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">doSomething</span>(); <span class="comment">// 调用 delete this</span></span><br><span class="line">    <span class="comment">// 尝试访问已释放的内存</span></span><br><span class="line">    <span class="comment">// obj-&gt;doSomething();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\\Doing something...</span><br><span class="line">\\Destroying object...</span><br><span class="line">\\Destructor called... </span><br></pre></td></tr></table></figure><h3 id="智能指针"><a class="header-anchor" href="#智能指针"></a>智能指针</h3><p><code>std::shared_ptr</code> 是 C++ 标准库提供的智能指针之一，用于管理动态分配的内存，实现自动的资源管理和内存释放，以避免内存泄漏和悬挂指针等问题。它实现了共享所有权的语义，允许多个 <code>std::shared_ptr</code> 实例共享同一块内存资源，并在不再需要时自动释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个动态分配的整数，由 shared_ptr 管理</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">// 输出指针所指向的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="string">&quot; addr:&quot;</span>&lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享所有权，创建第二个 shared_ptr 实例</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr;</span><br><span class="line">    <span class="comment">// 输出引用计数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference count: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新赋值</span></span><br><span class="line">    ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 输出新的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="string">&quot; addr:&quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出引用计数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference count: &quot;</span> &lt;&lt; ptr.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Value: <span class="number">42</span> addr:<span class="number">000001</span>EF951CE780</span><br><span class="line">Reference count: <span class="number">2</span></span><br><span class="line">Value: <span class="number">10</span> addr:<span class="number">000001</span>EF951C5420</span><br><span class="line">Reference count: <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="STL"><a class="header-anchor" href="#STL"></a>STL</h3><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>容器</td><td>底层数据结构</td><td>时间复杂度</td><td>有无序</td><td>可不可重复</td><td>其他</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#array">array</a></td><td>数组</td><td>随机读改 O(1)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#vector">vector</a></td><td>数组</td><td>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#deque">deque</a></td><td>双端队列</td><td>头尾插入、头尾删除 O(1)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#forward_list">forward_list</a></td><td>单向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#list">list</a></td><td>双向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#stack">stack</a></td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#queue">queue</a></td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue</a></td><td>vector + max-heap</td><td>插入、删除 O(log2n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#set">set</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multiset">multiset</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#map">map</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multimap">multimap</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set">unordered_set</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset">unordered_multiset</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map">unordered_map</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap">unordered_multimap</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table><h3 id="STL-算法"><a class="header-anchor" href="#STL-算法"></a>STL 算法</h3><table><thead><tr><th>算法</th><th>底层算法</th><th>时间复杂度</th><th>可不可重复</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/algorithm/find/">find</a></td><td>顺序查找</td><td>O(n)</td><td>可重复</td></tr><tr><td><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808">sort</a></td><td><a href="https://en.wikipedia.org/wiki/Introsort">内省排序</a></td><td>O(n*log2n)</td><td>可重复</td></tr></tbody></table><h3 id="经典排序"><a class="header-anchor" href="#经典排序"></a>经典排序</h3><p><img src="https://cuijiahua.com/wp-content/uploads/2018/01/algorithm_9_3.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起始&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#起始&quot;&gt;&lt;/a&gt;起始&lt;/h1&gt;
&lt;p&gt;这篇文章应该是 blog 里更的第二篇文章，最近开始准备今年夏季实习的事情，虽然C/C++&amp;amp;CSharp都会一点，但是感觉实习面试时的问题我会答不</summary>
      
    
    
    
    <category term="Learning" scheme="https://ninokz.github.io/categories/Learning/"/>
    
    
    <category term="C++" scheme="https://ninokz.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ninokz.github.io/2023/04/30/hello-world/"/>
    <id>https://ninokz.github.io/2023/04/30/hello-world/</id>
    <published>2023-04-30T15:00:01.604Z</published>
    <updated>2023-04-30T18:28:26.668Z</updated>
    
    <content type="html"><![CDATA[<p>天生万物以养民，民无一善可报天。<br>不知蝗蠹遍天下，苦尽苍生尽王臣。<br>人之生矣有贵贱，贵人长为天恩眷。<br>人生富贵总由天，草民之穷由天谴。<br>忽有狂徒夜磨刀，帝星飘摇荧惑高。<br>翻天覆地从今始，杀人何须惜手劳。<br>不忠之人曰可杀！不孝之人曰可杀！<br>不仁之人曰可杀！不义之人曰可杀！<br>不礼不智不信人，大西王曰杀杀杀！<br>我生不为逐鹿来，都门懒筑黄金台，<br>状元百官都如狗，总是刀下觳觫材。<br>传令麾下四王子，破城不须封刀匕。<br>山头代天树此碑，逆天之人立死跪亦死！</p><p><s>快说，谢谢大西王</s></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;天生万物以养民，民无一善可报天。&lt;br&gt;
不知蝗蠹遍天下，苦尽苍生尽王臣。&lt;br&gt;
人之生矣有贵贱，贵人长为天恩眷。&lt;br&gt;
人生富贵总由天，草民之穷由天谴。&lt;br&gt;
忽有狂徒夜磨刀，帝星飘摇荧惑高。&lt;br&gt;
翻天覆地从今始，杀人何须惜手劳。&lt;br&gt;
不忠之人曰可杀！不孝之</summary>
      
    
    
    
    
  </entry>
  
</feed>
