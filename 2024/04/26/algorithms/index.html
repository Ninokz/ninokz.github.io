<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法学习 | Ninokz</title><meta name="author" content="Ninokz"><meta name="copyright" content="Ninokz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="算法学习">
<meta property="og:url" content="https://ninokz.github.io/2024/04/26/algorithms/index.html">
<meta property="og:site_name" content="Ninokz">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/design/avatar/96275146_p0_master1200.jpg">
<meta property="article:published_time" content="2024-04-26T07:43:41.100Z">
<meta property="article:modified_time" content="2024-05-14T04:51:51.758Z">
<meta property="article:author" content="Ninokz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/design/avatar/96275146_p0_master1200.jpg"><link rel="shortcut icon" href="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/design/other/N.png"><link rel="canonical" href="https://ninokz.github.io/2024/04/26/algorithms/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2024-05-14 12:51:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Ninokz" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/design/avatar/96275146_p0_master1200.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/daily/"><i class="fa-fw fas fa-timeline"></i><span> 日常</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/"><i class="fa-fw fas fa-circle-nodes"></i><span> 本站</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-cat"></i><span> 我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Ninokz"><span class="site-name">Ninokz</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/daily/"><i class="fa-fw fas fa-timeline"></i><span> 日常</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 关于</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/"><i class="fa-fw fas fa-circle-nodes"></i><span> 本站</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-cat"></i><span> 我</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-26T07:43:41.100Z" title="发表于 2024-04-26 15:43:41">2024-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-14T04:51:51.758Z" title="更新于 2024-05-14 12:51:51">2024-05-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Learning/">Learning</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a class="header-anchor" href="#前言"></a>前言</h1>
<h3 id="数组"><a class="header-anchor" href="#数组"></a>数组</h3>
<h5 id="快慢-左右index"><a class="header-anchor" href="#快慢-左右index"></a>快慢&amp;左右index</h5>
<p>快慢index核心就是快慢指针问题，数组能通过[]直接访问，所以一般没用数组指针++\–访问</p>
<h6 id="26-力扣-有序数组去重"><a class="header-anchor" href="#26-力扣-有序数组去重"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/submissions/528446779/">26.力扣-有序数组去重</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow] != nums[fast]) &#123;</span><br><span class="line">            <span class="comment">/// 先递增slow再赋值</span></span><br><span class="line">            slow++;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="27-移除元素"><a class="header-anchor" href="#27-移除元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27.移除元素</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="283-移动-0"><a class="header-anchor" href="#283-移动-0"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/description/">283.移动 0</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    slow++;</span><br><span class="line">    <span class="keyword">while</span> (slow &lt; len)</span><br><span class="line">        nums[slow++] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="5-最长回文子串"><a class="header-anchor" href="#5-最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">5.最长回文子串</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">palindrome</span><span class="params">(std::string s, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.<span class="built_in">length</span>() &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s1 = <span class="built_in">palindrome</span>(s, i, i);</span><br><span class="line">        string s2 = <span class="built_in">palindrome</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        string cur = s1.<span class="built_in">length</span>() &gt; s2.<span class="built_in">length</span>() ? s1 : s2;</span><br><span class="line">        res = res.<span class="built_in">length</span>() &gt; cur.<span class="built_in">length</span>() ? res : cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="977-有序数组的平方"><a class="header-anchor" href="#977-有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977.有序数组的平方</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> cur = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ln = nums[left];</span><br><span class="line">        <span class="type">int</span> rn = nums[right];</span><br><span class="line"></span><br><span class="line">        ln *= ln;</span><br><span class="line">        rn *= rn;</span><br><span class="line">        <span class="keyword">if</span> (ln &gt; rn) &#123;</span><br><span class="line">            vec[cur] = ln;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vec[cur] = rn;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="11-盛最多水的容器"><a class="header-anchor" href="#11-盛最多水的容器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> wide = right - left;</span><br><span class="line">        <span class="type">int</span> lh = height[left];</span><br><span class="line">        <span class="type">int</span> rh = height[right];</span><br><span class="line">        <span class="type">int</span> hight = std::<span class="built_in">min</span>(lh, rh);</span><br><span class="line"></span><br><span class="line">        maxarea = maxarea &gt; hight * wide ? maxarea : hight * wide;</span><br><span class="line">        <span class="keyword">if</span> (lh &lt; rh)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="42-接雨水"><a class="header-anchor" href="#42-接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFrontMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">        max = max &gt; nums[i] ? max : nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBehinMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;=index; i--) &#123;</span><br><span class="line">        max = max &gt; nums[i] ? max : nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fmaxV</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(<span class="built_in">getFrontMax</span>(nums, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">BmaxV</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(<span class="built_in">getBehinMax</span>(nums, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; fm = <span class="built_in">fmaxV</span>(height);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; bm = <span class="built_in">BmaxV</span>(height);</span><br><span class="line">    <span class="type">int</span> cont = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> f = fm[i];</span><br><span class="line">        <span class="type">int</span> b = bm[i];</span><br><span class="line">        <span class="type">int</span> min = std::<span class="built_in">min</span>(f, b);</span><br><span class="line">        cont += min - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cont;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///这里求前后缀最大时，时间复杂度高优化如下</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fmaxV</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="type">int</span> currentMax = nums[<span class="number">0</span>];</span><br><span class="line">    v1[<span class="number">0</span>] = currentMax;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; currentMax) &#123;</span><br><span class="line">            currentMax = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        v1[i] = currentMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bmaxV</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> currentMax = nums[n - <span class="number">1</span>];</span><br><span class="line">    v1[n - <span class="number">1</span>] = currentMax;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; currentMax) &#123;</span><br><span class="line">            currentMax = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        v1[i] = currentMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Qg411q7ia/">接水问题相关讲解</a></p>
<h5 id="二分问题"><a class="header-anchor" href="#二分问题"></a>二分问题</h5>
<blockquote>
<p>一般二分涉及到直接搜索目标、目标左边界、目标右边界的三类问题，第一类是直接搜很好解决，问题是第二类和第三类，</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 如果 target 不存在，搜索左侧边界的二分搜索返回的索引是大于 target 的最小索引</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchLeftIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果 target 不存在，搜索右侧边界的二分搜索返回的索引是小于 target 的最大索引。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchRightIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left<span class="number">-1</span> &lt; <span class="number">0</span> || left<span class="number">-1</span> &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[left<span class="number">-1</span>] == target ? (left<span class="number">-1</span>) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="704-二分查找"><a class="header-anchor" href="#704-二分查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704.二分查找</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="35-搜索插入位置"><a class="header-anchor" href="#35-搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="34-在排序数组中查找元素的第一个和最后一个位置"><a class="header-anchor" href="#34-在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">-1</span>, end = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123; start, end &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="33-搜索旋转排序数组-无重复值"><a class="header-anchor" href="#33-搜索旋转排序数组-无重复值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组-无重复值</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &gt; nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[right] &amp;&amp; target &gt; nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="81-搜索旋转排序数组-II-有重复值"><a class="header-anchor" href="#81-搜索旋转排序数组-II-有重复值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II-有重复值</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">		<span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; nums[right])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// [left, mid)</span></span><br><span class="line">				right = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (target &lt;= nums[right] &amp;&amp; target &gt; nums[mid])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// (mid, right]</span></span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				right = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="153-寻找旋转排序数组中的最小值-多次旋转"><a class="header-anchor" href="#153-寻找旋转排序数组中的最小值-多次旋转"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值-多次旋转</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> minNumber = nums.<span class="built_in">front</span>();</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="comment">/// 当nums[mid] &gt; nums[right]时，说明最小值还在右边，mid在断崖的左边</span></span><br><span class="line">        <span class="comment">/// 当nums[mid] &lt; nums[right]时，说明最小值还在左边，mid在断崖的右边</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; nums[right])</span><br><span class="line">		&#123;</span><br><span class="line">			right = mid;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minNumber &lt; nums[left<span class="number">-1</span>] ? minNumber : nums[left<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="4-寻找两个正序数组的中位数"><a class="header-anchor" href="#4-寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> m = nums2.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n &gt; m) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> L1, L2, R1, R2, c1, c2, lo = <span class="number">0</span>, hi = <span class="number">2</span> * n;</span><br><span class="line">	<span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">		c1 = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">		c2 = m + n - c1;</span><br><span class="line">		L1 = (c1 == <span class="number">0</span>) ? INT_MIN : nums1[(c1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">		R1 = (c1 == <span class="number">2</span> * n) ? INT_MAX : nums1[c1 / <span class="number">2</span>];</span><br><span class="line">		L2 = (c2 == <span class="number">0</span>) ? INT_MIN : nums2[(c2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">		R2 = (c2 == <span class="number">2</span> * m) ? INT_MAX : nums2[c2 / <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">if</span> (L1 &gt; R2) &#123;</span><br><span class="line">			hi = c1 - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (L2 &gt; R1) &#123;</span><br><span class="line">			lo = c1 + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">max</span>(L1, L2) + <span class="built_in">min</span>(R1, R2)) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>c1 和 c2</strong>：分别表示在 <code>nums1</code> 和 <code>nums2</code> 中的分割线位置。</p>
<p><strong>L1, R1, L2, R2</strong>：分别表示分割线左侧和右侧的元素。其中 <code>L1</code> 和 <code>L2</code> 是分割线左侧的元素，<code>R1</code> 和 <code>R2</code> 是分割线右侧的元素。</p>
<p><strong>lo 和 hi</strong>：用于二分搜索的范围。</p>
<ol>
<li><code>c1 = (lo + hi) / 2;</code>
<ul>
<li>这里通过二分法计算 <code>nums1</code> 的分割线位置。<code>lo</code> 和 <code>hi</code> 是搜索的边界索引，<code>c1</code> 是当前的中点。这决定了在 <code>nums1</code> 中左侧将有多少个元素。</li>
</ul>
</li>
<li><code>c2 = m + n - c1;</code>
<ul>
<li><code>c2</code> 是 <code>nums2</code> 中的分割线位置。由于我们需要确保左右两部分的元素总数相等（或者在总数为奇数时，左侧比右侧多一个元素），<code>c2</code> 是根据 <code>c1</code> 和两个数组总长度计算得出。</li>
</ul>
</li>
<li><code>L1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2];</code>
<ul>
<li><code>L1</code> 是 <code>nums1</code> 中分割线左侧的元素。如果 <code>c1</code> 是 0，说明 <code>nums1</code> 的分割线在数组的最开始位置，左侧没有元素，因此 <code>L1</code> 赋值为 <code>INT_MIN</code>（一个非常小的数，表示没有元素的情况）。否则，<code>L1</code> 是分割线前的那个元素。</li>
</ul>
</li>
<li><code>R1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2];</code>
<ul>
<li><code>R1</code> 是 <code>nums1</code> 中分割线右侧的元素。如果 <code>c1</code> 是 <code>2 * n</code>（即分割线在数组的最末端之后），说明 <code>nums1</code> 的右侧没有元素，因此 <code>R1</code> 赋值为 <code>INT_MAX</code>（一个非常大的数，表示没有元素的情况）。否则，<code>R1</code> 是分割线上的元素。</li>
</ul>
</li>
<li><code>L2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2];</code>
<ul>
<li><code>L2</code> 是 <code>nums2</code> 中分割线左侧的元素。与 <code>L1</code> 的计算类似，如果 <code>c2</code> 是 0，说明 <code>nums2</code> 的分割线在数组的最开始位置，因此 <code>L2</code> 也赋值为 <code>INT_MIN</code>。</li>
</ul>
</li>
<li><code>R2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2];</code>
<ul>
<li><code>R2</code> 是 <code>nums2</code> 中分割线右侧的元素。与 <code>R1</code> 的计算类似，如果 <code>c2</code> 是 <code>2 * m</code>，说明 <code>nums2</code> 的右侧没有元素，因此 <code>R2</code> 赋值为 <code>INT_MAX</code>。</li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="滑动窗口"><a class="header-anchor" href="#滑动窗口"></a>滑动窗口</h5>
<blockquote>
<p>今天完成了大部分滑动窗口的题，经过总结发现，滑动窗口的题型分为2种类型：<br>
1.窗口长度不变 [见下图1]</p>
<p>参考题型:643、2379、3、53、424、438、713、1343、239、480</p>
<p>2.窗口长度变化 [见下图2]<br>
在练习完LC上的一些滑动窗口的题后，绝大部分的题是2，1的还没见过，所以重点应该是2</p>
</blockquote>
<p><img src="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/article/ref/cd2.webp" alt=""></p>
<p><img src="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/article/ref/cd1.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"># 1.窗口长度固定不变的代码框架伪代码示例</span><br><span class="line">滑动窗口(arr, 目标条件)</span><br><span class="line">&#123;</span><br><span class="line">    初始化 low = 0, high = 0</span><br><span class="line">    初始化 windowsize = k;</span><br><span class="line">    </span><br><span class="line">    while (high &lt; 窗口长度)</span><br><span class="line">    &#123;</span><br><span class="line">    	// 1. 制造的一个 windowsize 窗口</span><br><span class="line">        if (high - low + 1 &lt; windowsize)</span><br><span class="line">        &#123;</span><br><span class="line">        	可以做一些逐步创建窗口的事情</span><br><span class="line">       		</span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 移动窗口并处理</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // 此时窗口大小是等于 windowsize</span><br><span class="line">            // 基于当前窗口计算答案</span><br><span class="line">            // 删除最左边的旧的元素，更新window</span><br><span class="line">            // 添加新的元素</span><br><span class="line">            // 递增low 与 high</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 需要注意的是由于将递增low &amp; high移动到了后面可在退出循环后既high=wndlenght，此时low也要向右移动，我们没有判断这种情况，所以可能需要在后面添加判断left右移的情况</span><br><span class="line">    do something with left decrease</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 2.窗口长度变化的代码框架伪代码示例</span><br><span class="line">variable_window()</span><br><span class="line">&#123;</span><br><span class="line">    int start = 0, end = 0;</span><br><span class="line">    while (end &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        /* Case 1: 增加窗口大小</span><br><span class="line">           如果这个有限制窗口的一个大小滑动则有这个判断条件，但是一般无</span><br><span class="line">        */</span><br><span class="line">        if (end - start + 1 &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Case 2: 达到窗口期望大小k</span><br><span class="line">           如果这个窗口达到了期望的大小k则计算结果，但是一般无</span><br><span class="line">        */</span><br><span class="line">        else if (end - start + 1 == k)</span><br><span class="line">        &#123;</span><br><span class="line">            // Perform the required calculations or operations to obtain the answer</span><br><span class="line">            // Store the answer in a variable (ans)</span><br><span class="line"></span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Case 3: Reduce the window size</span><br><span class="line">           If the window size is greater than the desired value (k), adjust the window by moving the start index</span><br><span class="line">        */</span><br><span class="line">        else if (end - start + 1 &gt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            while (end - start + 1 &gt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                // Remove calculations or operations involving the element at the start index</span><br><span class="line"></span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Check if the window size becomes equal to the desired value (k) after adjustment</span><br><span class="line">            if (end - start + 1 == k)</span><br><span class="line">            &#123;</span><br><span class="line">                // Perform calculations or operations and store the answer if necessary</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Return the final answer (ans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">滑动窗口(arr, 目标条件)</span><br><span class="line">&#123;</span><br><span class="line">    初始化 left = 0, right = 0</span><br><span class="line">    初始化结果集 result</span><br><span class="line"></span><br><span class="line">    while right &lt; arr 的长度</span><br><span class="line">    &#123;</span><br><span class="line">        扩展右边界</span><br><span class="line">        right 向右移动，增加窗口内的元素</span><br><span class="line">        根据 arr[right] 的添加更新窗口状态</span><br><span class="line"></span><br><span class="line">        while 当前窗口满足目标条件?</span><br><span class="line">        &#123;</span><br><span class="line">            更新结果 result（如最小长度、最大长度、最大和等）</span><br><span class="line"></span><br><span class="line">            收缩左边界</span><br><span class="line">            根据 arr[left] 的去除更新窗口状态</span><br><span class="line">            left 向右移动，减小窗口内的元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    返回结果 result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/discuss/interview-question/3722472/mastering-sliding-window-technique-a-comprehensive-guide">推荐阅读的解说文章-需要网络工具</a></p>
<h6 id="76-最小覆盖子串"><a class="header-anchor" href="#76-最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">operationAdd</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; wnd, unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; tgt,<span class="type">char</span> newC,<span class="type">int</span> &amp; vaild)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tgt.<span class="built_in">find</span>(newC) != tgt.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        wnd[newC]++;</span><br><span class="line">        <span class="keyword">if</span> (wnd[newC] == tgt[newC])</span><br><span class="line">            vaild++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operationDel</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; wnd, unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; tgt, <span class="type">char</span> delC, <span class="type">int</span>&amp; vaild)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tgt.<span class="built_in">find</span>(delC) != tgt.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wnd[delC] == tgt[delC])</span><br><span class="line">            vaild--;</span><br><span class="line">        wnd[delC]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">minSubString</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; wndkv, tgtkv;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, subLen = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : t)</span><br><span class="line">        tgtkv[c]++;</span><br><span class="line">    <span class="type">int</span> vaildChar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right&lt;s.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 扩展右边界</span></span><br><span class="line">        <span class="type">char</span> newc = s[right++];</span><br><span class="line">        <span class="built_in">operationAdd</span>(wndkv, tgtkv, newc, vaildChar);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; vaildChar == tgtkv.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// 更新状态 子串</span></span><br><span class="line">            <span class="keyword">if</span> (subLen &gt; right - left) &#123;</span><br><span class="line">                subLen = right - left;</span><br><span class="line">                start = left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 缩小左边界</span></span><br><span class="line">            <span class="type">char</span> delC = s[left++];</span><br><span class="line">            <span class="built_in">operationDel</span>(wndkv, tgtkv, delC, vaildChar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subLen == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, subLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="567-字符串的排列"><a class="header-anchor" href="#567-字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">operationAdd</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; wnd, unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; tgt, <span class="type">char</span> newC, <span class="type">int</span>&amp; vaild)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tgt.<span class="built_in">find</span>(newC) != tgt.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        wnd[newC]++;</span><br><span class="line">        <span class="keyword">if</span> (wnd[newC] == tgt[newC])</span><br><span class="line">            vaild++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operationDel</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; wnd, unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; tgt, <span class="type">char</span> delC, <span class="type">int</span>&amp; vaild)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tgt.<span class="built_in">find</span>(delC) != tgt.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wnd[delC] == tgt[delC])</span><br><span class="line">            vaild--;</span><br><span class="line">        wnd[delC]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string t, string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; wndkv, tgtkv;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : t)</span><br><span class="line">        tgtkv[c]++;</span><br><span class="line">    <span class="type">int</span> vaildC = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt;= t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="built_in">operationAdd</span>(wndkv, tgtkv, s[right], vaildC);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vaildC == tgtkv.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">operationDel</span>(wndkv, tgtkv, s[left], vaildC);</span><br><span class="line">            <span class="keyword">if</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">operationAdd</span>(wndkv, tgtkv, s[right], vaildC);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaildC == tgtkv.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="438-找到字符串中所有字母异位词"><a class="header-anchor" href="#438-找到字符串中所有字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="type">void</span> <span class="title">operationAdd</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; wnd, unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; tgt, <span class="type">char</span> newC, <span class="type">int</span>&amp; vaild)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tgt.<span class="built_in">find</span>(newC) != tgt.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        wnd[newC]++;</span><br><span class="line">        <span class="keyword">if</span> (wnd[newC] == tgt[newC])</span><br><span class="line">            vaild++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operationDel</span><span class="params">(unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; wnd, unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&amp; tgt, <span class="type">char</span> delC, <span class="type">int</span>&amp; vaild)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tgt.<span class="built_in">find</span>(delC) != tgt.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wnd[delC] == tgt[delC])</span><br><span class="line">            vaild--;</span><br><span class="line">        wnd[delC]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; wndkv, tgtkv;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : t)</span><br><span class="line">        tgtkv[c]++;</span><br><span class="line">    <span class="type">int</span> vaildC = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; startIndexes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt;= t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="built_in">operationAdd</span>(wndkv, tgtkv, s[right], vaildC);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vaildC == tgtkv.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                startIndexes.<span class="built_in">push_back</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">operationDel</span>(wndkv, tgtkv, s[left], vaildC);</span><br><span class="line">            <span class="keyword">if</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">operationAdd</span>(wndkv, tgtkv, s[right], vaildC);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vaildC == tgtkv.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                startIndexes.<span class="built_in">push_back</span>(left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> startIndexes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="209-长度最小的子数组"><a class="header-anchor" href="#209-长度最小的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            len = len &gt; right - left ? right - left : len;</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  len == INT_MAX ? <span class="number">0</span> : len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-无重复字符的最长子串"><a class="header-anchor" href="#3-无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 动态滑动窗口？？？   </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">char</span>&gt; rec;</span><br><span class="line">    <span class="type">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> curLength = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> toAdd = s[right];</span><br><span class="line">        <span class="keyword">if</span> (rec.<span class="built_in">find</span>(toAdd) == rec.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            rec.<span class="built_in">insert</span>(toAdd);</span><br><span class="line">            curLength++;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            maxlen = curLength &gt; maxlen ? curLength : maxlen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> toDel = s[left++];</span><br><span class="line">            startIndex = left;</span><br><span class="line">            curLength--;</span><br><span class="line">            rec.<span class="built_in">erase</span>(toDel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="128-最长连续序列"><a class="header-anchor" href="#128-最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tempLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right&lt;nums.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == left)</span><br><span class="line">        &#123;</span><br><span class="line">            tempLength++;</span><br><span class="line">            maxLength = tempLength &gt; maxLength ? tempLength : maxLength;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == nums[right - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/// 若我们的 nums[right] 比前一位大1，则连续</span></span><br><span class="line">                tempLength++;</span><br><span class="line">                maxLength = tempLength &gt; maxLength ? tempLength : maxLength;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/// 相等前后位，则不管</span></span><br><span class="line">                maxLength = tempLength &gt; maxLength ? tempLength : maxLength;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/// 此时right下标位置开始不连续了，则更新left和right</span></span><br><span class="line">                <span class="comment">// 更新left</span></span><br><span class="line">                left = right;</span><br><span class="line">                tempLength = <span class="number">1</span>;</span><br><span class="line">                maxLength = tempLength &gt; maxLength ? tempLength : maxLength;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="239-滑动窗口最大值"><a class="header-anchor" href="#239-滑动窗口最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值*</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 超时</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMax</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">((vec.begin() + startIndex), (vec.begin() + endIndex + <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> v.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; resultMax;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxValue = <span class="number">-10001</span>;</span><br><span class="line">    <span class="type">int</span> currentWndSize = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 1.构建第一个窗口</span></span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/// 2. 滑动</span></span><br><span class="line">            <span class="type">int</span> max = <span class="built_in">findMax</span>(nums, left, right);</span><br><span class="line">            resultMax.<span class="built_in">push_back</span>(max);</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultMax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; resultMax;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> resultMax;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq; <span class="comment">// 优先队列，存储值和对应的索引</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; countMap; <span class="comment">// 哈希表，跟踪窗口中元素的计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 当窗口滑动超过k个元素，减少最左侧元素的计数</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">            countMap[nums[i - k]]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加新元素到优先队列和哈希表</span></span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        countMap[nums[i]]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当窗口大小为k时，从优先队列中找到有效的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; countMap[pq.<span class="built_in">top</span>().first] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>(); <span class="comment">// 移除无效的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">            resultMax.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; resultMax;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> resultMax;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq; <span class="comment">// 存储数组索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 移除超出滑动窗口左边界的元素索引</span></span><br><span class="line">        <span class="keyword">if</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() == i - k) &#123;</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除所有小于当前元素的索引，保持队列从大到小</span></span><br><span class="line">        <span class="keyword">while</span> (!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt;= nums[i]) &#123;</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加当前元素的索引</span></span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// 当窗口大小为k时，将对应的元素（队列的前端）添加到结果</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            resultMax.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="n数和问题"><a class="header-anchor" href="#n数和问题"></a>n数和问题</h5>
<h6 id="167-两数和II-数组有序"><a class="header-anchor" href="#167-两数和II-数组有序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">167.两数和II - 数组有序</a></h6>
<p>特殊情况，本题数组为有序数组，且本题答案需要返回的是+1下标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法 - 有序的时候使用</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sum == target)</span><br><span class="line">            <span class="keyword">return</span> &#123; left+<span class="number">1</span>,right+<span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-两数和-数组无序"><a class="header-anchor" href="#1-两数和-数组无序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&amp;envId=top-100-liked">1.两数和 - 数组无序</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num1 = numbers[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; numbers.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num2 = numbers[j];</span><br><span class="line">            <span class="keyword">if</span> (num1 + num2 == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; i,j &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hashmap法 - hash适用</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(target - numbers[i]);</span><br><span class="line">        <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = (*it).second;</span><br><span class="line">            <span class="keyword">return</span>&#123; i,j &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[numbers[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本题无序数组的也可以用1.的解法，只不过需要将数组排序后应用1.题的解法，需要修改返回的是值了，而非下标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 先对数组排序</span></span><br><span class="line"> <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"> <span class="comment">// 左右指针</span></span><br><span class="line"> <span class="type">int</span> lo = <span class="number">0</span>, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">     <span class="type">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">     <span class="comment">// 根据 sum 和 target 的比较，移动左右指针</span></span><br><span class="line">     <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">         lo++;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">         hi--;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;nums[lo], nums[hi]&#125;;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="">拓展-2数和-数组无序-多对</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> start) &#123;</span><br><span class="line">    <span class="comment">// 先对数组排序，此处排序可以移到外层实现</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> lo = start, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">        <span class="comment">// 记录索引 lo 和 hi 最初对应的值</span></span><br><span class="line">        <span class="type">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target)      lo++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) hi--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123; left, right &#125;);</span><br><span class="line">            <span class="comment">// 跳过所有重复的元素</span></span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="15-三数和-无序数组"><a class="header-anchor" href="#15-三数和-无序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">15.三数和-无序数组</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">int</span> start) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> lo = start, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">            <span class="comment">// 记录索引 lo 和 hi 最初对应的值</span></span><br><span class="line">            <span class="type">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target)      lo++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) hi--;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123; left, right &#125;);</span><br><span class="line">                <span class="comment">// 跳过所有重复的元素</span></span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target,<span class="type">int</span> start) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="comment">// 先对数组排序，此处排序可以移到外层实现</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;tuple = <span class="built_in">twoSumTarget</span>(nums, target - nums[i], i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> tp : tuple)</span><br><span class="line">            &#123;</span><br><span class="line">                tp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(tp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 跳过重复数字</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="18-四数和-无序数组"><a class="header-anchor" href="#18-四数和-无序数组"></a><a href="">18.四数和-无序数组</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> target, <span class="type">int</span> start) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> lo = start, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="type">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">        <span class="comment">// 记录索引 lo 和 hi 最初对应的值</span></span><br><span class="line">        <span class="type">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target)      lo++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) hi--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123; left, right &#125;);</span><br><span class="line">            <span class="comment">// 跳过所有重复的元素</span></span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> target,<span class="type">int</span> start) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;tuple = <span class="built_in">twoSumTarget</span>(nums, target - nums[i], i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tp : tuple)</span><br><span class="line">        &#123;</span><br><span class="line">            tp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(tp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过重复数字</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> target,<span class="type">int</span> start) &#123;</span><br><span class="line">    <span class="comment">// 先对数组排序，此处排序可以移到外层实现</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;triple = <span class="built_in">threeSumTarget</span>(nums, target - nums[i], i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> trp : triple)</span><br><span class="line">        &#123;</span><br><span class="line">            trp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(trp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过重复数字</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="">n数和-总结</a></p>
<blockquote>
<p>观察上述所有问题，我们发现了一个的递归的结构，所以我们归纳总结</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 使用前请先调用sort排序</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> n, <span class="type">long</span> target, <span class="type">int</span> start)</span><br><span class="line">&#123;</span><br><span class="line"> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"> <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">twoSumTarget</span>(nums, target, start);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">         vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;vc = <span class="built_in">nSumTarget</span>(nums,n<span class="number">-1</span>,target - nums[i], i + <span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">auto</span> v : vc)</span><br><span class="line">         &#123;</span><br><span class="line">             v.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">             res.<span class="built_in">push_back</span>(v);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这个是核心!</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">twoSumTarget</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> target, <span class="type">int</span> start) &#123;</span><br><span class="line"> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"> <span class="type">int</span> lo = start, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">     <span class="type">int</span> sum = nums[lo] + nums[hi];</span><br><span class="line">     <span class="comment">// 记录索引 lo 和 hi 最初对应的值</span></span><br><span class="line">     <span class="type">int</span> left = nums[lo], right = nums[hi];</span><br><span class="line">     <span class="keyword">if</span> (sum &lt; target)      lo++;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) hi--;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         res.<span class="built_in">push_back</span>(&#123; left, right &#125;);</span><br><span class="line">         <span class="comment">// 跳过所有重复的元素</span></span><br><span class="line">         <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class="line">         <span class="keyword">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="数组前缀和"><a class="header-anchor" href="#数组前缀和"></a>数组前缀和</h5>
<h6 id="303-区域和检索-数组不可变"><a class="header-anchor" href="#303-区域和检索-数组不可变"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sums.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sums[i+<span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[right+<span class="number">1</span>] - sums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="304-二维区域和检索-矩阵不可变"><a class="header-anchor" href="#304-二维区域和检索-矩阵不可变"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">front</span>().<span class="built_in">size</span>();</span><br><span class="line">        sums.<span class="built_in">resize</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sums[i + <span class="number">1</span>][j + <span class="number">1</span>] = sums[i + <span class="number">1</span>][j] + sums[i][j + <span class="number">1</span>] - sums[i][j] + matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - sums[row2 + <span class="number">1</span>][col1] - sums[row1][col2 + <span class="number">1</span>] + sums[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="前缀和-hash表结合问题"><a class="header-anchor" href="#前缀和-hash表结合问题"></a><a href="">前缀和&amp;hash表结合问题</a></h5>
<blockquote>
<p>本类型为前缀和和hash结合问题，思路较为常规：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prefix_Arr = CreatePrefixArr(nums_arr);</span><br><span class="line">hash_map prefix_index_kv;</span><br><span class="line">hash(prefix_Arr,prefix_index_kv);</span><br><span class="line">for(i=1;i&lt;prefix len;i++):</span><br><span class="line">	need = target - prefix_Arr[i]</span><br><span class="line">	prefix_index_kv.contain(need)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="523-连续的子数组和-涉及hash"><a class="header-anchor" href="#523-连续的子数组和-涉及hash"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/continuous-subarray-sum/">523. 连续的子数组和 - 涉及hash</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.暴力</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkSubarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; prefix = <span class="built_in">prefixSum</span>(nums);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prefix.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; prefix.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = prefix[j] - prefix[i];</span><br><span class="line">            <span class="keyword">if</span> (sum % k == <span class="number">0</span> &amp;&amp; (j - i)&gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.非暴力</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkSubarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; v2i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prefix.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val = prefix[i] % k;</span><br><span class="line">        <span class="keyword">if</span> (v2i.<span class="built_in">find</span>(val) == v2i.<span class="built_in">end</span>())</span><br><span class="line">            v2i[val] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prefix.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> need = prefix[i] % k;</span><br><span class="line">        <span class="keyword">if</span> (v2i.<span class="built_in">find</span>(need) != v2i.<span class="built_in">end</span>() &amp;&amp; (i - v2i[need] &gt; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="525-连续数组-涉及hash"><a class="header-anchor" href="#525-连续数组-涉及hash"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/contiguous-array/">525. 连续数组 - 涉及hash</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        prefix[i + <span class="number">1</span>] = (nums[i] == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>) + prefix[i];</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; v2im;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prefix.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v2im.<span class="built_in">find</span>(prefix[i]) == v2im.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            v2im[prefix[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            len = std::<span class="built_in">max</span>(len, i - v2im[prefix[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="560-和为-K-的子数组"><a class="header-anchor" href="#560-和为-K-的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; preSum_count_kv;</span><br><span class="line">    preSum_count_kv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target = prefix[i+<span class="number">1</span>] - k;</span><br><span class="line">        <span class="keyword">if</span> (preSum_count_kv.<span class="built_in">find</span>(target) != preSum_count_kv.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res += preSum_count_kv[target];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (preSum_count_kv.<span class="built_in">find</span>(prefix[i+<span class="number">1</span>]) != preSum_count_kv.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            preSum_count_kv[prefix[i+<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            preSum_count_kv[prefix[i+<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="差分数组"><a class="header-anchor" href="#差分数组"></a><a href="">差分数组</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dif</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dif</span>(vector&lt;<span class="type">int</span>&gt; target) &#123;</span><br><span class="line">        dec.<span class="built_in">push_back</span>(target.<span class="built_in">front</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; target.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dec.<span class="built_in">push_back</span>(target[i] - target[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        dec[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; dec.<span class="built_in">size</span>())</span><br><span class="line">            dec[j + <span class="number">1</span>] -= val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(dec.<span class="built_in">front</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; dec.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(vec.<span class="built_in">back</span>() + dec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="其它"><a class="header-anchor" href="#其它"></a>其它</h5>
<h6 id="56-合并区间"><a class="header-anchor" href="#56-合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; lf, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; rg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> lf[<span class="number">0</span>] &lt; rg[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">	std::<span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), Compare);</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">	result.<span class="built_in">push_back</span>(intervals.<span class="built_in">front</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; toAdd : intervals)</span><br><span class="line">	&#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; last = result.<span class="built_in">back</span>();</span><br><span class="line">		<span class="keyword">if</span> (last[<span class="number">1</span>] &lt; toAdd[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/// 区间不∩</span></span><br><span class="line">			result.<span class="built_in">push_back</span>(toAdd);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (last[<span class="number">1</span>] &gt;= toAdd[<span class="number">1</span>])</span><br><span class="line">			<span class="comment">/// 区间子集</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/// 区间相交</span></span><br><span class="line">		(*(result.<span class="built_in">end</span>() - <span class="number">1</span>))[<span class="number">1</span>] = toAdd[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="189-轮转数组"><a class="header-anchor" href="#189-轮转数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myreverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> left = startIndex;</span><br><span class="line">	<span class="type">int</span> right = endIndex;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> temp = nums[left];</span><br><span class="line">		nums[left] = nums[right];</span><br><span class="line">		nums[right] = temp;</span><br><span class="line">		left++;</span><br><span class="line">		right--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span> || nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	k = k % nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">myreverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">myreverse</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">myreverse</span>(nums, k, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="238-除自身以外数组的乘积"><a class="header-anchor" href="#238-除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> pre = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> suf = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		result[i] = pre;</span><br><span class="line">		pre *= nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">		result[j] *= suf;</span><br><span class="line">		suf *= nums[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="41-缺失的第一个正数"><a class="header-anchor" href="#41-缺失的第一个正数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums.<span class="built_in">size</span>() &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">		<span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> nums.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们知道如果nums不空缺任何数字的话，那么nums排序号后，数字就应该和索引对应</span></span><br><span class="line"><span class="comment">// 再此遍历nums，如果nums的值和索引不对应的话，那么那个索引就是我们需要的结果</span></span><br></pre></td></tr></table></figure>
<h4 id="链表"><a class="header-anchor" href="#链表"></a>链表</h4>
<p>链表相关问题本节按照类型进行分类完成整理，基础问题包括链表的一系列需要练习的较为基础的操作，可作为工具子函数使用；</p>
<blockquote>
<p>注意事项：</p>
<ol>
<li>前缀后缀–问题</li>
</ol>
<p>链表常用循环查找第index节点问题，这里需要注意的一点的是前缀–和后缀–的差别：</p>
<ul>
<li><code>while(index--)</code>：先检查值，再执行减法。循环次数等于初始<code>index</code>值。</li>
<li><code>while(--index)</code>：先执行减法，再检查值。循环次数等于初始<code>index</code>值减一</li>
</ul>
<p>如果需要从初始值开始处理，使用<code>while(index--)</code>；如果需要从初始值减一开始处理，使用<code>while(--index)</code></p>
<ol start="2">
<li>
<p>临时头节点问题</p>
<p>建议通通使用</p>
</li>
<li></li>
</ol>
</blockquote>
<h5 id="移除元素"><a class="header-anchor" href="#移除元素"></a>移除元素</h5>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ListNode</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">	<span class="keyword">public</span> ListNode? next;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">int</span> val = <span class="number">0</span>, ListNode? next = <span class="literal">null</span></span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">		<span class="keyword">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode? RemoveListNode(ListNode? head,<span class="built_in">int</span> val)</span><br><span class="line">&#123;</span><br><span class="line">	ListNode dummy = <span class="keyword">new</span>(<span class="number">-1</span>, head);</span><br><span class="line">	ListNode? current = dummy;</span><br><span class="line">	<span class="keyword">while</span>(current.next != <span class="literal">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(val == current.next.val)</span><br><span class="line">		&#123;</span><br><span class="line">			current.next = current.next.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			current = current.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">RemoveElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* tempHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    tempHead-&gt;next = head;</span><br><span class="line">    ListNode* current = tempHead;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;next-&gt;val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* temp = current-&gt;next;</span><br><span class="line">		 current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">	 &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">		 current = current-&gt;next;</span><br><span class="line">	 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="设计链表"><a class="header-anchor" href="#设计链表"></a>设计链表</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode *next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode* next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode* fakeHead;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        fakeHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; (size - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        ListNode* cur = fakeHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        newNode-&gt;next = fakeHead-&gt;next;</span><br><span class="line">        fakeHead-&gt;next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode*  newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val), *cur = fakeHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">		size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">addAtHead</span>(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val), *cur = fakeHead;</span><br><span class="line">            <span class="keyword">while</span> (index--)</span><br><span class="line">            &#123;</span><br><span class="line">				cur = cur-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			newNode-&gt;next = cur-&gt;next;</span><br><span class="line">			cur-&gt;next = newNode;</span><br><span class="line">			size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = fakeHead;</span><br><span class="line">        <span class="keyword">while</span> (index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode* cur = fakeHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="翻转链表"><a class="header-anchor" href="#翻转链表"></a>翻转链表</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 迭代版</span></span><br><span class="line"><span class="function">ListNode* <span class="title">Reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* newHead = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 记录下一个节点</span></span><br><span class="line">			ListNode* after = cur-&gt;next;</span><br><span class="line">			<span class="comment">// 拆</span></span><br><span class="line">			cur-&gt;next = newHead;</span><br><span class="line">			<span class="comment">// 更新newHead</span></span><br><span class="line">			newHead = cur;</span><br><span class="line">			<span class="comment">// 更新cur</span></span><br><span class="line">			cur = after;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newHead;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 递归法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="两两交换链表节点"><a class="header-anchor" href="#两两交换链表节点"></a>两两交换链表节点</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 迭代版</span></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* tempHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> tempHead-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...tH(prev) -&gt; a(head) -&gt; b -&gt; c(nextPair) -&gt; ...</span></span><br><span class="line">	</span><br><span class="line">	ListNode* cur = tempHead;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ListNode* a = cur-&gt;next;</span><br><span class="line">		ListNode* b = a-&gt;next;</span><br><span class="line">		ListNode* c = b-&gt;next;</span><br><span class="line">		<span class="comment">// ...tH(prev) -&gt; a(head) -&gt; b -&gt; c(nextPair) -&gt; ...</span></span><br><span class="line">		cur-&gt;next = b;</span><br><span class="line">		b-&gt;next = a;</span><br><span class="line">		a-&gt;next = c;</span><br><span class="line">		<span class="comment">// ...tH(prev) -&gt; b -&gt; a(head) -&gt; c(nextPair) -&gt; ...</span></span><br><span class="line">		cur = a;</span><br><span class="line">	&#125;		</span><br><span class="line">	ListNode* result = tempHead-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> tempHead;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 递归版本</span></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...-&gt;nullptr</span></span><br><span class="line">	<span class="comment">// head-&gt;nullptr</span></span><br><span class="line">    <span class="comment">// 1.终止条件检查</span></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 2.1对当前问题进行一些处理或简化，准备下一步递归</span></span><br><span class="line">	ListNode* next = head-&gt;next;</span><br><span class="line">    <span class="comment">// 2.2递归调用自身，解决更小或更简化的问题</span></span><br><span class="line">	head-&gt;next = <span class="built_in">swapPairs</span>(next-&gt;next);</span><br><span class="line">    <span class="comment">// 2.3使用递归得到的结果来构建当前问题的解</span></span><br><span class="line">	next-&gt;next = head;</span><br><span class="line">    <span class="comment">// 3.返回当前问题的解</span></span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除链表倒数N个节点"><a class="header-anchor" href="#删除链表倒数N个节点"></a>删除链表倒数N个节点</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	ListNode* tempHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">	ListNode* slow = tempHead,*fast = tempHead;</span><br><span class="line">	<span class="comment">// Move fast pointer to the nth node from the beginning, move n+1 steps</span></span><br><span class="line">	n=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> ((n--) &amp;&amp; fast != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Move fast to the end, maintaining the gap</span></span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Remove the nth node from the end</span></span><br><span class="line">	ListNode* temp = slow-&gt;next;</span><br><span class="line">	slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> temp;</span><br><span class="line">	<span class="keyword">return</span> tempHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="链表相交"><a class="header-anchor" href="#链表相交"></a>链表相交</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetLength</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		length++;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Move</span><span class="params">(ListNode* head, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (step--)</span><br><span class="line">	&#123;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> lengthA = <span class="built_in">GetLength</span>(headA);</span><br><span class="line">	<span class="type">int</span> lengthB = <span class="built_in">GetLength</span>(headB);</span><br><span class="line">	ListNode* newA_start = headA;</span><br><span class="line">	ListNode* newB_start = headB;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lengthA &gt; lengthB)</span><br><span class="line">	&#123;</span><br><span class="line">		newA_start = <span class="built_in">Move</span>(headA, lengthA - lengthB);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		newB_start = <span class="built_in">Move</span>(headB, lengthB - lengthA);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (newA_start != <span class="literal">nullptr</span> &amp;&amp; newB_start != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (newA_start == newB_start)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> newA_start;</span><br><span class="line">		&#125;</span><br><span class="line">		newA_start = newA_start-&gt;next;</span><br><span class="line">		newB_start = newB_start-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="环链表"><a class="header-anchor" href="#环链表"></a>环链表</h5>
<p>两个问题：是否环；环入口；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* tmpHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>,head);</span><br><span class="line">	ListNode* slow = tmpHead;</span><br><span class="line">	ListNode* fast = tmpHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">			ListNode* slow2 = tmpHead;</span><br><span class="line">			<span class="keyword">while</span> (slow2 != slow) &#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				slow2 = slow2-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> tmpHead;</span><br><span class="line">			<span class="keyword">return</span> slow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> tmpHead;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="快慢指针"><a class="header-anchor" href="#快慢指针"></a>快慢指针</h5>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">83.删除排序链表重复元素</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DelNodes</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* nxt = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        head = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast-&gt;val != slow-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            slow-&gt;val = fast-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slow != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DelNodes</span>(slow-&gt;next);</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归问题解释"><a class="header-anchor" href="#递归问题解释"></a>递归问题解释</h4>
<blockquote>
<p>递归法解释：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>问题定义</mtext><mo>:</mo><msub><mi>Q</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">问题定义: Q_{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">问题定义</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 问题Q能够在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>步递归完成求解，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>∈</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q_{i}(i \in N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>指的是第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>步时问题的解，假设递归求解公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">R_{m}(...),m \in M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">...</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，展开有：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi><mo>=</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>R</mi><mn>3</mn></msub><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><msub><mi>R</mi><mi>N</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><mi>e</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Result = R_{1}(R_{2}(R_{3}(...(R_{N}(min_{quesetion})...)))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">es</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">...</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">mi</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">ese</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">...</span><span class="mclose">)))</span></span></span></span></span></p>
<p>对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><msub><mi>Q</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\forall Q_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>个问题的解为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_{j}(...)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">...</span><span class="mclose">)</span></span></span></span>, 由于是递归，即每一步处理问题方式是相同的(终止条件时除外)</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">recursiveFunction<span class="punctuation">(</span>problem<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment"># 1.终止条件检查</span></span><br><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span>isBaseCase<span class="punctuation">(</span>problem<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line"> <span class="built_in">return</span> baseCaseSolution<span class="punctuation">(</span>problem<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1对当前问题进行一些处理或简化，准备下一步递归</span></span><br><span class="line">smallerProblem <span class="operator">=</span> prepareForRecursion<span class="punctuation">(</span>problem<span class="punctuation">)</span>    </span><br><span class="line"><span class="comment"># 2.2递归调用自身，解决更小或更简化的问题</span></span><br><span class="line">result_of_Recursion <span class="operator">=</span> recursiveFunction<span class="punctuation">(</span>smallerProblem<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.3使用递归得到的结果来构建当前问题的解</span></span><br><span class="line">resultForCurrentProblem <span class="operator">=</span> SolutionFromRecursion<span class="punctuation">(</span>result_of_Recursion<span class="punctuation">,</span> problem<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.返回当前问题的解</span></span><br><span class="line"><span class="built_in">return</span> resultForCurrentProblem</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>所以玩明白递归我们要做的是：</p>
<ol>
<li>终止条件是什么？</li>
<li>当前一层递归要干什么？</li>
<li>返回给上一层是什么？</li>
</ol>
</blockquote>
<h4 id="二叉树"><a class="header-anchor" href="#二叉树"></a>二叉树</h4>
<h5 id="解释"><a class="header-anchor" href="#解释"></a>解释</h5>
<blockquote>
<p><em>“动态规划关注整棵「子树」，回溯算法关注节点间的「树枝」，DFS 算法关注单个「节点」”</em></p>
<p><strong>动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同</strong>：</p>
<ul>
<li><strong>动态规划算法属于分解问题的思路，它的关注点在整棵「子树」</strong>。</li>
<li><strong>回溯算法属于遍历的思路，它的关注点在节点间的「树枝」</strong>。</li>
<li><strong>DFS 算法属于遍历的思路，它的关注点在单个「节点」</strong></li>
</ul>
<p><em>二叉树解题的思维模式分两类：</em></p>
<p><em><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</em></p>
<p><em><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</em></p>
</blockquote>
<p>以上内容来自于labuladong</p>
<blockquote>
<p>个人总结</p>
<p>二叉树相关解题思维：<strong>1.遍历类型 2.递归子问题类型</strong></p>
<p>个人认为他们二者最大区别就是递归类型可能涉及到子问题解答返回子问题的解，而遍历类型一般不返回东西。其中视作为前序遍历和后序遍历的问题，我们可以把前序遍历看作遍历类型，后序遍历看成递归类型（将我们的函数设置为返回来自于上层的某些值）</p>
<p>实际上，1和2区别就是后者为后序遍历可以获得来自于子问题的解进而构造出当前问题的解，前者为前序遍历，只能处理当前问题。</p>
</blockquote>
<h5 id="普通二叉树"><a class="header-anchor" href="#普通二叉树"></a>普通二叉树</h5>
<h6 id="226-翻转二叉树"><a class="header-anchor" href="#226-翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分解问题的思维</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分解子问题: </span></span><br><span class="line">    <span class="comment">// 子问题是根节点下左子树和右子树交换</span></span><br><span class="line">	TreeNode* left = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">	TreeNode* right = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">	<span class="comment">// 使用递归得到的结果来构建当前问题的解:合并子问题</span></span><br><span class="line">	root-&gt;left = right;</span><br><span class="line">	root-&gt;right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历思维</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历二叉树，交换每个节点的子节点</span></span><br><span class="line">    <span class="built_in">traverse</span>(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一个节点需要做的事就是交换它的左右子节点</span></span><br><span class="line">    TreeNode* tmp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历框架，去遍历左右子树的节点</span></span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="116-填充每个节点的下一个右侧节点指针"><a class="header-anchor" href="#116-填充每个节点的下一个右侧节点指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">				q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">				q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">			<span class="keyword">if</span> (i == sz - <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归遍历</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">connectTriple</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connectTriple</span><span class="params">(Node* leftNode, Node* rightNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leftNode == <span class="literal">nullptr</span> || rightNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    leftNode-&gt;next = rightNode;</span><br><span class="line">	<span class="built_in">connectTriple</span>(leftNode-&gt;left, leftNode-&gt;right);</span><br><span class="line">	<span class="built_in">connectTriple</span>(rightNode-&gt;left, rightNode-&gt;right);</span><br><span class="line">	<span class="built_in">connectTriple</span>(leftNode-&gt;right, rightNode-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="114-二叉树展开为链表"><a class="header-anchor" href="#114-二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PLR</span><span class="params">(TreeNode* root, TreeNode*&amp; curLast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode* left = root-&gt;left;  <span class="comment">// 保存左子树</span></span><br><span class="line">    TreeNode* right = root-&gt;right;  <span class="comment">// 保存右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (curLast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        curLast-&gt;right = root;  <span class="comment">// 将当前节点接到上一个节点的右子节点</span></span><br><span class="line">        curLast-&gt;left = <span class="literal">nullptr</span>;  <span class="comment">// 左子节点设为 nullptr</span></span><br><span class="line">    &#125;</span><br><span class="line">    curLast = root;  <span class="comment">// 更新 curLast 为当前节点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">PLR</span>(left, curLast);  <span class="comment">// 递归处理左子树</span></span><br><span class="line">    <span class="built_in">PLR</span>(right, curLast);  <span class="comment">// 递归处理右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    TreeNode* curLast = <span class="literal">nullptr</span>;  <span class="comment">// 初始化 curLast</span></span><br><span class="line">    <span class="built_in">PLR</span>(root, curLast);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子问题分解思维</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用定义，把左右子树拉平</span></span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">flatten</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">    TreeNode* left = root-&gt;left;</span><br><span class="line">    TreeNode* right = root-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将左子树作为右子树</span></span><br><span class="line">    root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;right = left;</span><br><span class="line"></span><br><span class="line">    TreeNode* p = root;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;right = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="543-二叉树的直径"><a class="header-anchor" href="#543-二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxD = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">traverse</span>(root, maxD);</span><br><span class="line">    <span class="keyword">return</span> maxD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">traverse</span><span class="params">(TreeNode* root,<span class="type">int</span>&amp; maxD)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> leftMax = <span class="built_in">traverse</span>(root-&gt;left, maxD);</span><br><span class="line">    <span class="type">int</span> rightMax = <span class="built_in">traverse</span>(root-&gt;right, maxD);</span><br><span class="line"></span><br><span class="line">	maxD = <span class="built_in">max</span>(maxD, leftMax + rightMax);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="654-最大二叉树"><a class="header-anchor" href="#654-最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxNum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> maxNum = nums[startIndex];</span><br><span class="line">	<span class="type">int</span> maxIndex = startIndex;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = startIndex + <span class="number">1</span>; i &lt;= endIndex; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] &gt; maxNum)</span><br><span class="line">		&#123;</span><br><span class="line">			maxNum = nums[i];</span><br><span class="line">			maxIndex = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (startIndex &gt; endIndex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> maxIndex = <span class="built_in">findMaxNum</span>(nums, startIndex, endIndex);</span><br><span class="line">	TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxIndex]);</span><br><span class="line">	root-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(nums, startIndex, maxIndex - <span class="number">1</span>);</span><br><span class="line">	root-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(nums, maxIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">constructMaximumBinaryTree</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="105-从前序与中序遍历序列构造二叉树"><a class="header-anchor" href="#105-从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">build</span>(preorder, inorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preStart, <span class="type">int</span> preEnd, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 前序遍历的第一个节点就是根节点</span></span><br><span class="line">	<span class="type">int</span> rootVal = preorder[preStart];</span><br><span class="line">	<span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = inStart; i &lt;= inEnd; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (inorder[i] == rootVal)</span><br><span class="line">		&#123;</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 先把根节点建立出来</span></span><br><span class="line">	TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">	<span class="type">int</span> leftSize = index - inStart;</span><br><span class="line">	<span class="comment">// 左子树是在中序遍历中根节点的左边，右子树是在中序遍历中根节点的右边</span></span><br><span class="line">	root-&gt;left = <span class="built_in">build</span>(preorder, inorder, preStart + <span class="number">1</span>, preStart + leftSize, inStart, index - <span class="number">1</span>);</span><br><span class="line">	root-&gt;right = <span class="built_in">build</span>(preorder, inorder, preStart + leftSize + <span class="number">1</span>, preEnd, index + <span class="number">1</span>, inEnd);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="106-从中序与后序遍历序列构造二叉树"><a class="header-anchor" href="#106-从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">build</span>(inorder, postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd, <span class="type">int</span> inStart, <span class="type">int</span> inEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (postStart &gt; postEnd || inStart &gt; inEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 后序遍历的最后一个节点是根节点</span></span><br><span class="line">    <span class="type">int</span> rootVal = postorder[postEnd];</span><br><span class="line">	<span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = inStart; i &lt;= inEnd; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (inorder[i] == rootVal)</span><br><span class="line">		&#123;</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 创建根节点</span></span><br><span class="line">	TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">	<span class="comment">// 左子树的节点个数</span></span><br><span class="line">	<span class="type">int</span> leftchildSz = index - inStart;</span><br><span class="line">	<span class="comment">// 递归构建左子树</span></span><br><span class="line">	<span class="comment">// postStart: 后序遍历的起始位置</span></span><br><span class="line">	<span class="comment">// postStart + leftchildSz - 1: 后序遍历的结束位置</span></span><br><span class="line">	root-&gt;left = <span class="built_in">build</span>(inorder, postorder, postStart, postStart + leftchildSz - <span class="number">1</span>, inStart, index - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 递归构建右子树</span></span><br><span class="line">	<span class="comment">// postStart + leftchildSz: 后序遍历的起始位置</span></span><br><span class="line">	<span class="comment">// postEnd - 1: 后序遍历的结束位置</span></span><br><span class="line">	root-&gt;right = <span class="built_in">build</span>(inorder, postorder, postStart + leftchildSz, postEnd - <span class="number">1</span>, index + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="889-根据前序和后序遍历构造二叉树"><a class="header-anchor" href="#889-根据前序和后序遍历构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">build</span>(preorder, postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd, <span class="type">int</span> preStart, <span class="type">int</span> preEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (preStart &gt; preEnd || postStart &gt; postEnd)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preStart]);</span><br><span class="line">	<span class="keyword">if</span> (preStart == preEnd)</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> leftRoot = preorder[preStart + <span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> leftRootIndex = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = postStart; i &lt;= postEnd; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (postorder[i] == leftRoot)</span><br><span class="line">		&#123;</span><br><span class="line">			leftRootIndex = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// leftSize = leftRootIndex - postStart + 1</span></span><br><span class="line">	<span class="comment">// 为什么是leftRootIndex - postStart + 1，因为postStart到leftRootIndex是左子树的节点，leftRootIndex是左子树的根节点</span></span><br><span class="line">	<span class="type">int</span> leftSize = leftRootIndex - postStart + <span class="number">1</span>;</span><br><span class="line">	root-&gt;left = <span class="built_in">build</span>(preorder, postorder, postStart, leftRootIndex, preStart + <span class="number">1</span>, preStart + leftSize);</span><br><span class="line">	root-&gt;right = <span class="built_in">build</span>(preorder, postorder, leftRootIndex + <span class="number">1</span>, postEnd - <span class="number">1</span>, preStart + leftSize + <span class="number">1</span>, preEnd);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么3者计算leftsize不一样？</p>
<ol>
<li><strong>前序与后序遍历构建树</strong></li>
</ol>
<p>在这个函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int leftSize = leftRootIndex - postStart + 1;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>+1</code> 是必要的，因为包括了在 <code>postorder</code> 中从 <code>postStart</code> 到 <code>leftRootIndex</code> 的所有元素。这段表示整个左子树，因此需要包括起始点和终止点。</p>
<p>对于构建右子树，你不需要在 <code>preStart + leftSize + 1</code> 时再加一，因为 <code>leftSize</code> 已经正确地计算了左子树的节点数，而 <code>preStart + leftSize</code> 已经指向左子树的最后一个元素，所以 <code>preStart + leftSize + 1</code> 直接就是右子树的起始位置。</p>
<ol start="2">
<li><strong>中序与后序遍历构建树</strong></li>
</ol>
<p>在这个代码中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int leftchildSz = index - inStart;</span><br></pre></td></tr></table></figure>
<p><code>leftchildSz</code> 表示中序遍历中从 <code>inStart</code> 到找到的根节点的索引（不包含根节点自己）的元素数量。因为中序遍历的根节点把树分成严格的左右两部分，所以这里不需要额外的 <code>+1</code>，其计算已经足够描述左子树的边界。</p>
<ol start="3">
<li><strong>前序与中序遍历构建树</strong></li>
</ol>
<p>这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int leftSize = index - inStart;</span><br></pre></td></tr></table></figure>
<p>与中序与后序遍历构建树相同，<code>leftSize</code> 正确地描述了左子树包含的节点数量，无需额外调整。</p>
</blockquote>
<h6 id="652-寻找重复的子树"><a class="header-anchor" href="#652-寻找重复的子树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">serialize</span><span class="params">(unordered_map&lt;string, <span class="type">int</span>&gt;&amp; map, vector&lt;TreeNode*&gt;&amp; res, TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    string lr = <span class="built_in">serialize</span>(map, res, root-&gt;left);</span><br><span class="line">	string rr = <span class="built_in">serialize</span>(map, res, root-&gt;right);</span><br><span class="line">    string seri = lr + <span class="string">&quot;,&quot;</span> + rr + <span class="string">&quot;,&quot;</span> + std::<span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (map[seri] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    map[seri]++;</span><br><span class="line">    <span class="keyword">return</span> seri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	unordered_map&lt;string, <span class="type">int</span>&gt; map;</span><br><span class="line">	vector&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="built_in">serialize</span>(map, res, root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="101-对称二叉树"><a class="header-anchor" href="#101-对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isSymmetric</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left-&gt;val == right-&gt;val &amp;&amp; <span class="built_in">isSymmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">isSymmetric</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="102-二叉树的层序遍历"><a class="header-anchor" href="#102-二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">createTree</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">createTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&gt;right)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">	TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">	root-&gt;left = <span class="built_in">createTree</span>(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">	root-&gt;right = <span class="built_in">createTree</span>(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="98-验证二叉搜索树"><a class="header-anchor" href="#98-验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	<span class="built_in">tranverse</span>(root, res);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (res[i] &gt;= res[i + <span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tranverse</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">tranverse</span>(root-&gt;left, res);</span><br><span class="line">	res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">	<span class="built_in">tranverse</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode* min, TreeNode* max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 若 root-&gt;val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">    <span class="keyword">if</span> (min != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= min-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">    <span class="keyword">if</span> (max != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &gt;= max-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 限定左子树的最大值是 root-&gt;val，右子树的最小值是 root-&gt;val</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left, min, root) </span><br><span class="line">        &amp;&amp; <span class="built_in">isValidBST</span>(root-&gt;right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="230-二叉搜索树中第K小的元素"><a class="header-anchor" href="#230-二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	<span class="built_in">inorder</span>(root, res);</span><br><span class="line">	<span class="keyword">return</span> res[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inorder</span>(root-&gt;left, res);</span><br><span class="line">	res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">	<span class="built_in">inorder</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="199-二叉树的右视图"><a class="header-anchor" href="#199-二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; mirror)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;TreeNode*&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (node!=<span class="literal">nullptr</span> &amp;&amp; i==size -  <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				mirror.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">				q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">			<span class="keyword">if</span> (node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">				q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res_mirror;</span><br><span class="line">	<span class="built_in">BFS</span>(root, res_mirror);</span><br><span class="line">	<span class="keyword">return</span> res_mirror;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="437-路径总和-III"><a class="header-anchor" href="#437-路径总和-III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">long</span>, <span class="type">long</span>&gt; preSumCount;</span><br><span class="line">    <span class="type">long</span> sum, targetSum;</span><br><span class="line">    <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">long</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;targetSum = target;</span><br><span class="line">        <span class="keyword">this</span>-&gt;preSumCount[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">tranverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tranverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        res += preSumCount[sum - targetSum];</span><br><span class="line">        preSumCount[sum]++;</span><br><span class="line">        <span class="built_in">tranverse</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">tranverse</span>(root-&gt;right);</span><br><span class="line">        preSumCount[sum]--;</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="236-二叉树的最近公共祖先"><a class="header-anchor" href="#236-二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q) &#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">	TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">	<span class="keyword">if</span> (left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="297-二叉树的序列化与反序列化"><a class="header-anchor" href="#297-二叉树的序列化与反序列化"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 困难题</span></span><br></pre></td></tr></table></figure>
<h6 id="124-二叉树中的最大路径和"><a class="header-anchor" href="#124-二叉树中的最大路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> max_v = INT_MIN;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> left_max_v = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">	<span class="type">int</span> right_max_v = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">	max_v = std::<span class="built_in">max</span>(max_v, left_max_v + right_max_v + root-&gt;val);</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(left_max_v, right_max_v) + root-&gt;val,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">dfs</span>(root);</span><br><span class="line">	<span class="keyword">return</span> max_v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="归并排序"><a class="header-anchor" href="#归并排序"></a>归并排序</h6>
<blockquote>
<p><code>merge</code> 函数的任务是将两个已经排序的连续子数组（<code>nums[left..mid]</code> 和 <code>nums[mid+1..right]</code>）合并成一个有序数组。这是通过比较两个子数组的元素并按顺序选择较小的元素来放入临时数组，然后再将这个临时数组复制回原数组的相应位置来实现的。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_merge</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* temp = <span class="keyword">new</span> <span class="type">int</span>[right - left + <span class="number">1</span>]; <span class="comment">// 创建临时数组存储合并后的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理剩余的元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将排序后的数组复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = left, k = <span class="number">0</span>; i &lt;= right; i++, k++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] temp; <span class="comment">// 释放临时数组内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">sort</span>(nums, left, mid);</span><br><span class="line">	<span class="built_in">sort</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="built_in">my_merge</span>(nums, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="快速排序"><a class="header-anchor" href="#快速排序"></a>快速排序</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> pivot = nums[right];</span><br><span class="line">	<span class="type">int</span> i = left;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[j] &lt; pivot)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(nums[i], nums[right]);</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="type">int</span> p = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    <span class="built_in">sort</span>(nums, left, p - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(nums, p + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="BST"><a class="header-anchor" href="#BST"></a>BST</h5>
<h6 id="BST搜索"><a class="header-anchor" href="#BST搜索"></a>BST搜索</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == target) <span class="keyword">return</span> root;</span><br><span class="line">	TreeNode* left = <span class="built_in">searchBST</span>(root-&gt;left, target);</span><br><span class="line">	TreeNode* right = <span class="built_in">searchBST</span>(root-&gt;right, target);</span><br><span class="line">	<span class="keyword">if</span> (left != <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">	<span class="keyword">if</span> (right != <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="BST的插入"><a class="header-anchor" href="#BST的插入"></a>BST的插入</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val)</span><br><span class="line">    &#123;</span><br><span class="line">		root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">		root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="BST的删除"><a class="header-anchor" href="#BST的删除"></a>BST的删除</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果树为空或者没有找到要删除的节点，返回null</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;val) &#123;</span><br><span class="line">        <span class="comment">// 如果要删除的键小于当前节点的值，则在左子树中继续查找</span></span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;val) &#123;</span><br><span class="line">        <span class="comment">// 如果要删除的键大于当前节点的值，则在右子树中继续查找</span></span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点就是要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况2：当前节点没有左子树</span></span><br><span class="line">            TreeNode* temp = root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> root;  <span class="comment">// 释放当前节点的内存</span></span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况2：当前节点没有右子树</span></span><br><span class="line">            TreeNode* temp = root-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> root;  <span class="comment">// 释放当前节点的内存</span></span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况3：当前节点有两个子节点</span></span><br><span class="line">        <span class="comment">// 找到右子树的最小节点，即当前节点的中序后继</span></span><br><span class="line">        TreeNode* temp = <span class="built_in">minValueNode</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用中序后继的值覆盖当前节点的值</span></span><br><span class="line">        root-&gt;val = temp-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除中序后继节点</span></span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, temp-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">minValueNode</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    TreeNode* current = node;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        current = current-&gt;left; <span class="comment">// 一直向左走到底</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="96-不同的二叉搜索树"><a class="header-anchor" href="#96-不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mmo;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countTree</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	string key = <span class="built_in">to_string</span>(left) + <span class="string">&quot; &quot;</span> + <span class="built_in">to_string</span>(right);</span><br><span class="line">	<span class="keyword">if</span> (mmo.<span class="built_in">find</span>(key) != mmo.<span class="built_in">end</span>()) <span class="keyword">return</span> mmo[key];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">		<span class="type">int</span> leftCount = <span class="built_in">countTree</span>(left, i - <span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> rightCount = <span class="built_in">countTree</span>(i + <span class="number">1</span>, right);</span><br><span class="line">		res += leftCount * rightCount;</span><br><span class="line">	&#125;</span><br><span class="line">	mmo[key] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">countTree</span>(<span class="number">1</span>, n); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="95-不同的二叉搜索树-II"><a class="header-anchor" href="#95-不同的二叉搜索树-II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        allTrees.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择一个数字作为根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// 构建所有可能的左子树和右子树</span></span><br><span class="line">        std::vector&lt;TreeNode*&gt; leftTrees = <span class="built_in">generateTrees</span>(start, i - <span class="number">1</span>);</span><br><span class="line">        std::vector&lt;TreeNode*&gt; rightTrees = <span class="built_in">generateTrees</span>(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与根节点组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : leftTrees) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : rightTrees) &#123;</span><br><span class="line">                TreeNode* currentTree = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                currentTree-&gt;left = left;</span><br><span class="line">                currentTree-&gt;right = right;</span><br><span class="line">                allTrees.<span class="built_in">push_back</span>(currentTree);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allTrees;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">generateTrees</span>(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="222-完全二叉树的节点个数"><a class="header-anchor" href="#222-完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划"><a class="header-anchor" href="#动态规划"></a>动态规划</h4>
<h5 id="解释-v2"><a class="header-anchor" href="#解释-v2"></a>解释</h5>
<blockquote></blockquote>
<h5 id="题型"><a class="header-anchor" href="#题型"></a>题型</h5>
<h4 id="哈希"><a class="header-anchor" href="#哈希"></a>哈希</h4>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h5 id="n数和"><a class="header-anchor" href="#n数和"></a>n数和</h5>
<p>见上面数组n数和问题</p>
<h5 id="一般题"><a class="header-anchor" href="#一般题"></a>一般题</h5>
<h6 id="242-有效的字母异位词"><a class="header-anchor" href="#242-有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h6>
<p>用hash判断即可</p>
<h6 id="349-两个数组的交集"><a class="header-anchor" href="#349-两个数组的交集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;kvm;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : nums1)</span><br><span class="line">        kvm[c]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : nums2)</span><br><span class="line">        <span class="keyword">if</span> (kvm.<span class="built_in">find</span>(c) != kvm.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">insert</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="49-字母异位词分组"><a class="header-anchor" href="#49-字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : strs) &#123;</span><br><span class="line">        string temp = it;</span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">        result[temp].<span class="built_in">push_back</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; vecs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : result)</span><br><span class="line">    &#123;</span><br><span class="line">        vecs.<span class="built_in">push_back</span>(it.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vecs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵"><a class="header-anchor" href="#矩阵"></a>矩阵</h4>
<h5 id="一般题-v2"><a class="header-anchor" href="#一般题-v2"></a>一般题</h5>
<h6 id="73-矩阵置零"><a class="header-anchor" href="#73-矩阵置零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col = matrix.<span class="built_in">front</span>().<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rows</span><span class="params">(row, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cols</span><span class="params">(col, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rows[i] = <span class="number">1</span>;</span><br><span class="line">                cols[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rows[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// 该行置为0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cols[j] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 列置为0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="矩阵搜索"><a class="header-anchor" href="#矩阵搜索"></a>矩阵搜索</h5>
<h6 id="74-搜索二维矩阵"><a class="header-anchor" href="#74-搜索二维矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rows = matrix.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">search</span>(matrix[i], target);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一种解法就是搜索第一列确顶在哪一行种，然后搜索那一行，时间复杂度将会降低到 log(m) + log(n)?</span></span><br></pre></td></tr></table></figure>
<h6 id="240-搜索二维矩阵-II"><a class="header-anchor" href="#240-搜索二维矩阵-II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用74.解法 nlogn</span></span><br><span class="line">...  </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="二维数组旋转排布问题"><a class="header-anchor" href="#二维数组旋转排布问题"></a>二维数组旋转排布问题</h5>
<h6 id="48-旋转图像"><a class="header-anchor" href="#48-旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tranverse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">front</span>().<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">front</span>().<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = matrix[i][right];</span><br><span class="line">            matrix[i][right] = matrix[i][left];</span><br><span class="line">            matrix[i][left] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Tranverse</span>(matrix);</span><br><span class="line">    <span class="built_in">Reverse</span>(matrix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="54-螺旋矩阵"><a class="header-anchor" href="#54-螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, bottom = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt;= right; ++j) result.<span class="built_in">push_back</span>(matrix[top][j]);</span><br><span class="line">        ++top;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= bottom; ++i) result.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">        --right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (top &lt;= bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = right; j &gt;= left; --j) result.<span class="built_in">push_back</span>(matrix[bottom][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        --bottom;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = bottom; i &gt;= top; --i) result.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">        &#125;</span><br><span class="line">        ++left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈"><a class="header-anchor" href="#栈"></a>栈</h4>
<h6 id="20-有效的括号"><a class="header-anchor" href="#20-有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; st.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; st.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; st.<span class="built_in">top</span>() != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			st.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="155-最小栈"><a class="header-anchor" href="#155-最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="type">int</span> min = INT_MAX;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">updateMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (v[i] &lt; min) &#123;</span><br><span class="line">				min = v[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; min) &#123;</span><br><span class="line">            min = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v[v.<span class="built_in">size</span>() - <span class="number">1</span>] == min)</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">pop_back</span>();</span><br><span class="line">            min = INT_MAX;</span><br><span class="line">            <span class="built_in">updateMin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			v.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v[v.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">updateMin</span>();</span><br><span class="line">		<span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="394-字符串解码"><a class="header-anchor" href="#394-字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	stack&lt;mpair&gt; st;</span><br><span class="line">	mpair p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p.num = p.num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			st.<span class="built_in">push</span>(p);</span><br><span class="line">			p.num = <span class="number">0</span>;</span><br><span class="line">			p.str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			mpair top = st.<span class="built_in">top</span>();</span><br><span class="line">			st.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; top.num; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				top.str += p.str;</span><br><span class="line">			&#125;</span><br><span class="line">			p.str = top.str;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p.str += s[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p.str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="739-每日温度"><a class="header-anchor" href="#739-每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; indexStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!indexStack.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">            temperatures[i] &gt; temperatures[indexStack.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            <span class="type">int</span> index = indexStack.<span class="built_in">top</span>();</span><br><span class="line">            indexStack.<span class="built_in">pop</span>();</span><br><span class="line">            ans[index] = i - index;</span><br><span class="line">        &#125;</span><br><span class="line">        indexStack.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="84-柱状图中最大的矩形"><a class="header-anchor" href="#84-柱状图中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> sze = heights.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">width</span><span class="params">(sze, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sze; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; heights[st.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">			st.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			width[i] += i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			width[i] += i - st.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		st.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = sze - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; heights[st.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">			st.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (st.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			width[i] += sze - i - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			width[i] += st.<span class="built_in">top</span>() - i - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		st.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">		ret = <span class="built_in">max</span>(ret, width[i] * heights[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="堆"><a class="header-anchor" href="#堆"></a>堆</h4>
<h6 id="215-数组中的第K个最大元素"><a class="header-anchor" href="#215-数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt;</span><br><span class="line">        pq; <span class="comment">// 小顶堆，堆顶是最小元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> e : nums) &#123;</span><br><span class="line">        <span class="comment">// 每个元素都要过一遍二叉堆</span></span><br><span class="line">        pq.<span class="built_in">push</span>(e);</span><br><span class="line">        <span class="comment">// 堆中元素多于 k 个时，删除堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pq 中剩下的是 nums 中 k 个最大元素，</span></span><br><span class="line">    <span class="comment">// 堆顶是最小的那个，即第 k 个最大元素</span></span><br><span class="line">    <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="347-前-K-个高频元素"><a class="header-anchor" href="#347-前-K-个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">		freq[num]++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = freq.<span class="built_in">begin</span>(); it != freq.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pq.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">			<span class="keyword">if</span> (it-&gt;second &gt; pq.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">				pq.<span class="built_in">pop</span>();</span><br><span class="line">				pq.<span class="built_in">push</span>(&#123; it-&gt;second, it-&gt;first &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			pq.<span class="built_in">push</span>(&#123; it-&gt;second, it-&gt;first &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		res.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="295-数据流的中位数"><a class="header-anchor" href="#295-数据流的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; maxHeap;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &gt; maxHeap.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">			minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">			maxHeap.<span class="built_in">push</span>(minHeap.<span class="built_in">top</span>());</span><br><span class="line">			minHeap.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">			maxHeap.<span class="built_in">push</span>(num);</span><br><span class="line">			minHeap.<span class="built_in">push</span>(maxHeap.<span class="built_in">top</span>());</span><br><span class="line">			maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() == maxHeap.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (minHeap.<span class="built_in">top</span>() + maxHeap.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> minHeap.<span class="built_in">top</span>();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="其它-v2"><a class="header-anchor" href="#其它-v2"></a>其它</h4>
<h6 id="136-只出现一次的数字"><a class="header-anchor" href="#136-只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></h6>
<blockquote>
<ol>
<li>交换律：a ^ b ^ c &lt;=&gt; a ^ c ^ b</li>
<li>任何数于0异或为任何数 0 ^ n =&gt; n</li>
<li>相同的数异或为0: n ^ n =&gt; 0</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tr ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="169-多数元素"><a class="header-anchor" href="#169-多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h6>
<blockquote>
<ol>
<li>遍历给定的数组 <code>nums</code> 中的每一个数 <code>num</code>。</li>
<li>如果 <code>count</code> 为 0，表示当前没有候选者或者前一个候选者的支持度已经被完全抵消，因此将当前的数 <code>num</code> 设为新的候选者。</li>
<li>然后，如果当前的数 <code>num</code> 等于候选者 <code>candidate</code>，则 <code>count</code> 增加 1（增加支持度）；否则 <code>count</code> 减少 1（减少支持度）</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> candidate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            candidate = nums[i];</span><br><span class="line">		count += (nums[i] == candidate) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="75-颜色分类"><a class="header-anchor" href="#75-颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c0 = <span class="number">0</span>, c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[c2++] = <span class="number">2</span>;</span><br><span class="line">            nums[c1++] = <span class="number">1</span>;</span><br><span class="line">            nums[c0++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[c2++] = <span class="number">2</span>;</span><br><span class="line">            nums[c1++] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[c2++] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="31-下一个排列"><a class="header-anchor" href="#31-下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = n - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) i--;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">/// 找不到这样的顺序队列，说明已经是最大的排列，直接翻转</span></span><br><span class="line">		<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 从后往前找到第一个比nums[i]大的数</span></span><br><span class="line">    <span class="keyword">while</span> (nums[j] &lt;= nums[i])j--;</span><br><span class="line">	<span class="comment">// 交换两个数, 交换后i后面的数仍然是降序排列的, 所以直接翻转</span></span><br><span class="line">	<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">	<span class="comment">// 翻转i后面的数</span></span><br><span class="line">	<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="287-寻找重复数"><a class="header-anchor" href="#287-寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (slow != fast)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = nums[slow];</span><br><span class="line">		fast = nums[nums[fast]];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	slow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (slow != fast)</span><br><span class="line">	&#123;</span><br><span class="line">		slow = nums[slow];</span><br><span class="line">		fast = nums[fast];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="练习"><a class="header-anchor" href="#练习"></a>练习</h1>
<h3 id="LCH-100"><a class="header-anchor" href="#LCH-100"></a>LCH 100</h3>
<h5 id="链表-v2"><a class="header-anchor" href="#链表-v2"></a>链表</h5>
<h6 id="160-相交链表"><a class="header-anchor" href="#160-相交链表"></a>160.相交链表</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetLength</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">MoveSteps</span><span class="params">(ListNode* head,<span class="type">int</span> steps = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (steps--)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lengthA = <span class="built_in">GetLength</span>(headA);</span><br><span class="line">    <span class="type">int</span> lengthB = <span class="built_in">GetLength</span>(headB);</span><br><span class="line"></span><br><span class="line">    ListNode* newStartA = headA;</span><br><span class="line">    ListNode* newStartB = headB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> moveStep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lengthA &gt; lengthB) &#123;</span><br><span class="line">        moveStep = lengthA - lengthB;</span><br><span class="line">        newStartA = <span class="built_in">MoveSteps</span>(newStartA, moveStep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lengthB &gt;= lengthA)</span><br><span class="line">    &#123;</span><br><span class="line">        moveStep = lengthB - lengthA;</span><br><span class="line">        newStartB = <span class="built_in">MoveSteps</span>(newStartB, moveStep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (newStartA != <span class="literal">nullptr</span> &amp;&amp; newStartB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newStartA == newStartB)</span><br><span class="line">            <span class="keyword">return</span> newStartA;</span><br><span class="line">        newStartA = newStartA-&gt;next;</span><br><span class="line">        newStartB = newStartB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="206-反转链表"><a class="header-anchor" href="#206-反转链表"></a>206.反转链表</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList_It</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* tempHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* nxt = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tempHead-&gt;next;</span><br><span class="line">        tempHead-&gt;next = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* he = tempHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempHead;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归法 : 具体请参看总结部分</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList_rec</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* res = <span class="built_in">reverseList_rec</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="234-回文链表"><a class="header-anchor" href="#234-回文链表"></a>234.回文链表</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法1</span></span><br><span class="line"><span class="comment">// 1.找中间点</span></span><br><span class="line"><span class="comment">// 2.逆序后半部分</span></span><br><span class="line"><span class="comment">// 3.对比查找</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLength</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Get</span><span class="params">(ListNode* head,<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index--)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode* lastLayerResult = <span class="built_in">reverse</span>(head-&gt;next);</span><br><span class="line"></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> lastLayerResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> halfLen = <span class="built_in">GetLength</span>(head) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (halfLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ListNode* previousHalfNode = <span class="built_in">Get</span>(head, halfLen<span class="number">-1</span>);</span><br><span class="line">    ListNode* halfNode = previousHalfNode-&gt;next;</span><br><span class="line">    previousHalfNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    halfNode = <span class="built_in">reverse</span>(halfNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (halfNode != <span class="literal">nullptr</span> &amp;&amp; head != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (halfNode-&gt;val == head-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            halfNode = halfNode-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="141-环链表"><a class="header-anchor" href="#141-环链表"></a>141.环链表</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast!=<span class="literal">nullptr</span> &amp;&amp; fast-&gt;next!= <span class="literal">nullptr</span> &amp;&amp; slow != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; slow != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span> (slow != fast)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="21-有序链表合并"><a class="header-anchor" href="#21-有序链表合并"></a>21.有序链表合并</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.优先级队列解法</span></span><br><span class="line"><span class="comment">// 小顶堆 &gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_greater</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> ListNode <span class="type">const</span> *lf,<span class="type">const</span> ListNode <span class="type">const</span> *rg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lf-&gt;val &gt; rg-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, my_greater&gt; pq;</span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* node = list1;</span><br><span class="line">        list1 = list1-&gt;next;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        pq.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (list2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* node = list2;</span><br><span class="line">        list2 = list2-&gt;next;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        pq.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* mt = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode* cur = mt;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* n = pq.<span class="built_in">top</span>();</span><br><span class="line">        cur-&gt;next = n;</span><br><span class="line">        cur = n;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* f = mt-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> mt;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-两数相加"><a class="header-anchor" href="#2-两数相加"></a>2.两数相加</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* cur1 = l1; ListNode* cur2 = l2;</span><br><span class="line"></span><br><span class="line">    ListNode* result = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode* curR = result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sum</span></span><br><span class="line">    <span class="keyword">while</span> (cur1!=<span class="literal">nullptr</span> &amp;&amp; cur2!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur1-&gt;val +cur2-&gt;val, <span class="literal">nullptr</span>);</span><br><span class="line">        curR-&gt;next = newNode;</span><br><span class="line">        curR = curR-&gt;next;</span><br><span class="line"></span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">if</span> (cur1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        curR-&gt;next = cur2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur2 == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        curR-&gt;next = cur1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//step</span></span><br><span class="line">    ListNode* cur_step = result-&gt;next;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur_step!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur_step-&gt;val += step;</span><br><span class="line">        step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur_step-&gt;val &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            step = <span class="number">1</span>;</span><br><span class="line">            cur_step-&gt;val %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cur_step = cur_step-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get last</span></span><br><span class="line">    cur_step = result;</span><br><span class="line">    <span class="keyword">while</span> (cur_step-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur_step = cur_step-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (step == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur_step-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        cur_step = cur_step-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur_step = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* r = result-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> result;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="19-删除倒数节点"><a class="header-anchor" href="#19-删除倒数节点"></a>19.删除倒数节点</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode* tempHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode* fast = tempHead, * slow = tempHead;</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* toDel = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = toDel-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> toDel;</span><br><span class="line"></span><br><span class="line">    ListNode* he = tempHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempHead;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="24-两辆交换"><a class="header-anchor" href="#24-两辆交换"></a>24.两辆交换</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(ListNode* prev)</span> </span>&#123;</span><br><span class="line">    ListNode* left = prev-&gt;next;</span><br><span class="line">    ListNode* right = prev-&gt;next-&gt;next;</span><br><span class="line">    left-&gt;next = right-&gt;next;</span><br><span class="line">    right-&gt;next = left;</span><br><span class="line">    prev-&gt;next = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckPair</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">nullptr</span> &amp;&amp; head-&gt;next != <span class="literal">nullptr</span> &amp;&amp; head-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* tempHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode* cur = tempHead;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">CheckPair</span>(cur))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(cur);</span><br><span class="line">        cur = cur-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* toRet = tempHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempHead;</span><br><span class="line">    <span class="keyword">return</span> toRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.递归</span></span><br><span class="line"><span class="comment">// head is pair&#x27;s head  ...-&gt;head-&gt;left-&gt;right-&gt;...</span></span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;  <span class="comment">// 如果列表为空或只有一个节点，直接返回头节点</span></span><br><span class="line">    <span class="comment">// 进行节点交换</span></span><br><span class="line">    ListNode* first = head;</span><br><span class="line">    ListNode* second = head-&gt;next;</span><br><span class="line">    <span class="comment">// 递归调用函数交换后续节点</span></span><br><span class="line">    first-&gt;next = <span class="built_in">swapPairs</span>(second-&gt;next);</span><br><span class="line">    <span class="comment">// 交换当前的两个节点</span></span><br><span class="line">    second-&gt;next = first;</span><br><span class="line">    <span class="comment">// &#x27;second&#x27; 成为这一对的新头部</span></span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="25-k个一组反转"><a class="header-anchor" href="#25-k个一组反转"></a>25.k个一组反转</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.迭代法 </span></span><br><span class="line"><span class="comment">// 假设区间为[a,b),反转该区间内的元素</span></span><br><span class="line"><span class="function">ListNode* <span class="title">Reverse</span><span class="params">(ListNode* head, ListNode* end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* tempHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="comment">/// 记录原首节点（反转必为末节点）</span></span><br><span class="line">    ListNode* last = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != end)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* nxt = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tempHead-&gt;next;</span><br><span class="line">        tempHead-&gt;next = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 原首节点（末节点）衔接上end以及后的元素</span></span><br><span class="line">    last-&gt;next = cur;</span><br><span class="line">    ListNode* he = tempHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempHead;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* tempHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode* cur = tempHead;</span><br><span class="line">    ListNode* start = tempHead;</span><br><span class="line">    <span class="type">int</span> count = k;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 记录原首节点</span></span><br><span class="line">            ListNode* first = start-&gt;next;</span><br><span class="line">            <span class="comment">// 反转[start.next, cur.next)部分</span></span><br><span class="line">            ListNode* newStart = <span class="built_in">Reverse</span>(start-&gt;next, cur-&gt;next);</span><br><span class="line">            <span class="comment">// 将反转后头与上一尾相连</span></span><br><span class="line">            start-&gt;next = newStart;</span><br><span class="line">            <span class="comment">// 更新start 到为尾节点</span></span><br><span class="line">            start = first;</span><br><span class="line">            <span class="comment">// 置 k</span></span><br><span class="line">            count = k;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* re = tempHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempHead;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.递归法</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件检查</span></span><br><span class="line">    <span class="keyword">if</span> (head == null) <span class="keyword">return</span> null;</span><br><span class="line">    <span class="comment">// 对当前问题进行一些处理或简化，准备下一步递归</span></span><br><span class="line">    ListNode a, b;</span><br><span class="line">    a = b = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="comment">// 不足 k 个，不需要反转，base case</span></span><br><span class="line">        <span class="keyword">if</span> (b == null) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">    ListNode newHead = <span class="built_in">reverse</span>(a, b);</span><br><span class="line">    <span class="comment">// 递归反转后续链表并连接起来 -  递归调用自身，解决更小或更简化的问题</span></span><br><span class="line">    a.next = <span class="built_in">reverseKGroup</span>(b, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="138-随即链表复制"><a class="header-anchor" href="#138-随即链表复制"></a>138.随即链表复制</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Copy1</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* tempHead = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>);</span><br><span class="line">    Node* cur = head;</span><br><span class="line">    Node* curT = tempHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">        curT-&gt;next = newNode;</span><br><span class="line">        curT = curT-&gt;next;</span><br><span class="line"></span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* re = tempHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempHead;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPos</span><span class="params">(Node* head, Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Node* cur = head;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == node)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">GetNodeByPos</span><span class="params">(Node* head, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    Node* tempHead = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>);</span><br><span class="line">    tempHead-&gt;next = head;</span><br><span class="line">    Node* cur = tempHead;</span><br><span class="line">    <span class="keyword">while</span> (pos-- &amp;&amp; cur != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> tempHead;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy2</span><span class="params">(Node* head, Node* lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* curH = head;</span><br><span class="line">    Node* curL = lst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curH!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">FindPos</span>(head, curH-&gt;random);</span><br><span class="line">        Node* rand = <span class="built_in">GetNodeByPos</span>(lst, pos);</span><br><span class="line">        curL-&gt;random = rand;</span><br><span class="line">        curH = curH-&gt;next;</span><br><span class="line">        curL = curL-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    Node* newN = <span class="built_in">Copy1</span>(head);</span><br><span class="line">    <span class="built_in">Copy2</span>(head, newN);</span><br><span class="line">    <span class="keyword">return</span> newN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="148-排序链表"><a class="header-anchor" href="#148-排序链表"></a>148.排序链表</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 链表排序</span></span><br><span class="line"><span class="comment">// 1.堆法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_greater</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> ListNode* <span class="type">const</span> l, <span class="type">const</span> ListNode* <span class="type">const</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l-&gt;val &gt; r-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Sort1</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, my_greater&gt; pq;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(cur);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* temphead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode* curT = temphead;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* n = pq.<span class="built_in">top</span>();</span><br><span class="line">        curT-&gt;next = n;</span><br><span class="line">        n-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        curT = curT-&gt;next;</span><br><span class="line"></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* re = temphead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temphead;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 原地置换法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">insertSorted</span><span class="params">(ListNode* sortedHead, ListNode* newNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortedHead == <span class="literal">nullptr</span> || sortedHead-&gt;val &gt;= newNode-&gt;val) &#123;</span><br><span class="line">        newNode-&gt;next = sortedHead;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* current = sortedHead;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span> &amp;&amp; current-&gt;next-&gt;val &lt; newNode-&gt;val) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;next = current-&gt;next;</span><br><span class="line">    current-&gt;next = newNode;</span><br><span class="line">    <span class="keyword">return</span> sortedHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* sortedHead = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* next = current-&gt;next;</span><br><span class="line">        sortedHead = <span class="built_in">insertSorted</span>(sortedHead, current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="23-合并K个升序链表"><a class="header-anchor" href="#23-合并K个升序链表"></a>23.合并K个升序链表</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">my_greater</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> ListNode* <span class="type">const</span> l, <span class="type">const</span> ListNode* <span class="type">const</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l-&gt;val &gt; r-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, my_greater&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = lists.<span class="built_in">begin</span>(); it != lists.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        ListNode* head = *it;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* temphead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode* curT = temphead;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* n = pq.<span class="built_in">top</span>();</span><br><span class="line">        curT-&gt;next = n;</span><br><span class="line">        n-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        curT = curT-&gt;next;</span><br><span class="line"></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* re = temphead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temphead;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="146-LRU"><a class="header-anchor" href="#146-LRU"></a>146.LRU</h6>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; lst; <span class="comment">// 存储 (key, value) 对</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; kvm;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">cap</span>(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = kvm.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == kvm.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将元素移动到列表前端</span></span><br><span class="line">            lst.<span class="built_in">splice</span>(lst.<span class="built_in">begin</span>(), lst, it-&gt;second);</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = kvm.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != kvm.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 更新值并移动到列表前端</span></span><br><span class="line">            it-&gt;second-&gt;second = value;</span><br><span class="line">            lst.<span class="built_in">splice</span>(lst.<span class="built_in">begin</span>(), lst, it-&gt;second);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lst.<span class="built_in">size</span>() == cap) &#123;</span><br><span class="line">                <span class="comment">// 删除最久未使用的元素</span></span><br><span class="line">                <span class="keyword">auto</span> last = lst.<span class="built_in">back</span>();</span><br><span class="line">                kvm.<span class="built_in">erase</span>(last.first);</span><br><span class="line">                lst.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入新元素到列表前端</span></span><br><span class="line">            lst.<span class="built_in">emplace_front</span>(key, value);</span><br><span class="line">            kvm[key] = lst.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : lst) &#123;</span><br><span class="line">            cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">( const_iterator pos, list&amp; other)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">( const_iterator pos, list&amp;&amp; other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">( const_iterator pos, list&amp; other, const_iterator it)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">( const_iterator pos, list&amp;&amp; other, const_iterator it)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">( const_iterator pos, list&amp; other, const_iterator first, const_iterator last)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">( const_iterator pos, list&amp;&amp; other, const_iterator first, const_iterator last )</span></span>;</span><br><span class="line"><span class="comment">//第一组是将other链表中的所有要素转移到当前链表，插入位置为pos指向的位置之前，执行此操作后，other容器将为空。</span></span><br><span class="line"><span class="comment">//第二组是将other链表中迭代器it所指的要素转移给当前链表，插入位置为pos指向的位置之前。</span></span><br><span class="line"><span class="comment">//第三组是将other链表中[first, end)范围内的要素转移给当前链表，同样插入位置为pos指向的位置之前</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="总结-基本操作之反转"><a class="header-anchor" href="#总结-基本操作之反转"></a>总结:基本操作之反转</h6>
<p>根据上述刷题总结，我们得到最爱考查的是链表反转问题，其中链表反转有又有2种变型，现总结如下：</p>
<blockquote>
<ol>
<li>
<p>直接反转整个</p>
<p>该类问题较为简单，涉及源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList_It</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* tempHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* nxt = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tempHead-&gt;next;</span><br><span class="line">        tempHead-&gt;next = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* he = tempHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempHead;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList_rec</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// 递归调用自身，解决更小或更简化的问题</span></span><br><span class="line">    ListNode* start_node_after_reverse = <span class="built_in">reverseList_rec</span>(head-&gt;next);</span><br><span class="line">    <span class="comment">// 使用递归得到的结果来构建当前问题的解</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//返回当前问题的解</span></span><br><span class="line">    <span class="keyword">return</span> start_node_after_reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>区间反转</p>
<p>这个在于区间反转其中某部分，我们可能会需要start和end</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代法 假设区间为[a,b)</span></span><br><span class="line"><span class="function">ListNode* <span class="title">Reverse</span><span class="params">(ListNode* head, ListNode* end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* tempHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="comment">/// 记录原首节点（反转必为末节点）</span></span><br><span class="line">    ListNode* last = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=end)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* nxt = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tempHead-&gt;next;</span><br><span class="line">        tempHead-&gt;next = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 原首节点（末节点）衔接上end以及后的元素</span></span><br><span class="line">    last-&gt;next = cur;</span><br><span class="line">    ListNode* he = tempHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tempHead;</span><br><span class="line">    <span class="keyword">return</span> he;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="comment">// 1.反转前n节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当不需要反转，或者链表为空时，直接返回原链表</span></span><br><span class="line">    <span class="keyword">if</span> (m == n) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> ListNode* successor = <span class="literal">nullptr</span>;  <span class="comment">// 用来保存第 n + 1 个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 从第一个节点开始反转</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理，直到找到起始反转的节点</span></span><br><span class="line">    head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode* successor = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 反转链表的前 n 个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        successor = head-&gt;next;  <span class="comment">// 保存第 n + 1 个节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* last = <span class="built_in">reverseN</span>(head-&gt;next, n - <span class="number">1</span>);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>K组反转 - 迭代&amp;递归 参考25.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代法(略)</span></span><br><span class="line"><span class="comment">// 递归法(略)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h5 id="数组-v2"><a class="header-anchor" href="#数组-v2"></a>数组</h5>
<h6 id="283-移动0"><a class="header-anchor" href="#283-移动0"></a>283.移动0</h6>
<p>(见数组基础问题章节)</p>
<h6 id="1-两数和"><a class="header-anchor" href="#1-两数和"></a>1.两数和</h6>
<p>(见数组基础问题章节)</p>
<h6 id="15-三数和"><a class="header-anchor" href="#15-三数和"></a>15.三数和</h6>
<p>(见数组基础问题章节)</p>
<h6 id="35-插入位置"><a class="header-anchor" href="#35-插入位置"></a>35.插入位置</h6>
<p>(见数组基础问题章节)</p>
<h6 id="283-移动零"><a class="header-anchor" href="#283-移动零"></a>283.移动零</h6>
<p>(见数组基础问题章节)</p>
<h6 id="3-无重复字符的最长子串-v2"><a class="header-anchor" href="#3-无重复字符的最长子串-v2"></a>3.无重复字符的最长子串</h6>
<p>(见数组基础问题章节)</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/design/avatar/96275146_p0_master1200.jpg" data-sites="facebook,twitter,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/04/24/DesignPatterns/" title="设计模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/design/avatar/96275146_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ninokz</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ninokz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Ninokz" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1137876240@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://twitter.com/" target="_blank" title="Twitter"><i class="fab fa-twitter" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">本站缓慢施工中...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2-%E5%B7%A6%E5%8F%B3index"><span class="toc-number">1.0.1.0.1.</span> <span class="toc-text">快慢&amp;左右index</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#26-%E5%8A%9B%E6%89%A3-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.0.1.0.1.1.</span> <span class="toc-text">26.力扣-有序数组去重</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.0.1.0.1.2.</span> <span class="toc-text">27.移除元素</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8-0"><span class="toc-number">1.0.1.0.1.3.</span> <span class="toc-text">283.移动 0</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">1.0.1.0.1.4.</span> <span class="toc-text">5.最长回文子串</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">1.0.1.0.1.5.</span> <span class="toc-text">977.有序数组的平方</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.1.0.1.6.</span> <span class="toc-text">11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">1.0.1.0.1.7.</span> <span class="toc-text">42. 接雨水</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.0.2.</span> <span class="toc-text">二分问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.0.1.0.2.1.</span> <span class="toc-text">704.二分查找</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.0.1.0.2.2.</span> <span class="toc-text">35. 搜索插入位置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.0.1.0.2.3.</span> <span class="toc-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%80%BC"><span class="toc-number">1.0.1.0.2.4.</span> <span class="toc-text">33. 搜索旋转排序数组-无重复值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II-%E6%9C%89%E9%87%8D%E5%A4%8D%E5%80%BC"><span class="toc-number">1.0.1.0.2.5.</span> <span class="toc-text">81. 搜索旋转排序数组 II-有重复值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-%E5%A4%9A%E6%AC%A1%E6%97%8B%E8%BD%AC"><span class="toc-number">1.0.1.0.2.6.</span> <span class="toc-text">153. 寻找旋转排序数组中的最小值-多次旋转</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">1.0.1.0.2.7.</span> <span class="toc-text">4. 寻找两个正序数组的中位数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.0.1.0.3.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">1.0.1.0.3.1.</span> <span class="toc-text">76.最小覆盖子串</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">1.0.1.0.3.2.</span> <span class="toc-text">567. 字符串的排列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">1.0.1.0.3.3.</span> <span class="toc-text">438. 找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.1.0.3.4.</span> <span class="toc-text">209.长度最小的子数组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">1.0.1.0.3.5.</span> <span class="toc-text">3. 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">1.0.1.0.3.6.</span> <span class="toc-text">128. 最长连续序列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">1.0.1.0.3.7.</span> <span class="toc-text">239. 滑动窗口最大值*</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#n%E6%95%B0%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.0.4.</span> <span class="toc-text">n数和问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#167-%E4%B8%A4%E6%95%B0%E5%92%8CII-%E6%95%B0%E7%BB%84%E6%9C%89%E5%BA%8F"><span class="toc-number">1.0.1.0.4.1.</span> <span class="toc-text">167.两数和II - 数组有序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E5%92%8C-%E6%95%B0%E7%BB%84%E6%97%A0%E5%BA%8F"><span class="toc-number">1.0.1.0.4.2.</span> <span class="toc-text">1.两数和 - 数组无序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E5%92%8C-%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.1.0.4.3.</span> <span class="toc-text">15.三数和-无序数组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#18-%E5%9B%9B%E6%95%B0%E5%92%8C-%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.1.0.4.4.</span> <span class="toc-text">18.四数和-无序数组</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.0.1.0.5.</span> <span class="toc-text">数组前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">1.0.1.0.5.1.</span> <span class="toc-text">303. 区域和检索 - 数组不可变</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#304-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">1.0.1.0.5.2.</span> <span class="toc-text">304. 二维区域和检索 - 矩阵不可变</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C-hash%E8%A1%A8%E7%BB%93%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.0.6.</span> <span class="toc-text">前缀和&amp;hash表结合问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#523-%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-%E6%B6%89%E5%8F%8Ahash"><span class="toc-number">1.0.1.0.6.1.</span> <span class="toc-text">523. 连续的子数组和 - 涉及hash</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84-%E6%B6%89%E5%8F%8Ahash"><span class="toc-number">1.0.1.0.6.2.</span> <span class="toc-text">525. 连续数组 - 涉及hash</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.1.0.6.3.</span> <span class="toc-text">560. 和为 K 的子数组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.1.0.6.4.</span> <span class="toc-text">差分数组</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">1.0.1.0.7.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">1.0.1.0.7.1.</span> <span class="toc-text">56. 合并区间</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.1.0.7.2.</span> <span class="toc-text">189. 轮转数组</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-number">1.0.1.0.7.3.</span> <span class="toc-text">238. 除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="toc-number">1.0.1.0.7.4.</span> <span class="toc-text">41. 缺失的第一个正数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.0.1.1.1.</span> <span class="toc-text">移除元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-number">1.0.1.1.2.</span> <span class="toc-text">设计链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.0.1.1.3.</span> <span class="toc-text">翻转链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="toc-number">1.0.1.1.4.</span> <span class="toc-text">两两交换链表节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0N%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">1.0.1.1.5.</span> <span class="toc-text">删除链表倒数N个节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">1.0.1.1.6.</span> <span class="toc-text">链表相交</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.0.1.1.7.</span> <span class="toc-text">环链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">1.0.1.1.8.</span> <span class="toc-text">快慢指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%E8%A7%A3%E9%87%8A"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">递归问题解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">1.0.1.3.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.1.3.2.</span> <span class="toc-text">普通二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.1.3.2.1.</span> <span class="toc-text">226. 翻转二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">1.0.1.3.2.2.</span> <span class="toc-text">116. 填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">1.0.1.3.2.3.</span> <span class="toc-text">114. 二叉树展开为链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-number">1.0.1.3.2.4.</span> <span class="toc-text">543. 二叉树的直径</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.1.3.2.5.</span> <span class="toc-text">654. 最大二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.1.3.2.6.</span> <span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.1.3.2.7.</span> <span class="toc-text">106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.1.3.2.8.</span> <span class="toc-text">889. 根据前序和后序遍历构造二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#652-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">1.0.1.3.2.9.</span> <span class="toc-text">652. 寻找重复的子树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.0.1.3.2.10.</span> <span class="toc-text">101. 对称二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.0.1.3.2.11.</span> <span class="toc-text">102. 二叉树的层序遍历</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.0.1.3.2.12.</span> <span class="toc-text">98. 验证二叉搜索树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.0.1.3.2.13.</span> <span class="toc-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">1.0.1.3.2.14.</span> <span class="toc-text">199. 二叉树的右视图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="toc-number">1.0.1.3.2.15.</span> <span class="toc-text">437. 路径总和 III</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">1.0.1.3.2.16.</span> <span class="toc-text">236. 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.0.1.3.2.17.</span> <span class="toc-text">297. 二叉树的序列化与反序列化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">1.0.1.3.2.18.</span> <span class="toc-text">124. 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.1.3.2.19.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.1.3.2.20.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BST"><span class="toc-number">1.0.1.3.3.</span> <span class="toc-text">BST</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#BST%E6%90%9C%E7%B4%A2"><span class="toc-number">1.0.1.3.3.1.</span> <span class="toc-text">BST搜索</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#BST%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.0.1.3.3.2.</span> <span class="toc-text">BST的插入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#BST%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.0.1.3.3.3.</span> <span class="toc-text">BST的删除</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.0.1.3.3.4.</span> <span class="toc-text">96. 不同的二叉搜索树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II"><span class="toc-number">1.0.1.3.3.5.</span> <span class="toc-text">95. 不同的二叉搜索树 II</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">1.0.1.3.3.6.</span> <span class="toc-text">222. 完全二叉树的节点个数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-v2"><span class="toc-number">1.0.1.4.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B"><span class="toc-number">1.0.1.4.2.</span> <span class="toc-text">题型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#n%E6%95%B0%E5%92%8C"><span class="toc-number">1.0.1.5.1.</span> <span class="toc-text">n数和</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E9%A2%98"><span class="toc-number">1.0.1.5.2.</span> <span class="toc-text">一般题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">1.0.1.5.2.1.</span> <span class="toc-text">242. 有效的字母异位词</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">1.0.1.5.2.2.</span> <span class="toc-text">349. 两个数组的交集</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">1.0.1.5.2.3.</span> <span class="toc-text">49. 字母异位词分组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">1.0.1.6.</span> <span class="toc-text">矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E9%A2%98-v2"><span class="toc-number">1.0.1.6.1.</span> <span class="toc-text">一般题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="toc-number">1.0.1.6.1.1.</span> <span class="toc-text">73. 矩阵置零</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%90%9C%E7%B4%A2"><span class="toc-number">1.0.1.6.2.</span> <span class="toc-text">矩阵搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-number">1.0.1.6.2.1.</span> <span class="toc-text">74. 搜索二维矩阵</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="toc-number">1.0.1.6.2.2.</span> <span class="toc-text">240. 搜索二维矩阵 II</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%97%8B%E8%BD%AC%E6%8E%92%E5%B8%83%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.6.3.</span> <span class="toc-text">二维数组旋转排布问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-number">1.0.1.6.3.1.</span> <span class="toc-text">48. 旋转图像</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">1.0.1.6.3.2.</span> <span class="toc-text">54. 螺旋矩阵</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.0.1.7.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.0.1.7.0.1.</span> <span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">1.0.1.7.0.2.</span> <span class="toc-text">155. 最小栈</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-number">1.0.1.7.0.3.</span> <span class="toc-text">394. 字符串解码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-number">1.0.1.7.0.4.</span> <span class="toc-text">739. 每日温度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-number">1.0.1.7.0.5.</span> <span class="toc-text">84. 柱状图中最大的矩形</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.0.1.8.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">1.0.1.8.0.1.</span> <span class="toc-text">215. 数组中的第K个最大元素</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">1.0.1.8.0.2.</span> <span class="toc-text">347. 前 K 个高频元素</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">1.0.1.8.0.3.</span> <span class="toc-text">295. 数据流的中位数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83-v2"><span class="toc-number">1.0.1.9.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">1.0.1.9.0.1.</span> <span class="toc-text">136. 只出现一次的数字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-number">1.0.1.9.0.2.</span> <span class="toc-text">169. 多数元素</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-number">1.0.1.9.0.3.</span> <span class="toc-text">75. 颜色分类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">1.0.1.9.0.4.</span> <span class="toc-text">31. 下一个排列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="toc-number">1.0.1.9.0.5.</span> <span class="toc-text">287. 寻找重复数</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">2.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LCH-100"><span class="toc-number">2.0.1.</span> <span class="toc-text">LCH 100</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8-v2"><span class="toc-number">2.0.1.0.1.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.1.0.1.1.</span> <span class="toc-text">160.相交链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.1.0.1.2.</span> <span class="toc-text">206.反转链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.1.0.1.3.</span> <span class="toc-text">234.回文链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#141-%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.1.0.1.4.</span> <span class="toc-text">141.环链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#21-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6"><span class="toc-number">2.0.1.0.1.5.</span> <span class="toc-text">21.有序链表合并</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.0.1.0.1.6.</span> <span class="toc-text">2.两数相加</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E5%80%92%E6%95%B0%E8%8A%82%E7%82%B9"><span class="toc-number">2.0.1.0.1.7.</span> <span class="toc-text">19.删除倒数节点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#24-%E4%B8%A4%E8%BE%86%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.0.1.0.1.8.</span> <span class="toc-text">24.两辆交换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC"><span class="toc-number">2.0.1.0.1.9.</span> <span class="toc-text">25.k个一组反转</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#138-%E9%9A%8F%E5%8D%B3%E9%93%BE%E8%A1%A8%E5%A4%8D%E5%88%B6"><span class="toc-number">2.0.1.0.1.10.</span> <span class="toc-text">138.随即链表复制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.1.0.1.11.</span> <span class="toc-text">148.排序链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.1.0.1.12.</span> <span class="toc-text">23.合并K个升序链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#146-LRU"><span class="toc-number">2.0.1.0.1.13.</span> <span class="toc-text">146.LRU</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%8F%8D%E8%BD%AC"><span class="toc-number">2.0.1.0.1.14.</span> <span class="toc-text">总结:基本操作之反转</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-v2"><span class="toc-number">2.0.1.0.2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A80"><span class="toc-number">2.0.1.0.2.1.</span> <span class="toc-text">283.移动0</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E5%92%8C"><span class="toc-number">2.0.1.0.2.2.</span> <span class="toc-text">1.两数和</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E5%92%8C"><span class="toc-number">2.0.1.0.2.3.</span> <span class="toc-text">15.三数和</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#35-%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.0.1.0.2.4.</span> <span class="toc-text">35.插入位置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">2.0.1.0.2.5.</span> <span class="toc-text">283.移动零</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-v2"><span class="toc-number">2.0.1.0.2.6.</span> <span class="toc-text">3.无重复字符的最长子串</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/26/algorithms/" title="算法学习">算法学习</a><time datetime="2024-04-26T07:43:41.100Z" title="发表于 2024-04-26 15:43:41">2024-04-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/24/DesignPatterns/" title="设计模式">设计模式</a><time datetime="2024-04-24T05:37:04.014Z" title="发表于 2024-04-24 13:37:04">2024-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/23/csharplearning/" title="CSharp"><img src="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/article/cover/51432235_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSharp"/></a><div class="content"><a class="title" href="/2024/04/23/csharplearning/" title="CSharp">CSharp</a><time datetime="2024-04-23T13:20:00.267Z" title="发表于 2024-04-23 21:20:00">2024-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/22/computerbase/" title="计算机基础"><img src="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/article/cover/52793674_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机基础"/></a><div class="content"><a class="title" href="/2024/04/22/computerbase/" title="计算机基础">计算机基础</a><time datetime="2024-04-22T05:17:43.738Z" title="发表于 2024-04-22 13:17:43">2024-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/31/GNN/" title="GNN 学习回顾"><img src="https://observer-storage.oss-cn-chengdu.aliyuncs.com/img/article/cover/47470275_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GNN 学习回顾"/></a><div class="content"><a class="title" href="/2024/03/31/GNN/" title="GNN 学习回顾">GNN 学习回顾</a><time datetime="2024-03-31T14:52:55.605Z" title="发表于 2024-03-31 22:52:55">2024-03-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Ninokz</div><div class="footer_custom_text"><label style="font-family:楷体;font-size:14px">繁華如三千東流水</label></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>